---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...mk-tcp-model/mk-tcp-model   43.7   24.4   24.6   61.3    n/a  100.0   37.6
Total                          43.7   24.4   24.6   61.3    n/a  100.0   37.6
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu May  5 16:41:12 2011
Finish:       Thu May  5 16:41:12 2011

Run:          ./101_analyses.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu May  5 16:41:13 2011
Finish:       Thu May  5 16:41:13 2011

/home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     
3                                                     # This program is copyright 2007-@CURRENTYEAR@ Percona Inc.
4                                                     # Feedback and improvements are welcome.
5                                                     #
6                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
7                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
8                                                     # MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
9                                                     #
10                                                    # This program is free software; you can redistribute it and/or modify it under
11                                                    # the terms of the GNU General Public License as published by the Free Software
12                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
13                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
14                                                    # licenses.
15                                                    #
16                                                    # You should have received a copy of the GNU General Public License along with
17                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
18                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
19                                                    
20             1                    1             9   use strict;
               1                                  2   
               1                                  7   
21             1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  7   
22                                                    
23                                                    our $VERSION = '@VERSION@';
24                                                    our $DISTRIB = '@DISTRIB@';
25                                                    our $SVN_REV = sprintf("%d", (q$Revision: 7407 $ =~ m/(\d+)/g, 0));
26                                                    
27                                                    # ###########################################################################
28                                                    # OptionParser package 7102
29                                                    # This package is a copy without comments from the original.  The original
30                                                    # with comments and its test file can be found in the SVN repository at,
31                                                    #   trunk/common/OptionParser.pm
32                                                    #   trunk/common/t/OptionParser.t
33                                                    # See http://code.google.com/p/maatkit/wiki/Developers for more information.
34                                                    # ###########################################################################
35                                                    
36                                                    package OptionParser;
37                                                    
38             1                    1             6   use strict;
               1                                  2   
               1                                  5   
39             1                    1             5   use warnings FATAL => 'all';
               1                                  7   
               1                                  5   
40             1                    1             6   use List::Util qw(max);
               1                                  2   
               1                                 12   
41             1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  7   
42    ***      1            50      1             7   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 17   
43                                                    
44             1                    1            16   use Getopt::Long;
               1                                  3   
               1                                  7   
45                                                    
46                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
47                                                    
48                                                    sub new {
49             1                    1             5      my ( $class, %args ) = @_;
50             1                                  4      my @required_args = qw();
51             1                                  5      foreach my $arg ( @required_args ) {
52    ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
53                                                       }
54                                                    
55             1                                 11      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
56    ***      1            50                    4      $program_name ||= $PROGRAM_NAME;
57    ***      1            33                   10      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
58                                                    
59             1                                  9      my %attributes = (
60                                                          'type'       => 1,
61                                                          'short form' => 1,
62                                                          'group'      => 1,
63                                                          'default'    => 1,
64                                                          'cumulative' => 1,
65                                                          'negatable'  => 1,
66                                                       );
67                                                    
68             1                                 52      my $self = {
69                                                          head1             => 'OPTIONS',        # These args are used internally
70                                                          skip_rules        => 0,                # to instantiate another Option-
71                                                          item              => '--(.*)',         # Parser obj that parses the
72                                                          attributes        => \%attributes,     # DSN OPTIONS section.  Tools
73                                                          parse_attributes  => \&_parse_attribs, # don't tinker with these args.
74                                                    
75                                                          %args,
76                                                    
77                                                          strict            => 1,  # disabled by a special rule
78                                                          program_name      => $program_name,
79                                                          opts              => {},
80                                                          got_opts          => 0,
81                                                          short_opts        => {},
82                                                          defaults          => {},
83                                                          groups            => {},
84                                                          allowed_groups    => {},
85                                                          errors            => [],
86                                                          rules             => [],  # desc of rules for --help
87                                                          mutex             => [],  # rule: opts are mutually exclusive
88                                                          atleast1          => [],  # rule: at least one opt is required
89                                                          disables          => {},  # rule: opt disables other opts 
90                                                          defaults_to       => {},  # rule: opt defaults to value of other opt
91                                                          DSNParser         => undef,
92                                                          default_files     => [
93                                                             "/etc/maatkit/maatkit.conf",
94                                                             "/etc/maatkit/$program_name.conf",
95                                                             "$home/.maatkit.conf",
96                                                             "$home/.$program_name.conf",
97                                                          ],
98                                                          types             => {
99                                                             string => 's', # standard Getopt type
100                                                            int    => 'i', # standard Getopt type
101                                                            float  => 'f', # standard Getopt type
102                                                            Hash   => 'H', # hash, formed from a comma-separated list
103                                                            hash   => 'h', # hash as above, but only if a value is given
104                                                            Array  => 'A', # array, similar to Hash
105                                                            array  => 'a', # array, similar to hash
106                                                            DSN    => 'd', # DSN
107                                                            size   => 'z', # size with kMG suffix (powers of 2^10)
108                                                            time   => 'm', # time, with an optional suffix of s/h/m/d
109                                                         },
110                                                      };
111                                                   
112            1                                 15      return bless $self, $class;
113                                                   }
114                                                   
115                                                   sub get_specs {
116            1                    1             5      my ( $self, $file ) = @_;
117   ***      1            50                   13      $file ||= $self->{file} || __FILE__;
      ***                   50                        
118            1                                  4      my @specs = $self->_pod_to_specs($file);
119            1                                 15      $self->_parse_specs(@specs);
120                                                   
121   ***      1     50                          25      open my $fh, "<", $file or die "Cannot open $file: $OS_ERROR";
122            1                                  3      my $contents = do { local $/ = undef; <$fh> };
               1                                  5   
               1                                172   
123            1                                  6      close $fh;
124   ***      1     50                          31      if ( $contents =~ m/^=head1 DSN OPTIONS/m ) {
125   ***      0                                  0         MKDEBUG && _d('Parsing DSN OPTIONS');
126   ***      0                                  0         my $dsn_attribs = {
127                                                            dsn  => 1,
128                                                            copy => 1,
129                                                         };
130                                                         my $parse_dsn_attribs = sub {
131   ***      0                    0             0            my ( $self, $option, $attribs ) = @_;
132   ***      0                                  0            map {
133   ***      0                                  0               my $val = $attribs->{$_};
134   ***      0      0                           0               if ( $val ) {
135   ***      0      0                           0                  $val    = $val eq 'yes' ? 1
      ***             0                               
136                                                                          : $val eq 'no'  ? 0
137                                                                          :                 $val;
138   ***      0                                  0                  $attribs->{$_} = $val;
139                                                               }
140                                                            } keys %$attribs;
141                                                            return {
142   ***      0                                  0               key => $option,
143                                                               %$attribs,
144                                                            };
145   ***      0                                  0         };
146   ***      0                                  0         my $dsn_o = new OptionParser(
147                                                            description       => 'DSN OPTIONS',
148                                                            head1             => 'DSN OPTIONS',
149                                                            dsn               => 0,         # XXX don't infinitely recurse!
150                                                            item              => '\* (.)',  # key opts are a single character
151                                                            skip_rules        => 1,         # no rules before opts
152                                                            attributes        => $dsn_attribs,
153                                                            parse_attributes  => $parse_dsn_attribs,
154                                                         );
155   ***      0                                  0         my @dsn_opts = map {
156   ***      0                                  0            my $opts = {
157                                                               key  => $_->{spec}->{key},
158                                                               dsn  => $_->{spec}->{dsn},
159                                                               copy => $_->{spec}->{copy},
160                                                               desc => $_->{desc},
161                                                            };
162   ***      0                                  0            $opts;
163                                                         } $dsn_o->_pod_to_specs($file);
164   ***      0                                  0         $self->{DSNParser} = DSNParser->new(opts => \@dsn_opts);
165                                                      }
166                                                   
167            1                                  2      return;
168                                                   }
169                                                   
170                                                   sub DSNParser {
171   ***      0                    0             0      my ( $self ) = @_;
172   ***      0                                  0      return $self->{DSNParser};
173                                                   };
174                                                   
175                                                   sub get_defaults_files {
176            1                    1             4      my ( $self ) = @_;
177            1                                  3      return @{$self->{default_files}};
               1                                 10   
178                                                   }
179                                                   
180                                                   sub _pod_to_specs {
181            1                    1             4      my ( $self, $file ) = @_;
182   ***      1             0                    5      $file ||= $self->{file} || __FILE__;
      ***                   50                        
183   ***      1     50                          22      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
184                                                   
185            1                                  4      my @specs = ();
186            1                                  3      my @rules = ();
187            1                                  3      my $para;
188                                                   
189            1                                  6      local $INPUT_RECORD_SEPARATOR = '';
190            1                                 22      while ( $para = <$fh> ) {
191          308    100                        2362         next unless $para =~ m/^=head1 $self->{head1}/;
192            1                                  4         last;
193                                                      }
194                                                   
195            1                                  6      while ( $para = <$fh> ) {
196            2    100                          11         last if $para =~ m/^=over/;
197   ***      1     50                           5         next if $self->{skip_rules};
198            1                                  4         chomp $para;
199            1                                  9         $para =~ s/\s+/ /g;
200            1                                 29         $para =~ s/$POD_link_re/$1/go;
201            1                                  3         MKDEBUG && _d('Option rule:', $para);
202            1                                  7         push @rules, $para;
203                                                      }
204                                                   
205   ***      1     50                           4      die "POD has no $self->{head1} section" unless $para;
206                                                   
207            1                                  3      do {
208           10    100                          87         if ( my ($option) = $para =~ m/^=item $self->{item}/ ) {
209            8                                 27            chomp $para;
210            8                                 17            MKDEBUG && _d($para);
211            8                                 18            my %attribs;
212                                                   
213            8                                 26            $para = <$fh>; # read next paragraph, possibly attributes
214                                                   
215            8    100                          33            if ( $para =~ m/: / ) { # attributes
216            6                                 29               $para =~ s/\s+\Z//g;
217            8                                 37               %attribs = map {
218            6                                 28                     my ( $attrib, $val) = split(/: /, $_);
219   ***      8     50                          42                     die "Unrecognized attribute for --$option: $attrib"
220                                                                        unless $self->{attributes}->{$attrib};
221            8                                 41                     ($attrib, $val);
222                                                                  } split(/; /, $para);
223   ***      6     50                          26               if ( $attribs{'short form'} ) {
224   ***      0                                  0                  $attribs{'short form'} =~ s/-//;
225                                                               }
226            6                                 34               $para = <$fh>; # read next paragraph, probably short help desc
227                                                            }
228                                                            else {
229            2                                  5               MKDEBUG && _d('Option has no attributes');
230                                                            }
231                                                   
232            8                                 68            $para =~ s/\s+\Z//g;
233            8                                 71            $para =~ s/\s+/ /g;
234            8                                 55            $para =~ s/$POD_link_re/$1/go;
235                                                   
236            8                                 35            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
237            8                                 19            MKDEBUG && _d('Short help:', $para);
238                                                   
239   ***      8     50                          32            die "No description after option spec $option" if $para =~ m/^=item/;
240                                                   
241   ***      8     50                          34            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
242   ***      0                                  0               $option = $base_option;
243   ***      0                                  0               $attribs{'negatable'} = 1;
244                                                            }
245                                                   
246            8    100                          42            push @specs, {
      ***            50                               
247                                                               spec  => $self->{parse_attributes}->($self, $option, \%attribs), 
248                                                               desc  => $para
249                                                                  . (defined $attribs{default} ? " (default $attribs{default})" : ''),
250                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
251                                                            };
252                                                         }
253           10                                 63         while ( $para = <$fh> ) {
254   ***     20     50                          66            last unless $para;
255           20    100                          73            if ( $para =~ m/^=head1/ ) {
256            1                                  4               $para = undef; # Can't 'last' out of a do {} block.
257            1                                  4               last;
258                                                            }
259           19    100                         112            last if $para =~ m/^=item /;
260                                                         }
261                                                      } while ( $para );
262                                                   
263   ***      1     50                           5      die "No valid specs in $self->{head1}" unless @specs;
264                                                   
265            1                                 16      close $fh;
266            1                                  3      return @specs, @rules;
267                                                   }
268                                                   
269                                                   sub _parse_specs {
270            1                    1             7      my ( $self, @specs ) = @_;
271            1                                  4      my %disables; # special rule that requires deferred checking
272                                                   
273            1                                  5      foreach my $opt ( @specs ) {
274            9    100                          32         if ( ref $opt ) { # It's an option spec, not a rule.
275                                                            MKDEBUG && _d('Parsing opt spec:',
276            8                                 18               map { ($_, '=>', $opt->{$_}) } keys %$opt);
277                                                   
278            8                                 52            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
279   ***      8     50                          31            if ( !$long ) {
280   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
281                                                            }
282            8                                 27            $opt->{long} = $long;
283                                                   
284   ***      8     50                          35            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
285            8                                 31            $self->{opts}->{$long} = $opt;
286                                                   
287   ***      8     50                          35            if ( length $long == 1 ) {
288   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
289   ***      0                                  0               $self->{short_opts}->{$long} = $long;
290                                                            }
291                                                   
292   ***      8     50                          23            if ( $short ) {
293   ***      0      0                           0               die "Duplicate short option -$short"
294                                                                  if exists $self->{short_opts}->{$short};
295   ***      0                                  0               $self->{short_opts}->{$short} = $long;
296   ***      0                                  0               $opt->{short} = $short;
297                                                            }
298                                                            else {
299            8                                 29               $opt->{short} = undef;
300                                                            }
301                                                   
302   ***      8     50                          37            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
303   ***      8     50                          37            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
304   ***      8     50                          49            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
305                                                   
306   ***      8            50                   31            $opt->{group} ||= 'default';
307            8                                 38            $self->{groups}->{ $opt->{group} }->{$long} = 1;
308                                                   
309            8                                 36            $opt->{value} = undef;
310            8                                 24            $opt->{got}   = 0;
311                                                   
312            8                                 42            my ( $type ) = $opt->{spec} =~ m/=(.)/;
313            8                                 26            $opt->{type} = $type;
314            8                                 17            MKDEBUG && _d($long, 'type:', $type);
315                                                   
316                                                   
317            8    100    100                   72            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
318                                                   
319            8    100                          59            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
320   ***      5     50                          27               $self->{defaults}->{$long} = defined $def ? $def : 1;
321            5                                 10               MKDEBUG && _d($long, 'default:', $def);
322                                                            }
323                                                   
324            8    100                          33            if ( $long eq 'config' ) {
325            1                                  5               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
326                                                            }
327                                                   
328   ***      8     50                          39            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
329   ***      0                                  0               $disables{$long} = $dis;
330   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
331                                                            }
332                                                   
333            8                                 36            $self->{opts}->{$long} = $opt;
334                                                         }
335                                                         else { # It's an option rule, not a spec.
336            1                                  2            MKDEBUG && _d('Parsing rule:', $opt); 
337            1                                  3            push @{$self->{rules}}, $opt;
               1                                  4   
338            1                                  5            my @participants = $self->_get_participants($opt);
339            1                                  3            my $rule_ok = 0;
340                                                   
341   ***      1     50                          10            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
342   ***      0                                  0               $rule_ok = 1;
343   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
344   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
345                                                            }
346   ***      1     50                           7            if ( $opt =~ m/at least one|one and only one/ ) {
347   ***      0                                  0               $rule_ok = 1;
348   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
349   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
350                                                            }
351   ***      1     50                           5            if ( $opt =~ m/default to/ ) {
352   ***      0                                  0               $rule_ok = 1;
353   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
354   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
355                                                            }
356   ***      1     50                           5            if ( $opt =~ m/restricted to option groups/ ) {
357   ***      0                                  0               $rule_ok = 1;
358   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
359   ***      0                                  0               my @groups = split(',', $groups);
360   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
361   ***      0                                  0                  s/\s+//;
362   ***      0                                  0                  $_ => 1;
363                                                               } @groups;
364                                                            }
365   ***      1     50                           4            if( $opt =~ m/accepts additional command-line arguments/ ) {
366            1                                  3               $rule_ok = 1;
367            1                                  7               $self->{strict} = 0;
368            1                                  3               MKDEBUG && _d("Strict mode disabled by rule");
369                                                            }
370                                                   
371   ***      1     50                           6            die "Unrecognized option rule: $opt" unless $rule_ok;
372                                                         }
373                                                      }
374                                                   
375            1                                  5      foreach my $long ( keys %disables ) {
376   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
377   ***      0                                  0         $self->{disables}->{$long} = \@participants;
378   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
379                                                      }
380                                                   
381            1                                  5      return; 
382                                                   }
383                                                   
384                                                   sub _get_participants {
385            1                    1             4      my ( $self, $str ) = @_;
386            1                                  4      my @participants;
387            1                                  5      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
388   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
389                                                            unless exists $self->{opts}->{$long};
390   ***      0                                  0         push @participants, $long;
391                                                      }
392            1                                  3      MKDEBUG && _d('Participants for', $str, ':', @participants);
393            1                                  3      return @participants;
394                                                   }
395                                                   
396                                                   sub opts {
397   ***      0                    0             0      my ( $self ) = @_;
398   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
399   ***      0                                  0      return %opts;
400                                                   }
401                                                   
402                                                   sub short_opts {
403   ***      0                    0             0      my ( $self ) = @_;
404   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
405   ***      0                                  0      return %short_opts;
406                                                   }
407                                                   
408                                                   sub set_defaults {
409   ***      0                    0             0      my ( $self, %defaults ) = @_;
410   ***      0                                  0      $self->{defaults} = {};
411   ***      0                                  0      foreach my $long ( keys %defaults ) {
412   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
413                                                            unless exists $self->{opts}->{$long};
414   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
415   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
416                                                      }
417   ***      0                                  0      return;
418                                                   }
419                                                   
420                                                   sub get_defaults {
421   ***      0                    0             0      my ( $self ) = @_;
422   ***      0                                  0      return $self->{defaults};
423                                                   }
424                                                   
425                                                   sub get_groups {
426   ***      0                    0             0      my ( $self ) = @_;
427   ***      0                                  0      return $self->{groups};
428                                                   }
429                                                   
430                                                   sub _set_option {
431   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
432   ***      0      0                           0      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***             0                               
433                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
434                                                               : die "Getopt::Long gave a nonexistent option: $opt";
435                                                   
436   ***      0                                  0      $opt = $self->{opts}->{$long};
437   ***      0      0                           0      if ( $opt->{is_cumulative} ) {
438   ***      0                                  0         $opt->{value}++;
439                                                      }
440                                                      else {
441   ***      0                                  0         $opt->{value} = $val;
442                                                      }
443   ***      0                                  0      $opt->{got} = 1;
444   ***      0                                  0      MKDEBUG && _d('Got option', $long, '=', $val);
445                                                   }
446                                                   
447                                                   sub get_opts {
448            1                    1             4      my ( $self ) = @_; 
449                                                   
450            1                                  3      foreach my $long ( keys %{$self->{opts}} ) {
               1                                  7   
451            8                                 30         $self->{opts}->{$long}->{got} = 0;
452   ***      8     50                          59         $self->{opts}->{$long}->{value}
                    100                               
453                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
454                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
455                                                            : undef;
456                                                      }
457            1                                  4      $self->{got_opts} = 0;
458                                                   
459            1                                  4      $self->{errors} = [];
460                                                   
461   ***      1     50     33                   12      if ( @ARGV && $ARGV[0] eq "--config" ) {
462   ***      0                                  0         shift @ARGV;
463   ***      0                                  0         $self->_set_option('config', shift @ARGV);
464                                                      }
465   ***      1     50                           6      if ( $self->has('config') ) {
466            1                                  2         my @extra_args;
467            1                                  6         foreach my $filename ( split(',', $self->get('config')) ) {
468            4                                 18            eval {
469            4                                 20               push @extra_args, $self->_read_config_file($filename);
470                                                            };
471   ***      4     50                          18            if ( $EVAL_ERROR ) {
472   ***      4     50                          16               if ( $self->got('config') ) {
473   ***      0                                  0                  die $EVAL_ERROR;
474                                                               }
475                                                               elsif ( MKDEBUG ) {
476                                                                  _d($EVAL_ERROR);
477                                                               }
478                                                            }
479                                                         }
480            1                                  5         unshift @ARGV, @extra_args;
481                                                      }
482                                                   
483            1                                 14      Getopt::Long::Configure('no_ignore_case', 'bundling');
484                                                      GetOptions(
485   ***      7                    0            57         map    { $_->{spec} => sub { $self->_set_option(@_); } }
      ***      0                                  0   
               8                                 31   
486            1                                  5         grep   { $_->{long} ne 'config' } # --config is handled specially above.
487   ***      1     50                           4         values %{$self->{opts}}
488                                                      ) or $self->save_error('Error parsing options');
489                                                   
490   ***      1     50     33                   21      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
491   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
492                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
493                                                               or die "Cannot print: $OS_ERROR";
494   ***      0                                  0         exit 0;
495                                                      }
496                                                   
497   ***      1     50     33                   10      if ( @ARGV && $self->{strict} ) {
498   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
499                                                      }
500                                                   
501            1                                  3      foreach my $mutex ( @{$self->{mutex}} ) {
               1                                  9   
502   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
503   ***      0      0                           0         if ( @set > 1 ) {
504   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
505   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
506                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
507                                                                    . ' are mutually exclusive.';
508   ***      0                                  0            $self->save_error($err);
509                                                         }
510                                                      }
511                                                   
512            1                                  3      foreach my $required ( @{$self->{atleast1}} ) {
               1                                  5   
513   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
514   ***      0      0                           0         if ( @set == 0 ) {
515   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
516   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
517                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
518   ***      0                                  0            $self->save_error("Specify at least one of $err");
519                                                         }
520                                                      }
521                                                   
522            1                                  3      $self->_check_opts( keys %{$self->{opts}} );
               1                                  7   
523            1                                  4      $self->{got_opts} = 1;
524            1                                  2      return;
525                                                   }
526                                                   
527                                                   sub _check_opts {
528            1                    1             6      my ( $self, @long ) = @_;
529            1                                  5      my $long_last = scalar @long;
530            1                                  4      while ( @long ) {
531            1                                  7         foreach my $i ( 0..$#long ) {
532            8                                 26            my $long = $long[$i];
533   ***      8     50                          27            next unless $long;
534            8                                 29            my $opt  = $self->{opts}->{$long};
535   ***      8     50                          43            if ( $opt->{got} ) {
      ***            50                               
536   ***      0      0                           0               if ( exists $self->{disables}->{$long} ) {
537   ***      0                                  0                  my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
538   ***      0                                  0                  map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
539   ***      0                                  0                  MKDEBUG && _d('Unset options', @disable_opts,
540                                                                     'because', $long,'disables them');
541                                                               }
542                                                   
543   ***      0      0                           0               if ( exists $self->{allowed_groups}->{$long} ) {
544                                                   
545   ***      0                                  0                  my @restricted_groups = grep {
546   ***      0                                  0                     !exists $self->{allowed_groups}->{$long}->{$_}
547   ***      0                                  0                  } keys %{$self->{groups}};
548                                                   
549   ***      0                                  0                  my @restricted_opts;
550   ***      0                                  0                  foreach my $restricted_group ( @restricted_groups ) {
551   ***      0                                  0                     RESTRICTED_OPT:
552   ***      0                                  0                     foreach my $restricted_opt (
553                                                                        keys %{$self->{groups}->{$restricted_group}} )
554                                                                     {
555   ***      0      0                           0                        next RESTRICTED_OPT if $restricted_opt eq $long;
556   ***      0      0                           0                        push @restricted_opts, $restricted_opt
557                                                                           if $self->{opts}->{$restricted_opt}->{got};
558                                                                     }
559                                                                  }
560                                                   
561   ***      0      0                           0                  if ( @restricted_opts ) {
562   ***      0                                  0                     my $err;
563   ***      0      0                           0                     if ( @restricted_opts == 1 ) {
564   ***      0                                  0                        $err = "--$restricted_opts[0]";
565                                                                     }
566                                                                     else {
567   ***      0                                  0                        $err = join(', ',
568   ***      0                                  0                                  map { "--$self->{opts}->{$_}->{long}" }
569   ***      0                                  0                                  grep { $_ } 
570                                                                                  @restricted_opts[0..scalar(@restricted_opts) - 2]
571                                                                               )
572                                                                             . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
573                                                                     }
574   ***      0                                  0                     $self->save_error("--$long is not allowed with $err");
575                                                                  }
576                                                               }
577                                                   
578                                                            }
579                                                            elsif ( $opt->{is_required} ) { 
580   ***      0                                  0               $self->save_error("Required option --$long must be specified");
581                                                            }
582                                                   
583            8                                 27            $self->_validate_type($opt);
584   ***      8     50                          30            if ( $opt->{parsed} ) {
585            8                                 29               delete $long[$i];
586                                                            }
587                                                            else {
588   ***      0                                  0               MKDEBUG && _d('Temporarily failed to parse', $long);
589                                                            }
590                                                         }
591                                                   
592   ***      1     50                           5         die "Failed to parse options, possibly due to circular dependencies"
593                                                            if @long == $long_last;
594            1                                  5         $long_last = @long;
595                                                      }
596                                                   
597            1                                  5      return;
598                                                   }
599                                                   
600                                                   sub _validate_type {
601            8                    8            29      my ( $self, $opt ) = @_;
602   ***      8     50                          28      return unless $opt;
603                                                   
604            8    100                          33      if ( !$opt->{type} ) {
605            2                                 12         $opt->{parsed} = 1;
606            2                                  6         return;
607                                                      }
608                                                   
609            6                                 20      my $val = $opt->{value};
610                                                   
611   ***      6     50     33                  236      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***            50     33                        
      ***            50     33                        
      ***            50     33                        
      ***           100     33                        
      ***                   66                        
                           100                        
612   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
613   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
614   ***      0      0                           0         if ( !$suffix ) {
615   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
616   ***      0             0                    0            $suffix = $s || 's';
617   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
618                                                               $opt->{long}, '(value:', $val, ')');
619                                                         }
620   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
621   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
622                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
623                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
624                                                                 :                  $num * 86400;   # Days
625   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
626   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
627                                                         }
628                                                         else {
629   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
630                                                         }
631                                                      }
632                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
633   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
634   ***      0                                  0         my $prev = {};
635   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
636   ***      0      0                           0         if ( $from_key ) {
637   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
638   ***      0      0                           0            if ( $self->{opts}->{$from_key}->{parsed} ) {
639   ***      0                                  0               $prev = $self->{opts}->{$from_key}->{value};
640                                                            }
641                                                            else {
642   ***      0                                  0               MKDEBUG && _d('Cannot parse', $opt->{long}, 'until',
643                                                                  $from_key, 'parsed');
644   ***      0                                  0               return;
645                                                            }
646                                                         }
647   ***      0                                  0         my $defaults = $self->{DSNParser}->parse_options($self);
648   ***      0                                  0         $opt->{value} = $self->{DSNParser}->parse($val, $prev, $defaults);
649                                                      }
650                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
651   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
652   ***      0                                  0         $self->_parse_size($opt, $val);
653                                                      }
654                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
655   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(/(?<!\\),\s*/, ($val || '')) };
      ***      0                                  0   
656                                                      }
657                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
658   ***      2            50                   22         $opt->{value} = [ split(/(?<!\\),\s*/, ($val || '')) ];
659                                                      }
660                                                      else {
661            4                                 12         MKDEBUG && _d('Nothing to validate for option',
662                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
663                                                      }
664                                                   
665            6                                 20      $opt->{parsed} = 1;
666            6                                 16      return;
667                                                   }
668                                                   
669                                                   sub get {
670           12                   12            48      my ( $self, $opt ) = @_;
671   ***     12     50                          50      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
672   ***     12     50     33                  118      die "Option $opt does not exist"
673                                                         unless $long && exists $self->{opts}->{$long};
674           12                                116      return $self->{opts}->{$long}->{value};
675                                                   }
676                                                   
677                                                   sub got {
678            4                    4            17      my ( $self, $opt ) = @_;
679   ***      4     50                          17      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
680   ***      4     50     33                   69      die "Option $opt does not exist"
681                                                         unless $long && exists $self->{opts}->{$long};
682            4                                 32      return $self->{opts}->{$long}->{got};
683                                                   }
684                                                   
685                                                   sub has {
686            1                    1             5      my ( $self, $opt ) = @_;
687   ***      1     50                           5      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
688   ***      1     50                           8      return defined $long ? exists $self->{opts}->{$long} : 0;
689                                                   }
690                                                   
691                                                   sub set {
692   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
693   ***      0      0                           0      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
694   ***      0      0      0                    0      die "Option $opt does not exist"
695                                                         unless $long && exists $self->{opts}->{$long};
696   ***      0                                  0      $self->{opts}->{$long}->{value} = $val;
697   ***      0                                  0      return;
698                                                   }
699                                                   
700                                                   sub save_error {
701   ***      0                    0             0      my ( $self, $error ) = @_;
702   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
703   ***      0                                  0      return;
704                                                   }
705                                                   
706                                                   sub errors {
707   ***      0                    0             0      my ( $self ) = @_;
708   ***      0                                  0      return $self->{errors};
709                                                   }
710                                                   
711                                                   sub usage {
712   ***      0                    0             0      my ( $self ) = @_;
713   ***      0      0                           0      warn "No usage string is set" unless $self->{usage}; # XXX
714   ***      0             0                    0      return "Usage: " . ($self->{usage} || '') . "\n";
715                                                   }
716                                                   
717                                                   sub descr {
718   ***      0                    0             0      my ( $self ) = @_;
719   ***      0      0                           0      warn "No description string is set" unless $self->{description}; # XXX
720   ***      0             0                    0      my $descr  = ($self->{description} || $self->{program_name} || '')
      ***                    0                        
721                                                                 . "  For more details, please use the --help option, "
722                                                                 . "or try 'perldoc $PROGRAM_NAME' "
723                                                                 . "for complete documentation.";
724   ***      0      0                           0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g)
725                                                         unless $ENV{DONT_BREAK_LINES};
726   ***      0                                  0      $descr =~ s/ +$//mg;
727   ***      0                                  0      return $descr;
728                                                   }
729                                                   
730                                                   sub usage_or_errors {
731            1                    1             4      my ( $self, $file, $return ) = @_;
732   ***      1            50                   11      $file ||= $self->{file} || __FILE__;
      ***                   50                        
733                                                   
734   ***      1     50     33                   11      if ( !$self->{description} || !$self->{usage} ) {
735            1                                  2         MKDEBUG && _d("Getting description and usage from SYNOPSIS in", $file);
736            1                                  5         my %synop = $self->_parse_synopsis($file);
737   ***      1            50                   16         $self->{description} ||= $synop{description};
738   ***      1            50                    6         $self->{usage}       ||= $synop{usage};
739            1                                  4         MKDEBUG && _d("Description:", $self->{description},
740                                                            "\nUsage:", $self->{usage});
741                                                      }
742                                                   
743   ***      1     50                           5      if ( $self->{opts}->{help}->{got} ) {
      ***      1     50                           6   
744   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
745   ***      0      0                           0         exit 0 unless $return;
746                                                      }
747                                                      elsif ( scalar @{$self->{errors}} ) {
748   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
749   ***      0      0                           0         exit 0 unless $return;
750                                                      }
751                                                   
752            1                                  3      return;
753                                                   }
754                                                   
755                                                   sub print_errors {
756   ***      0                    0             0      my ( $self ) = @_;
757   ***      0                                  0      my $usage = $self->usage() . "\n";
758   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
759   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
760                                                                 . "\n";
761                                                      }
762   ***      0                                  0      return $usage . "\n" . $self->descr();
763                                                   }
764                                                   
765                                                   sub print_usage {
766   ***      0                    0             0      my ( $self ) = @_;
767   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
768   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
769                                                   
770   ***      0      0                           0      my $maxl = max(
      ***             0                               
771                                                         map {
772   ***      0                                  0            length($_->{long})               # option long name
773                                                            + ($_->{is_negatable} ? 4 : 0)   # "[no]" if opt is negatable
774                                                            + ($_->{type} ? 2 : 0)           # "=x" where x is the opt type
775                                                         }
776                                                         @opts);
777                                                   
778   ***      0      0                           0      my $maxs = max(0,
      ***             0                               
779                                                         map {
780   ***      0                                  0            length($_)
781                                                            + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0)
782                                                            + ($self->{opts}->{$_}->{type} ? 2 : 0)
783                                                         }
784   ***      0                                  0         values %{$self->{short_opts}});
785                                                   
786   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
787   ***      0                                  0      my $rcol = 80 - $lcol - 6;
788   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
789                                                   
790   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
791                                                   
792   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->usage();
793                                                   
794   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
795   ***      0                                  0      push @groups, 'default';
796                                                   
797   ***      0                                  0      foreach my $group ( reverse @groups ) {
798   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
799   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
800   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
801                                                            grep { $_->{group} eq $group }
802                                                            @opts )
803                                                         {
804   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
805   ***      0                                  0            my $short = $opt->{short};
806   ***      0                                  0            my $desc  = $opt->{desc};
807                                                   
808   ***      0      0                           0            $long .= $opt->{type} ? "=$opt->{type}" : "";
809                                                   
810   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
811   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
812   ***      0             0                    0               $s    ||= 's';
813   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
814   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
815                                                                      . "d=days; if no suffix, $s is used.";
816                                                            }
817   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
818   ***      0                                  0            $desc =~ s/ +$//mg;
819   ***      0      0                           0            if ( $short ) {
820   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
821                                                            }
822                                                            else {
823   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
824                                                            }
825                                                         }
826                                                      }
827                                                   
828   ***      0                                  0      $usage .= "\nOption types: s=string, i=integer, f=float, h/H/a/A=comma-separated list, d=DSN, z=size, m=time\n";
829                                                   
830   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
831   ***      0                                  0         $usage .= "\nRules:\n\n";
832   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
833                                                      }
834   ***      0      0                           0      if ( $self->{DSNParser} ) {
835   ***      0                                  0         $usage .= "\n" . $self->{DSNParser}->usage();
836                                                      }
837   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
838   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
839   ***      0                                  0         my $val   = $opt->{value};
840   ***      0             0                    0         my $type  = $opt->{type} || '';
841   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
842   ***      0      0                           0         $val      = $bool              ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
843                                                                   : !defined $val      ? '(No value)'
844                                                                   : $type eq 'd'       ? $self->{DSNParser}->as_string($val)
845                                                                   : $type =~ m/H|h/    ? join(',', sort keys %$val)
846                                                                   : $type =~ m/A|a/    ? join(',', @$val)
847                                                                   :                    $val;
848   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
849                                                      }
850   ***      0                                  0      return $usage;
851                                                   }
852                                                   
853                                                   sub prompt_noecho {
854   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
855   ***      0                                  0      my ( $prompt ) = @_;
856   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
857   ***      0      0                           0      print $prompt
858                                                         or die "Cannot print: $OS_ERROR";
859   ***      0                                  0      my $response;
860   ***      0                                  0      eval {
861   ***      0                                  0         require Term::ReadKey;
862   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
863   ***      0                                  0         chomp($response = <STDIN>);
864   ***      0                                  0         Term::ReadKey::ReadMode('normal');
865   ***      0      0                           0         print "\n"
866                                                            or die "Cannot print: $OS_ERROR";
867                                                      };
868   ***      0      0                           0      if ( $EVAL_ERROR ) {
869   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
870                                                      }
871   ***      0                                  0      return $response;
872                                                   }
873                                                   
874                                                   if ( MKDEBUG ) {
875                                                      print '# ', $^X, ' ', $], "\n";
876                                                      my $uname = `uname -a`;
877                                                      if ( $uname ) {
878                                                         $uname =~ s/\s+/ /g;
879                                                         print "# $uname\n";
880                                                      }
881                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
882                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
883                                                         ($main::SVN_REV || ''), __LINE__);
884                                                      print('# Arguments: ',
885                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
886                                                   }
887                                                   
888                                                   sub _read_config_file {
889            4                    4            20      my ( $self, $filename ) = @_;
890   ***      4     50                           9      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
891   ***      0                                  0      my @args;
892   ***      0                                  0      my $prefix = '--';
893   ***      0                                  0      my $parse  = 1;
894                                                   
895                                                      LINE:
896   ***      0                                  0      while ( my $line = <$fh> ) {
897   ***      0                                  0         chomp $line;
898   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
899   ***      0                                  0         $line =~ s/\s+#.*$//g;
900   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
901   ***      0      0                           0         if ( $line eq '--' ) {
902   ***      0                                  0            $prefix = '';
903   ***      0                                  0            $parse  = 0;
904   ***      0                                  0            next LINE;
905                                                         }
906   ***      0      0      0                    0         if ( $parse
      ***             0                               
907                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
908                                                         ) {
909   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
910                                                         }
911                                                         elsif ( $line =~ m/./ ) {
912   ***      0                                  0            push @args, $line;
913                                                         }
914                                                         else {
915   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
916                                                         }
917                                                      }
918   ***      0                                  0      close $fh;
919   ***      0                                  0      return @args;
920                                                   }
921                                                   
922                                                   sub read_para_after {
923   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
924   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
925   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
926   ***      0                                  0      my $para;
927   ***      0                                  0      while ( $para = <$fh> ) {
928   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
929   ***      0                                  0         last;
930                                                      }
931   ***      0                                  0      while ( $para = <$fh> ) {
932   ***      0      0                           0         next unless $para =~ m/$regex/;
933   ***      0                                  0         last;
934                                                      }
935   ***      0                                  0      $para = <$fh>;
936   ***      0                                  0      chomp($para);
937   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
938   ***      0                                  0      return $para;
939                                                   }
940                                                   
941                                                   sub clone {
942   ***      0                    0             0      my ( $self ) = @_;
943                                                   
944   ***      0                                  0      my %clone = map {
945   ***      0                                  0         my $hashref  = $self->{$_};
946   ***      0                                  0         my $val_copy = {};
947   ***      0                                  0         foreach my $key ( keys %$hashref ) {
948   ***      0                                  0            my $ref = ref $hashref->{$key};
949   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
950   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
951   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
952                                                                              : $hashref->{$key};
953                                                         }
954   ***      0                                  0         $_ => $val_copy;
955                                                      } qw(opts short_opts defaults);
956                                                   
957   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
958   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
959                                                      }
960                                                   
961   ***      0                                  0      return bless \%clone;     
962                                                   }
963                                                   
964                                                   sub _parse_size {
965   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
966                                                   
967   ***      0      0      0                    0      if ( lc($val || '') eq 'null' ) {
968   ***      0                                  0         MKDEBUG && _d('NULL size for', $opt->{long});
969   ***      0                                  0         $opt->{value} = 'null';
970   ***      0                                  0         return;
971                                                      }
972                                                   
973   ***      0                                  0      my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
974   ***      0                                  0      my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
975   ***      0      0                           0      if ( defined $num ) {
976   ***      0      0                           0         if ( $factor ) {
977   ***      0                                  0            $num *= $factor_for{$factor};
978   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{y},
979                                                               'to num', $num, '* factor', $factor);
980                                                         }
981   ***      0             0                    0         $opt->{value} = ($pre || '') . $num;
982                                                      }
983                                                      else {
984   ***      0                                  0         $self->save_error("Invalid size for --$opt->{long}");
985                                                      }
986   ***      0                                  0      return;
987                                                   }
988                                                   
989                                                   sub _parse_attribs {
990            8                    8            34      my ( $self, $option, $attribs ) = @_;
991            8                                 26      my $types = $self->{types};
992   ***      8     50                         151      return $option
      ***            50                               
      ***            50                               
                    100                               
993                                                         . ($attribs->{'short form'} ? '|' . $attribs->{'short form'}   : '' )
994                                                         . ($attribs->{'negatable'}  ? '!'                              : '' )
995                                                         . ($attribs->{'cumulative'} ? '+'                              : '' )
996                                                         . ($attribs->{'type'}       ? '=' . $types->{$attribs->{type}} : '' );
997                                                   }
998                                                   
999                                                   sub _parse_synopsis {
1000           1                    1             4      my ( $self, $file ) = @_;
1001  ***      1             0                    5      $file ||= $self->{file} || __FILE__;
      ***                   50                        
1002           1                                  5      MKDEBUG && _d("Parsing SYNOPSIS in", $file);
1003                                                  
1004           1                                  7      local $INPUT_RECORD_SEPARATOR = '';  # read paragraphs
1005  ***      1     50                          31      open my $fh, "<", $file or die "Cannot open $file: $OS_ERROR";
1006           1                                  2      my $para;
1007  ***      1            66                 1654      1 while defined($para = <$fh>) && $para !~ m/^=head1 SYNOPSIS/;
1008  ***      1     50                           4      die "$file does not contain a SYNOPSIS section" unless $para;
1009           1                                  3      my @synop;
1010           1                                  5      for ( 1..2 ) {  # 1 for the usage, 2 for the description
1011           2                                 10         my $para = <$fh>;
1012           2                                  9         push @synop, $para;
1013                                                     }
1014           1                                  8      close $fh;
1015           1                                  3      MKDEBUG && _d("Raw SYNOPSIS text:", @synop);
1016           1                                  5      my ($usage, $desc) = @synop;
1017  ***      1     50     33                    9      die "The SYNOPSIS section in $file is not formatted properly"
1018                                                        unless $usage && $desc;
1019                                                  
1020           1                                 12      $usage =~ s/^\s*Usage:\s+(.+)/$1/;
1021           1                                  3      chomp $usage;
1022                                                  
1023           1                                  7      $desc =~ s/\n/ /g;
1024           1                                  8      $desc =~ s/\s{2,}/ /g;
1025           1                                  9      $desc =~ s/\. ([A-Z][a-z])/.  $1/g;
1026           1                                  8      $desc =~ s/\s+$//;
1027                                                  
1028                                                     return (
1029           1                                  3         description => $desc,
1030                                                        usage       => $usage,
1031                                                     );
1032                                                  };
1033                                                  
1034                                                  sub _d {
1035  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1036  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1037  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1038                                                          @_;
1039  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1040                                                  }
1041                                                  
1042                                                  1;
1043                                                  
1044                                                  # ###########################################################################
1045                                                  # End OptionParser package
1046                                                  # ###########################################################################
1047                                                  
1048                                                  # ###########################################################################
1049                                                  # Transformers package 7226
1050                                                  # ###########################################################################
1051                                                  
1052                                                  # Transformers - Common transformation and beautification subroutines
1053                                                  package Transformers;
1054                                                  
1055           1                    1            11   use strict;
               1                                  2   
               1                                  8   
1056           1                    1             6   use warnings FATAL => 'all';
               1                                260   
               1                                  8   
1057           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  7   
1058           1                    1            14   use Time::Local qw(timegm timelocal);
               1                                  3   
               1                                 10   
1059           1                    1             7   use Digest::MD5 qw(md5_hex);
               1                                  2   
               1                                  7   
1060                                                  
1061  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 12   
1062                                                  
1063                                                  require Exporter;
1064                                                  our @ISA         = qw(Exporter);
1065                                                  our %EXPORT_TAGS = ();
1066                                                  our @EXPORT      = ();
1067                                                  our @EXPORT_OK   = qw(
1068                                                     micro_t
1069                                                     percentage_of
1070                                                     secs_to_time
1071                                                     time_to_secs
1072                                                     shorten
1073                                                     ts
1074                                                     parse_timestamp
1075                                                     unix_timestamp
1076                                                     any_unix_timestamp
1077                                                     make_checksum
1078                                                     crc32
1079                                                  );
1080                                                  
1081                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
1082                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
1083                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
1084                                                                                           # like a MySQL YYMMDD without hh:mm:ss.
1085                                                  
1086                                                  sub micro_t {
1087  ***      0                    0             0      my ( $t, %args ) = @_;
1088  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
1089  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
1090  ***      0                                  0      my $f;
1091                                                  
1092  ***      0      0                           0      $t = 0 if $t < 0;
1093                                                  
1094                                                     # "Remove" scientific notation so the regex below does not make
1095                                                     # 6.123456e+18 into 6.123456.
1096  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
1097                                                  
1098                                                     # Truncate after 6 decimal places to avoid 0.9999997 becoming 1
1099                                                     # because sprintf() rounds.
1100  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
1101                                                  
1102  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
1103  ***      0                                  0         $f = ($t * 1000000) . 'us';
1104                                                     }
1105                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
1106  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
1107  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
1108                                                     }
1109                                                     elsif ($t >= 1) {
1110  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
1111  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
1112                                                     }
1113                                                     else {
1114  ***      0                                  0         $f = 0;  # $t should = 0 at this point
1115                                                     }
1116                                                  
1117  ***      0                                  0      return $f;
1118                                                  }
1119                                                  
1120                                                  # Returns what percentage $is of $of.
1121                                                  sub percentage_of {
1122  ***      0                    0             0      my ( $is, $of, %args ) = @_;
1123  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
1124  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
1125  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
1126                                                  }
1127                                                  
1128                                                  sub secs_to_time {
1129  ***      0                    0             0      my ( $secs, $fmt ) = @_;
1130  ***      0             0                    0      $secs ||= 0;
1131  ***      0      0                           0      return '00:00' unless $secs;
1132                                                  
1133                                                     # Decide what format to use, if not given
1134  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
1135                                                            : $secs >= 3_600  ? 'h'
1136                                                            :                   'm';
1137                                                  
1138                                                     return
1139  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
1140                                                           "%d+%02d:%02d:%02d",
1141                                                           int($secs / 86_400),
1142                                                           int(($secs % 86_400) / 3_600),
1143                                                           int(($secs % 3_600) / 60),
1144                                                           $secs % 60)
1145                                                        : $fmt eq 'h' ? sprintf(
1146                                                           "%02d:%02d:%02d",
1147                                                           int(($secs % 86_400) / 3_600),
1148                                                           int(($secs % 3_600) / 60),
1149                                                           $secs % 60)
1150                                                        : sprintf(
1151                                                           "%02d:%02d",
1152                                                           int(($secs % 3_600) / 60),
1153                                                           $secs % 60);
1154                                                  }
1155                                                  
1156                                                  # Convert time values to number of seconds:
1157                                                  # 1s = 1, 1m = 60, 1h = 3600, 1d = 86400.
1158                                                  sub time_to_secs {
1159  ***      0                    0             0      my ( $val, $default_suffix ) = @_;
1160  ***      0      0                           0      die "I need a val argument" unless defined $val;
1161  ***      0                                  0      my $t = 0;
1162  ***      0                                  0      my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
1163  ***      0             0                    0      $suffix = $suffix || $default_suffix || 's';
      ***                    0                        
1164  ***      0      0                           0      if ( $suffix =~ m/[smhd]/ ) {
1165  ***      0      0                           0         $t = $suffix eq 's' ? $num * 1        # Seconds
      ***             0                               
      ***             0                               
1166                                                           : $suffix eq 'm' ? $num * 60       # Minutes
1167                                                           : $suffix eq 'h' ? $num * 3600     # Hours
1168                                                           :                  $num * 86400;   # Days
1169                                                  
1170  ***      0      0      0                    0         $t *= -1 if $prefix && $prefix eq '-';
1171                                                     }
1172                                                     else {
1173  ***      0                                  0         die "Invalid suffix for $val: $suffix";
1174                                                     }
1175  ***      0                                  0      return $t;
1176                                                  }
1177                                                  
1178                                                  sub shorten {
1179  ***      0                    0             0      my ( $num, %args ) = @_;
1180  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
1181  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
1182  ***      0                                  0      my $n = 0;
1183  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
1184  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
1185  ***      0                                  0         $num /= $d;
1186  ***      0                                  0         ++$n;
1187                                                     }
1188  ***      0      0      0                    0      return sprintf(
1189                                                        $num =~ m/\./ || $n
1190                                                           ? "%.${p}f%s"
1191                                                           : '%d',
1192                                                        $num, $units[$n]);
1193                                                  }
1194                                                  
1195                                                  # Turns a unix timestamp into an ISO8601 formatted date and time.  $gmt makes
1196                                                  # this relative to GMT, for test determinism.
1197                                                  sub ts {
1198  ***      0                    0             0      my ( $time, $gmt ) = @_;
1199  ***      0      0                           0      my ( $sec, $min, $hour, $mday, $mon, $year )
1200                                                        = $gmt ? gmtime($time) : localtime($time);
1201  ***      0                                  0      $mon  += 1;
1202  ***      0                                  0      $year += 1900;
1203  ***      0                                  0      my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
1204                                                        $year, $mon, $mday, $hour, $min, $sec);
1205  ***      0      0                           0      if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
1206  ***      0                                  0         $us = sprintf("%.6f", $us);
1207  ***      0                                  0         $us =~ s/^0\././;
1208  ***      0                                  0         $val .= $us;
1209                                                     }
1210  ***      0                                  0      return $val;
1211                                                  }
1212                                                  
1213                                                  # Turns MySQL's 071015 21:43:52 into a properly formatted timestamp.  Also
1214                                                  # handles a timestamp with fractions after it.
1215                                                  sub parse_timestamp {
1216  ***      0                    0             0      my ( $val ) = @_;
1217  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $f)
1218                                                           = $val =~ m/^$mysql_ts$/ )
1219                                                     {
1220  ***      0      0                           0         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
1221                                                                       . (defined $f ? '%09.6f' : '%02d'),
1222                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
1223                                                     }
1224  ***      0                                  0      return $val;
1225                                                  }
1226                                                  
1227                                                  # Turns a properly formatted timestamp like 2007-10-15 01:43:52
1228                                                  # into an int (seconds since epoch).  Optional microseconds are printed.  $gmt
1229                                                  # makes it use GMT time instead of local time (to make tests deterministic).
1230                                                  sub unix_timestamp {
1231  ***      0                    0             0      my ( $val, $gmt ) = @_;
1232  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
1233  ***      0      0                           0         $val = $gmt
1234                                                           ? timegm($s, $i, $h, $d, $m - 1, $y)
1235                                                           : timelocal($s, $i, $h, $d, $m - 1, $y);
1236  ***      0      0                           0         if ( defined $us ) {
1237  ***      0                                  0            $us = sprintf('%.6f', $us);
1238  ***      0                                  0            $us =~ s/^0\././;
1239  ***      0                                  0            $val .= $us;
1240                                                        }
1241                                                     }
1242  ***      0                                  0      return $val;
1243                                                  }
1244                                                  
1245                                                  # Turns several different types of timestamps into a unix timestamp.
1246                                                  # Each type is auto-detected.  Supported types are:
1247                                                  #   * N[shdm]                Now - N[shdm]
1248                                                  #   * 071015 21:43:52        MySQL slow log timestamp
1249                                                  #   * 2009-07-01 [3:43:01]   Proper timestamp with options HH:MM:SS
1250                                                  #   * NOW()                  A MySQL time express
1251                                                  # For the last type, the callback arg is required.  It is passed the
1252                                                  # given value/expression and is expected to return a single value
1253                                                  # (the result of the expression).
1254                                                  sub any_unix_timestamp {
1255  ***      0                    0             0      my ( $val, $callback ) = @_;
1256                                                  
1257  ***      0      0                           0      if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      ***             0                               
      ***             0                               
      ***             0                               
1258  ***      0      0                           0         $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
1259                                                           : $suffix eq 'm' ? $n * 60       # Minutes
1260                                                           : $suffix eq 'h' ? $n * 3600     # Hours
1261                                                           : $suffix eq 'd' ? $n * 86400    # Days
1262                                                           :                  $n;           # default: Seconds
1263  ***      0                                  0         MKDEBUG && _d('ts is now - N[shmd]:', $n);
1264  ***      0                                  0         return time - $n;
1265                                                     }
1266                                                     elsif ( $val =~ m/^\d{9,}/ ) {
1267                                                        # unix timestamp 100000000 is roughly March, 1973, so older
1268                                                        # dates won't be caught here; they'll probably be mistaken
1269                                                        # for a MySQL slow log timestamp.
1270  ***      0                                  0         MKDEBUG && _d('ts is already a unix timestamp');
1271  ***      0                                  0         return $val;
1272                                                     }
1273                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
1274  ***      0                                  0         MKDEBUG && _d('ts is MySQL slow log timestamp');
1275  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
1276  ***      0                                  0         return unix_timestamp(parse_timestamp($val));
1277                                                     }
1278                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
1279  ***      0                                  0         MKDEBUG && _d('ts is properly formatted timestamp');
1280  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
1281  ***      0                                  0         return unix_timestamp($val);
1282                                                     }
1283                                                     else {
1284  ***      0                                  0         MKDEBUG && _d('ts is MySQL expression');
1285  ***      0      0      0                    0         return $callback->($val) if $callback && ref $callback eq 'CODE';
1286                                                     }
1287                                                  
1288  ***      0                                  0      MKDEBUG && _d('Unknown ts type:', $val);
1289  ***      0                                  0      return;
1290                                                  }
1291                                                  
1292                                                  # Returns the rightmost 64 bits of an MD5 checksum of the value.
1293                                                  sub make_checksum {
1294  ***      0                    0             0      my ( $val ) = @_;
1295  ***      0                                  0      my $checksum = uc substr(md5_hex($val), -16);
1296  ***      0                                  0      MKDEBUG && _d($checksum, 'checksum for', $val);
1297  ***      0                                  0      return $checksum;
1298                                                  }
1299                                                  
1300                                                  # Perl implementation of CRC32, ripped off from Digest::Crc32.  The results
1301                                                  # ought to match what you get from any standard CRC32 implementation, such as
1302                                                  # that inside MySQL.
1303                                                  sub crc32 {
1304  ***      0                    0             0      my ( $string ) = @_;
1305  ***      0      0                           0      return unless $string;
1306  ***      0                                  0      my $poly = 0xEDB88320;
1307  ***      0                                  0      my $crc  = 0xFFFFFFFF;
1308  ***      0                                  0      foreach my $char ( split(//, $string) ) {
1309  ***      0                                  0         my $comp = ($crc ^ ord($char)) & 0xFF;
1310  ***      0                                  0         for ( 1 .. 8 ) {
1311  ***      0      0                           0            $comp = $comp & 1 ? $poly ^ ($comp >> 1) : $comp >> 1;
1312                                                        }
1313  ***      0                                  0         $crc = (($crc >> 8) & 0x00FFFFFF) ^ $comp;
1314                                                     }
1315  ***      0                                  0      return $crc ^ 0xFFFFFFFF;
1316                                                  }
1317                                                  
1318                                                  sub _d {
1319  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1320  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1321  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1322                                                          @_;
1323  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1324                                                  }
1325                                                  
1326                                                  1;
1327                                                  
1328                                                  # ###########################################################################
1329                                                  # End Transformers package
1330                                                  # ###########################################################################
1331                                                  
1332                                                  # ###########################################################################
1333                                                  # Progress package 7096
1334                                                  # This package is a copy without comments from the original.  The original
1335                                                  # with comments and its test file can be found in the SVN repository at,
1336                                                  #   trunk/common/Progress.pm
1337                                                  #   trunk/common/t/Progress.t
1338                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1339                                                  # ###########################################################################
1340                                                  package Progress;
1341                                                  
1342           1                    1             7   use strict;
               1                                  3   
               1                                  6   
1343           1                    1             6   use warnings FATAL => 'all';
               1                                  2   
               1                                  6   
1344                                                  
1345           1                    1             5   use English qw(-no_match_vars);
               1                                  3   
               1                                  5   
1346           1                    1             6   use Data::Dumper;
               1                                  3   
               1                                  8   
1347                                                  $Data::Dumper::Indent    = 1;
1348                                                  $Data::Dumper::Sortkeys  = 1;
1349                                                  $Data::Dumper::Quotekeys = 0;
1350                                                  
1351  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 23   
1352                                                  
1353                                                  sub new {
1354           1                    1             8      my ( $class, %args ) = @_;
1355           1                                  5      foreach my $arg (qw(jobsize)) {
1356  ***      1     50                           5         die "I need a $arg argument" unless defined $args{$arg};
1357                                                     }
1358  ***      1     50     33                    7      if ( (!$args{report} || !$args{interval}) ) {
1359  ***      1     50     33                    9         if ( $args{spec} && @{$args{spec}} == 2 ) {
               1                                  8   
1360           1                                  4            @args{qw(report interval)} = @{$args{spec}};
               1                                  7   
1361                                                        }
1362                                                        else {
1363  ***      0                                  0            die "I need either report and interval arguments, or a spec";
1364                                                        }
1365                                                     }
1366                                                  
1367  ***      1            50                    6      my $name  = $args{name} || "Progress";
1368  ***      1            50                    7      $args{start} ||= time();
1369           1                                  2      my $self;
1370                                                     $self = {
1371                                                        last_reported => $args{start},
1372                                                        fraction      => 0,       # How complete the job is
1373                                                        callback      => sub {
1374  ***      0                    0             0            my ($fraction, $elapsed, $remaining, $eta) = @_;
1375  ***      0                                  0            printf STDERR "$name: %3d%% %s remain\n",
1376                                                              $fraction * 100,
1377                                                              Transformers::secs_to_time($remaining),
1378                                                              Transformers::ts($eta);
1379                                                        },
1380           1                                 14         %args,
1381                                                     };
1382           1                                 13      return bless $self, $class;
1383                                                  }
1384                                                  
1385                                                  sub validate_spec {
1386  ***      1     50             1             5      shift @_ if $_[0] eq 'Progress'; # Permit calling as Progress-> or Progress::
1387           1                                  4      my ( $spec ) = @_;
1388  ***      1     50                           5      if ( @$spec != 2 ) {
1389  ***      0                                  0         die "spec array requires a two-part argument\n";
1390                                                     }
1391  ***      1     50                          12      if ( $spec->[0] !~ m/^(?:percentage|time|iterations)$/ ) {
1392  ***      0                                  0         die "spec array's first element must be one of "
1393                                                          . "percentage,time,iterations\n";
1394                                                     }
1395  ***      1     50                           8      if ( $spec->[1] !~ m/^\d+$/ ) {
1396  ***      0                                  0         die "spec array's second element must be an integer\n";
1397                                                     }
1398                                                  }
1399                                                  
1400                                                  sub set_callback {
1401  ***      0                    0             0      my ( $self, $callback ) = @_;
1402  ***      0                                  0      $self->{callback} = $callback;
1403                                                  }
1404                                                  
1405                                                  sub start {
1406  ***      0                    0             0      my ( $self, $start ) = @_;
1407  ***      0             0                    0      $self->{start} = $self->{last_reported} = $start || time();
1408                                                  }
1409                                                  
1410                                                  sub update {
1411           3                    3            12      my ( $self, $callback, $now ) = @_;
1412           3                                 10      my $jobsize   = $self->{jobsize};
1413  ***      3            50                   15      $now        ||= time();
1414           3                                 11      $self->{iterations}++; # How many updates have happened;
1415                                                  
1416  ***      3     50     33                   32      if ( $self->{report} eq 'time'
      ***             0      0                        
1417                                                           && $self->{interval} > $now - $self->{last_reported}
1418                                                     ) {
1419           3                                 12         return;
1420                                                     }
1421                                                     elsif ( $self->{report} eq 'iterations'
1422                                                           && ($self->{iterations} - 1) % $self->{interval} > 0
1423                                                     ) {
1424  ***      0                                  0         return;
1425                                                     }
1426  ***      0                                  0      $self->{last_reported} = $now;
1427                                                  
1428  ***      0                                  0      my $completed = $callback->();
1429  ***      0                                  0      $self->{updates}++; # How many times we have run the update callback
1430                                                  
1431  ***      0      0                           0      return if $completed > $jobsize;
1432                                                  
1433  ***      0      0                           0      my $fraction = $completed > 0 ? $completed / $jobsize : 0;
1434                                                  
1435  ***      0      0      0                    0      if ( $self->{report} eq 'percentage'
1436                                                           && $self->fraction_modulo($self->{fraction})
1437                                                              >= $self->fraction_modulo($fraction)
1438                                                     ) {
1439  ***      0                                  0         $self->{fraction} = $fraction;
1440  ***      0                                  0         return;
1441                                                     }
1442  ***      0                                  0      $self->{fraction} = $fraction;
1443                                                  
1444  ***      0                                  0      my $elapsed   = $now - $self->{start};
1445  ***      0                                  0      my $remaining = 0;
1446  ***      0                                  0      my $eta       = $now;
1447  ***      0      0      0                    0      if ( $completed > 0 && $completed <= $jobsize && $elapsed > 0 ) {
      ***                    0                        
1448  ***      0                                  0         my $rate = $completed / $elapsed;
1449  ***      0      0                           0         if ( $rate > 0 ) {
1450  ***      0                                  0            $remaining = ($jobsize - $completed) / $rate;
1451  ***      0                                  0            $eta       = $now + int($remaining);
1452                                                        }
1453                                                     }
1454  ***      0                                  0      $self->{callback}->($fraction, $elapsed, $remaining, $eta, $completed);
1455                                                  }
1456                                                  
1457                                                  sub fraction_modulo {
1458  ***      0                    0             0      my ( $self, $num ) = @_;
1459  ***      0                                  0      $num *= 100; # Convert from fraction to percentage
1460  ***      0                                  0      return sprintf('%d',
1461                                                        sprintf('%d', $num / $self->{interval}) * $self->{interval});
1462                                                  }
1463                                                  
1464                                                  sub _d {
1465  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1466  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1467  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1468                                                          @_;
1469  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1470                                                  }
1471                                                  
1472                                                  1;
1473                                                  
1474                                                  # ###########################################################################
1475                                                  # End Progress package
1476                                                  # ###########################################################################
1477                                                  
1478                                                  # ###########################################################################
1479                                                  # FileIterator package 7096
1480                                                  # This package is a copy without comments from the original.  The original
1481                                                  # with comments and its test file can be found in the SVN repository at,
1482                                                  #   trunk/common/FileIterator.pm
1483                                                  #   trunk/common/t/FileIterator.t
1484                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1485                                                  # ###########################################################################
1486                                                  package FileIterator;
1487                                                  
1488           1                    1             6   use strict;
               1                                  3   
               1                                  5   
1489           1                    1             5   use warnings FATAL => 'all';
               1                                  3   
               1                                  4   
1490                                                  
1491           1                    1             6   use English qw(-no_match_vars);
               1                                  2   
               1                                  5   
1492           1                    1             6   use Data::Dumper;
               1                                  2   
               1                                  5   
1493                                                  $Data::Dumper::Indent    = 1;
1494                                                  $Data::Dumper::Sortkeys  = 1;
1495                                                  $Data::Dumper::Quotekeys = 0;
1496                                                  
1497  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 16   
1498                                                  
1499                                                  sub new {
1500           1                    1             5      my ( $class, %args ) = @_;
1501           1                                  5      my $self = {
1502                                                        %args,
1503                                                     };
1504           1                                 14      return bless $self, $class;
1505                                                  }
1506                                                  
1507                                                  sub get_file_itr {
1508           1                    1             4      my ( $self, @filenames ) = @_;
1509                                                  
1510           1                                  3      my @final_filenames;
1511                                                     FILENAME:
1512           1                                  4      foreach my $fn ( @filenames ) {
1513  ***      1     50                           5         if ( !defined $fn ) {
1514  ***      0                                  0            warn "Skipping undefined filename";
1515  ***      0                                  0            next FILENAME;
1516                                                        }
1517  ***      1     50                           4         if ( $fn ne '-' ) {
1518  ***      1     50     33                   27            if ( !-e $fn || !-r $fn ) {
1519  ***      0                                  0               warn "$fn does not exist or is not readable";
1520  ***      0                                  0               next FILENAME;
1521                                                           }
1522                                                        }
1523           1                                  4         push @final_filenames, $fn;
1524                                                     }
1525                                                  
1526  ***      1     50                           5      if ( !@filenames ) {
1527  ***      0                                  0         push @final_filenames, '-';
1528  ***      0                                  0         MKDEBUG && _d('Auto-adding "-" to the list of filenames');
1529                                                     }
1530                                                  
1531           1                                  2      MKDEBUG && _d('Final filenames:', @final_filenames);
1532                                                     return sub {
1533           2                    2            10         while ( @final_filenames ) {
1534           1                                  4            my $fn = shift @final_filenames;
1535           1                                  2            MKDEBUG && _d('Filename:', $fn);
1536  ***      1     50                           4            if ( $fn eq '-' ) { # Magical STDIN filename.
1537  ***      0                                  0               return (*STDIN, undef, undef);
1538                                                           }
1539  ***      1     50                          22            open my $fh, '<', $fn or warn "Cannot open $fn: $OS_ERROR";
1540  ***      1     50                           5            if ( $fh ) {
1541           1                                 11               return ( $fh, $fn, -s $fn );
1542                                                           }
1543                                                        }
1544           1                                  2         return (); # Avoids $f being set to 0 in list context.
1545           1                                 13      };
1546                                                  }
1547                                                  
1548                                                  sub _d {
1549  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1550  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1551  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1552                                                          @_;
1553  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1554                                                  }
1555                                                  
1556                                                  1;
1557                                                  
1558                                                  # ###########################################################################
1559                                                  # End FileIterator package
1560                                                  # ###########################################################################
1561                                                  
1562                                                  # ###########################################################################
1563                                                  # SimpleTCPDumpParser package 7441
1564                                                  # This package is a copy without comments from the original.  The original
1565                                                  # with comments and its test file can be found in the SVN repository at,
1566                                                  #   trunk/common/SimpleTCPDumpParser.pm
1567                                                  #   trunk/common/t/SimpleTCPDumpParser.t
1568                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1569                                                  # ###########################################################################
1570                                                  package SimpleTCPDumpParser;
1571                                                  
1572           1                    1            21   use strict;
               1                                  2   
               1                                  5   
1573           1                    1             6   use warnings FATAL => 'all';
               1                                  3   
               1                                  5   
1574           1                    1             5   use English qw(-no_match_vars);
               1                                  3   
               1                                  8   
1575           1                    1             7   use Time::Local qw(timelocal);
               1                                  2   
               1                                  5   
1576           1                    1             6   use Data::Dumper;
               1                                  2   
               1                                  5   
1577                                                  
1578  ***      1            50      1             6   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  2   
               1                                 12   
1579                                                  
1580                                                  sub new {
1581           1                    1             6      my ( $class, %args ) = @_;
1582           1                                  6      my ($ip, $port) = split(/:/, $args{watch});
1583  ***      1            50                   15      my $self = {
1584                                                        sessions => {},
1585                                                        requests => 0,
1586                                                        port     => $port || 3306,
1587                                                     };
1588           1                                 12      return bless $self, $class;
1589                                                  }
1590                                                  
1591                                                  sub parse_event {
1592           4                    4            34      my ( $self, %args ) = @_;
1593           4                                 19      my @required_args = qw(next_event tell);
1594           4                                 14      foreach my $arg ( @required_args ) {
1595  ***      8     50                          36         die "I need a $arg argument" unless $args{$arg};
1596                                                     }
1597           4                                 17      my ($next_event, $tell) = @args{@required_args};
1598                                                  
1599           4                                 13      my $sessions   = $self->{sessions};
1600           4                                 12      my $pos_in_log = $tell->();
1601           4                                 10      my $line;
1602                                                  
1603                                                     EVENT:
1604           4                                 13      while ( defined($line = $next_event->()) ) {
1605           8                                 78         my ( $ts, $us, $src, $dst )
1606                                                           = $line =~ m/([0-9-]{10} [0-9:]{8})(\.\d{6}) IP (\S+) > (\S+):/;
1607  ***      8     50                          32         next unless $ts;
1608           8                                 28         my $unix_timestamp = make_ts($ts) . $us;
1609                                                  
1610           8    100                          63         if ( $dst =~ m/\.$self->{port}$/o ) {
                    100                               
1611           3                                 26            $sessions->{$src} = {
1612                                                              pos_in_log => $pos_in_log,
1613                                                              ts         => $unix_timestamp,
1614                                                              id         => $self->{requests}++,
1615                                                           };
1616                                                        }
1617                                                  
1618                                                        elsif (defined (my $event = $sessions->{$dst}) ) {
1619           3                                 20            my ( $src_host, $src_port ) = $dst =~ m/^(.*)\.(\d+)$/;
1620           3                                 12            $event->{end}  = $unix_timestamp;
1621           3                                  9            $event->{host} = $src_host;
1622           3                                 14            $event->{port} = $src_port;
1623           3                                 10            $event->{arg}  = undef;
1624           3                                  6            MKDEBUG && _d('Properties of event:', Dumper($event));
1625           3                                 10            delete $sessions->{$dst};
1626           3                                 22            return $event;
1627                                                        }
1628           5                                 16         $pos_in_log = $tell->();
1629                                                     } # EVENT
1630                                                  
1631  ***      1     50                           7      $args{oktorun}->(0) if $args{oktorun};
1632           1                                  6      return;
1633                                                  }
1634                                                  
1635                                                  {
1636                                                     my ($last, $result);
1637                                                     sub make_ts {
1638           8                    8            25         my ($arg) = @_;
1639  ***      8    100     66                   79         if ( !$last || $last ne $arg ) {
1640           1                                  9            my ($year, $mon, $mday, $hour, $min, $sec) = split(/\D/, $arg);
1641           1                                 10            $result = timelocal($sec, $min, $hour, $mday, $mon - 1, $year);
1642           1                                  4            $last   = $arg;
1643                                                        }
1644           8                                 35         return $result;
1645                                                     }
1646                                                  }
1647                                                  
1648                                                  sub _d {
1649  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1650  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1651  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1652                                                          @_;
1653  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1654                                                  }
1655                                                  
1656                                                  1;
1657                                                  
1658                                                  # ###########################################################################
1659                                                  # End SimpleTCPDumpParser package
1660                                                  # ###########################################################################
1661                                                  
1662                                                  # ###########################################################################
1663                                                  # TCPRequestAggregator package 7450
1664                                                  # This package is a copy without comments from the original.  The original
1665                                                  # with comments and its test file can be found in the SVN repository at,
1666                                                  #   trunk/common/TCPRequestAggregator.pm
1667                                                  #   trunk/common/t/TCPRequestAggregator.t
1668                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1669                                                  # ###########################################################################
1670                                                  package TCPRequestAggregator;
1671                                                  
1672           1                    1             7   use strict;
               1                                  2   
               1                                  5   
1673           1                    1             5   use warnings FATAL => 'all';
               1                                  3   
               1                                  5   
1674           1                    1            11   use English qw(-no_match_vars);
               1                                  2   
               1                                  4   
1675           1                    1             6   use List::Util qw(sum);
               1                                  2   
               1                                  6   
1676           1                    1             6   use Data::Dumper;
               1                                  2   
               1                                  5   
1677                                                  
1678  ***      1            50      1             5   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               1                                  3   
               1                                 11   
1679                                                  
1680                                                  sub new {
1681  ***      0                    0             0      my ( $class, %args ) = @_;
1682  ***      0                                  0      my @required_args = qw(interval quantile);
1683  ***      0                                  0      foreach my $arg ( @required_args ) {
1684  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1685                                                     }
1686  ***      0                                  0      my $self = {
1687                                                        buffer             => [],
1688                                                        last_weighted_time => 0,
1689                                                        last_res_time      => 0,
1690                                                        last_completions   => 0,
1691                                                        current_ts         => 0,
1692                                                        %args,
1693                                                     };
1694  ***      0                                  0      return bless $self, $class;
1695                                                  }
1696                                                  
1697                                                  sub parse_event {
1698  ***      0                    0             0      my ( $self, %args ) = @_;
1699  ***      0                                  0      my @required_args = qw(next_event tell);
1700  ***      0                                  0      foreach my $arg ( @required_args ) {
1701  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1702                                                     }
1703  ***      0                                  0      my ($next_event, $tell) = @args{@required_args};
1704                                                  
1705  ***      0                                  0      my $pos_in_log = $tell->();
1706  ***      0                                  0      my $buffer = $self->{buffer};
1707  ***      0             0                    0      $self->{last_pos_in_log} ||= $pos_in_log;
1708                                                  
1709                                                     EVENT:
1710  ***      0                                  0      while ( 1 ) {
1711  ***      0                                  0         MKDEBUG && _d("Beginning a loop at pos", $pos_in_log);
1712  ***      0                                  0         my ( $id, $start, $elapsed );
1713                                                  
1714  ***      0                                  0         my ($timestamp, $direction);
1715  ***      0      0                           0         if ( $self->{pending} ) {
      ***             0                               
1716  ***      0                                  0            ( $id, $start, $elapsed ) = @{$self->{pending}};
      ***      0                                  0   
1717  ***      0                                  0            MKDEBUG && _d("Pulled from pending", @{$self->{pending}});
1718                                                        }
1719                                                        elsif ( defined(my $line = $next_event->()) ) {
1720  ***      0                                  0            my ($end, $host_port);
1721  ***      0                                  0            ( $id, $start, $end, $elapsed, $host_port ) = $line =~ m/(\S+)/g;
1722  ***      0                                  0            @$buffer = sort { $a <=> $b } ( @$buffer, $end );
      ***      0                                  0   
1723  ***      0                                  0            MKDEBUG && _d("Read from the file", $id, $start, $end, $elapsed, $host_port);
1724  ***      0                                  0            MKDEBUG && _d("Buffer is now", @$buffer);
1725                                                        }
1726  ***      0      0                           0         if ( $start ) { # Test that we got a line; $id can be 0.
      ***             0                               
1727  ***      0      0      0                    0            if ( @$buffer && $buffer->[0] < $start ) {
1728  ***      0                                  0               $direction       = 'C'; # Completion
1729  ***      0                                  0               $timestamp       = shift @$buffer;
1730  ***      0                                  0               $self->{pending} = [ $id, $start, $elapsed ];
1731  ***      0                                  0               $id = $start = $elapsed = undef;
1732  ***      0                                  0               MKDEBUG && _d("Completion: using buffered end value", $timestamp);
1733  ***      0                                  0               MKDEBUG && _d("Saving line to pending", @{$self->{pending}});
1734                                                           }
1735                                                           else {
1736  ***      0                                  0               $direction       = 'A'; # Arrival
1737  ***      0                                  0               $timestamp       = $start;
1738  ***      0                                  0               $self->{pending} = undef;
1739  ***      0                                  0               MKDEBUG && _d("Deleting pending line");
1740  ***      0                                  0               MKDEBUG && _d("Arrival: using the line");
1741                                                           }
1742                                                        }
1743                                                        elsif ( @$buffer ) {
1744  ***      0                                  0            $direction = 'C';
1745  ***      0                                  0            $timestamp = shift @$buffer;
1746  ***      0                                  0            MKDEBUG && _d("No more lines, reading from buffer", $timestamp);
1747                                                        }
1748                                                        else { # We hit EOF.
1749  ***      0                                  0            MKDEBUG && _d("No more lines, no more buffered end times");
1750  ***      0      0                           0            if ( $self->{in_prg} ) {
1751  ***      0                                  0               die "Error: no more lines, but in_prg = $self->{in_prg}";
1752                                                           }
1753  ***      0      0                           0            if ( $self->{t_start} < $self->{current_ts} ) {
1754  ***      0                                  0               MKDEBUG && _d("Returning event based on what's been seen");
1755  ***      0                                  0               return $self->make_event($self->{t_start}, $self->{current_ts});
1756                                                           }
1757                                                           else {
1758  ***      0                                  0               MKDEBUG && _d("No further events to make");
1759  ***      0                                  0               return;
1760                                                           }
1761                                                        }
1762                                                  
1763  ***      0                                  0         my $t_start = int($timestamp / $self->{interval}) * $self->{interval};
1764  ***      0             0                    0         $self->{t_start} ||= $timestamp; # Not $t_start; that'd skew 1st interval.
1765  ***      0                                  0         MKDEBUG && _d("Timestamp", $timestamp, "interval start time", $t_start);
1766                                                  
1767  ***      0      0                           0         if ( $t_start > $self->{t_start} ) {
1768  ***      0                                  0            MKDEBUG && _d("Timestamp doesn't belong to this interval");
1769  ***      0      0                           0            if ( $self->{in_prg} ) {
1770  ***      0                                  0               MKDEBUG && _d("Computing from", $self->{current_ts}, "to", $t_start);
1771  ***      0                                  0               $self->{res_time}      += $t_start - $self->{current_ts};
1772  ***      0                                  0               $self->{weighted_time} += ($t_start - $self->{current_ts}) * $self->{in_prg};
1773                                                           }
1774                                                  
1775  ***      0      0      0                    0            if ( @$buffer && $buffer->[0] < $t_start ) {
1776  ***      0                                  0               die "Error: completions for interval remain unprocessed";
1777                                                           }
1778                                                  
1779  ***      0                                  0            my $event                = $self->make_event($self->{t_start}, $t_start);
1780  ***      0                                  0            $self->{last_pos_in_log} = $pos_in_log;
1781  ***      0      0                           0            if ( $start ) {
1782  ***      0                                  0               $self->{pending} = [ $id, $start, $elapsed ];
1783                                                           }
1784                                                           else {
1785  ***      0                                  0               unshift @$buffer, $timestamp;
1786                                                           }
1787  ***      0                                  0            return $event;
1788                                                        }
1789                                                  
1790                                                        else {
1791  ***      0      0                           0            if ( $self->{in_prg} ) {
1792  ***      0                                  0               MKDEBUG && _d("Computing from", $self->{current_ts}, "to", $timestamp);
1793  ***      0                                  0               $self->{res_time}      += $timestamp - $self->{current_ts};
1794  ***      0                                  0               $self->{weighted_time} += ($timestamp - $self->{current_ts}) * $self->{in_prg};
1795                                                           }
1796  ***      0                                  0            $self->{current_ts} = $timestamp;
1797  ***      0      0                           0            if ( $direction eq 'A' ) {
1798  ***      0                                  0               MKDEBUG && _d("Direction A", $timestamp);
1799  ***      0                                  0               ++$self->{in_prg};
1800  ***      0      0                           0               if ( defined $elapsed ) {
1801  ***      0                                  0                  push @{$self->{response_times}}, $elapsed;
      ***      0                                  0   
1802                                                              }
1803                                                           }
1804                                                           else {
1805  ***      0                                  0               MKDEBUG && _d("Direction C", $timestamp);
1806  ***      0                                  0               --$self->{in_prg};
1807  ***      0                                  0               ++$self->{completions};
1808                                                           }
1809                                                        }
1810                                                  
1811  ***      0                                  0         $pos_in_log = $tell->();
1812                                                     } # EVENT
1813                                                  
1814  ***      0      0                           0      $args{oktorun}->(0) if $args{oktorun};
1815  ***      0                                  0      return;
1816                                                  }
1817                                                  
1818                                                  sub make_event {
1819  ***      0                    0             0      my ( $self, $t_start, $t_end ) = @_;
1820                                                  
1821  ***      0                                  0      my $quantile_cutoff = sprintf( "%.0f", # Round to nearest int
1822  ***      0                                  0         scalar( @{ $self->{response_times} } ) * $self->{quantile} );
1823  ***      0                                  0      my @times = sort { $a <=> $b } @{ $self->{response_times} };
      ***      0                                  0   
      ***      0                                  0   
1824  ***      0                                  0      my $arrivals = scalar(@times);
1825  ***      0                                  0      my $sum_times = sum( @times );
1826  ***      0             0                    0      my $mean_times = ($sum_times || 0) / ($arrivals || 1);
      ***                    0                        
1827  ***      0                                  0      my $var_times = 0;
1828  ***      0      0                           0      if ( @times ) {
1829  ***      0                                  0         $var_times = sum( map { ($_ - $mean_times) **2 } @times ) / $arrivals;
      ***      0                                  0   
1830                                                     }
1831                                                  
1832  ***      0                                  0      my $e_ts
1833                                                        = int( $self->{current_ts} / $self->{interval} ) * $self->{interval};
1834  ***      0                                  0      my $e_concurrency = sprintf( "%.6f",
1835                                                             ( $self->{weighted_time} - $self->{last_weighted_time} )
1836                                                           / ( $t_end - $t_start ) );
1837  ***      0                                  0      my $e_arrivals   = $arrivals;
1838  ***      0                                  0      my $e_throughput = sprintf( "%.6f", $e_arrivals / ( $t_end - $t_start ) );
1839  ***      0                                  0      my $e_completions
1840                                                        = ( $self->{completions} - $self->{last_completions} );
1841  ***      0                                  0      my $e_res_time
1842                                                        = sprintf( "%.6f", $self->{res_time} - $self->{last_res_time} );
1843  ***      0                                  0      my $e_weighted_time = sprintf( "%.6f",
1844                                                        $self->{weighted_time} - $self->{last_weighted_time} );
1845  ***      0             0                    0      my $e_sum_time = sprintf("%.6f", $sum_times || 0);
1846  ***      0             0                    0      my $e_variance_mean = sprintf("%.6f", $var_times / ($mean_times || 1));
1847  ***      0             0                    0      my $e_quantile_time = sprintf("%.6f", $times[ $quantile_cutoff - 1 ] || 0);
1848                                                  
1849  ***      0                                  0      my $event = {
1850                                                        ts            => $e_ts,
1851                                                        concurrency   => $e_concurrency,
1852                                                        throughput    => $e_throughput,
1853                                                        arrivals      => $e_arrivals,
1854                                                        completions   => $e_completions,
1855                                                        res_time      => $e_res_time ,
1856                                                        weighted_time => $e_weighted_time,
1857                                                        sum_time      => $e_sum_time,
1858                                                        variance_mean => $e_variance_mean,
1859                                                        quantile_time => $e_quantile_time,
1860                                                        pos_in_log    => $self->{last_pos_in_log},
1861                                                        obs_time      => sprintf("%.6f", $t_end - $t_start),
1862                                                     };
1863                                                  
1864  ***      0                                  0      $self->{t_start}            = $t_end;  # Not current_timestamp!
1865  ***      0                                  0      $self->{current_ts}         = $t_end;  # Next iteration will begin at boundary
1866  ***      0                                  0      $self->{last_weighted_time} = $self->{weighted_time};
1867  ***      0                                  0      $self->{last_res_time}      = $self->{res_time};
1868  ***      0                                  0      $self->{last_completions}   = $self->{completions};
1869  ***      0                                  0      $self->{response_times}     = [];
1870                                                  
1871  ***      0                                  0      MKDEBUG && _d("Event is", Dumper($event));
1872  ***      0                                  0      return $event;
1873                                                  }
1874                                                  
1875                                                  sub _d {
1876  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1877  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1878  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1879                                                          @_;
1880  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1881                                                  }
1882                                                  
1883                                                  1;
1884                                                  
1885                                                  # ###########################################################################
1886                                                  # End TCPRequestAggregator package
1887                                                  # ###########################################################################
1888                                                  
1889                                                  # ###########################################################################
1890                                                  # This is a combination of modules and programs in one -- a runnable module.
1891                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
1892                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
1893                                                  #
1894                                                  # Check at the end of this package for the call to main() which actually runs
1895                                                  # the program.
1896                                                  # ###########################################################################
1897                                                  package mk_tcp_model;
1898                                                  
1899           1                    1             7   use English qw(-no_match_vars);
               1                                  2   
               1                                  6   
1900           1                    1             6   use Time::Local qw(timelocal);
               1                                  3   
               1                                  4   
1901           1                    1             6   use Time::HiRes qw(time usleep);
               1                                  2   
               1                                  7   
1902           1                    1             6   use List::Util qw(max);
               1                                  3   
               1                                  5   
1903           1                    1             6   use POSIX qw(signal_h);
               1                                  2   
               1                                  6   
1904           1                    1            10   use Data::Dumper;
               1                                  2   
               1                                  5   
1905                                                  $Data::Dumper::Indent = 1;
1906                                                  $OUTPUT_AUTOFLUSH     = 1;
1907                                                  
1908  ***      1            50      1             7   use constant MKDEBUG        => $ENV{MKDEBUG}        || 0;
               1                                  2   
               1                                 16   
1909                                                  
1910           1                    1            13   use sigtrap 'handler', \&sig_int, 'normal-signals';
               1                                  3   
               1                                 14   
1911                                                  
1912                                                  # Global variables.  Only really essential variables should be here.
1913                                                  my $oktorun = 1;
1914                                                  
1915                                                  sub main {
1916           1                    1           201      @ARGV    = @_;  # set global ARGV for this package
1917           1                                  3      $oktorun = 1;   # reset between tests else pipeline won't run
1918                                                  
1919                                                     # ##########################################################################
1920                                                     # Get configuration information.
1921                                                     # ##########################################################################
1922           1                                  8      my $o = new OptionParser();
1923           1                                  5      $o->get_specs();
1924           1                                 10      $o->get_opts();
1925  ***      1     50                           4      if ( !$o->get('help') ) {
1926  ***      1     50                           3         if ( $o->get('progress') ) {
1927           1                                  3            eval { Progress->validate_spec($o->get('progress')) };
               1                                  3   
1928  ***      1     50                           4            if ( $EVAL_ERROR ) {
1929  ***      0                                  0               chomp $EVAL_ERROR;
1930  ***      0                                  0               $o->save_error("--progress $EVAL_ERROR");
1931                                                           }
1932                                                        }
1933  ***      1     50                           4         if ( $o->get('type') !~ m/^(tcpdump|requests)$/ ) {
1934  ***      0                                  0            $o->save_error("--type must be tcpdump or requests");
1935                                                        }
1936                                                     }
1937           1                                  6      $o->usage_or_errors();
1938                                                  
1939                                                     # ########################################################################
1940                                                     # Set up objects and variables.
1941                                                     # ########################################################################
1942           1                                  9      my $fi     = new FileIterator();
1943           1                                  3      my $parser;
1944  ***      1     50                           5      if ( $o->get('type') eq 'tcpdump' ) { # Default: parse tcpdump
1945           1                                  5         $parser = new SimpleTCPDumpParser(watch => $o->get('watch-server'));
1946                                                     }
1947                                                     else {
1948  ***      0                                  0         $parser = new TCPRequestAggregator(
1949                                                           interval => $o->get('run-time'),
1950                                                           quantile => $o->get('quantile')
1951                                                        );
1952                                                     }
1953                                                  
1954                                                     # ########################################################################
1955                                                     # This is the main loop over the input filenames.
1956                                                     # ########################################################################
1957           1                                  6      my $next_file = $fi->get_file_itr(@ARGV);
1958           1                                  4      my ( $fh, $filename, $filesize ) = $next_file->();
1959                                                     FILE:
1960           1                                 12      while ( defined $fh ) {
1961                                                  
1962                                                        # Create a callback to get events from the input.
1963           1                    9             6         my $next_event = sub { return <$fh>; };
               9                                 70   
1964           1                    9             5         my $tell       = sub { return tell $fh; };
               9                                 47   
1965           1                                  2         my $event;
1966                                                        my $get_event = sub {
1967                                                           return $parser->parse_event(
1968                                                              event      => $event,
1969                                                              next_event => $next_event,
1970                                                              tell       => $tell,
1971           1                                  3               oktorun    => sub { return 1 },
1972           4                    4            36               misc       => {},
1973                                                              stats      => {},
1974                                                           );
1975           1                                  9         };
1976                                                  
1977                                                        # #####################################################################
1978                                                        # Set up a progress reporter.  For right now, we just do one per file.
1979                                                        # Maybe someday we can do a global progress report?
1980                                                        # #####################################################################
1981           1                                  3         my $pr;
1982  ***      1     50     33                    4         if ( $o->get('progress') && $filename && -e $filename ) {
      ***                   33                        
1983           1                                  9            $pr = new Progress(
1984                                                              jobsize => -s $filename,
1985                                                              spec    => $o->get('progress'),
1986                                                              name    => $filename,
1987                                                           );
1988                                                        }
1989                                                  
1990                                                        # #####################################################################
1991                                                        # This is the main loop over the events in the input file.
1992                                                        # #####################################################################
1993                                                        EVENT:
1994           1                                  4         while ( $event = $get_event->() ) {
1995  ***      3     50                          20            if ( $o->get('type') eq 'tcpdump' ) {
1996           3                                 92               printf "%6d %.6f %.6f %9.6f %s:%s\n",
1997                                                                 $event->{id},
1998                                                                 $event->{ts},
1999                                                                 $event->{end},
2000                                                                 $event->{end} - $event->{ts},
2001                                                                 $event->{host},
2002                                                                 $event->{port};
2003                                                           }
2004                                                           else {
2005  ***      0                                  0               printf "%s %5.2f %9.3f %5d %5d %.6f %.6f %.6f %.6f %.6f %.6f\n",
2006  ***      0                                  0                  @{$event}{qw(
2007                                                                  ts concurrency throughput arrivals completions res_time
2008                                                                  weighted_time sum_time variance_mean quantile_time obs_time)};
2009                                                           }
2010  ***      3     50                          19            $pr->update($tell) if $pr;
2011                                                        } # EVENT
2012                                                  
2013           1                                  7         ( $fh, $filename, $filesize ) = $next_file->();
2014                                                     } # FILE
2015                                                  
2016           1                                 69      return 0;
2017                                                  } # End main()
2018                                                  
2019                                                  # ############################################################################
2020                                                  # Subroutines.
2021                                                  # ############################################################################
2022                                                  
2023                                                  # Catches signals so we can exit gracefully.
2024                                                  sub sig_int {
2025  ***      0                    0                    my ( $signal ) = @_;
2026  ***      0      0                                  if ( $oktorun ) {
2027  ***      0                                            print STDERR "# Caught SIG$signal.\n";
2028  ***      0                                            $oktorun = 0;
2029                                                     }
2030                                                     else {
2031  ***      0                                            print STDERR "# Exiting on SIG$signal.\n";
2032  ***      0                                            exit(1);
2033                                                     }
2034                                                  }
2035                                                  
2036                                                  sub _d {
2037  ***      0                    0                    my ($package, undef, $line) = caller 0;
2038  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
2039  ***      0                                              map { defined $_ ? $_ : 'undef' }
2040                                                          @_;
2041  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2042                                                  }
2043                                                  
2044                                                  # ############################################################################
2045                                                  # Run the program.
2046                                                  # ############################################################################
2047                                                  exit main(@ARGV) unless caller;
2048                                                  
2049                                                  1; # Because this is a module as well as a script.
2050                                                  
2051                                                  # #############################################################################
2052                                                  # Documentation.
2053                                                  # #############################################################################
2054                                                  
2055                                                  =pod
2056                                                  
2057                                                  =head1 NAME
2058                                                  
2059                                                  mk-tcp-model - Transform tcpdump into metrics that permit performance and
2060                                                  scalability modeling.
2061                                                  
2062                                                  =head1 SYNOPSIS
2063                                                  
2064                                                  Usage: mk-tcp-model [OPTION...] [FILE]
2065                                                  
2066                                                  mk-tcp-model parses and analyzes tcpdump files.  With no FILE, or when
2067                                                  FILE is -, it read standard input.
2068                                                  
2069                                                  Dump TCP requests and responses to a file, capturing only the packet headers to
2070                                                  avoid dropped packets, and ignoring any packets without a payload (such as
2071                                                  ack-only packets).  Capture port 3306 (MySQL database traffic).  Note that to
2072                                                  avoid line breaking in terminals and man pages, the TCP filtering expression
2073                                                  that follows has a line break at the end of the second line; you should omit
2074                                                  this from your tcpdump command.
2075                                                  
2076                                                   tcpdump -s 384 -i any -nnq -tttt \
2077                                                  	'tcp port 3306 and (((ip[2:2] - ((ip[0]&0xf)<<2)) 
2078                                                        - ((tcp[12]&0xf0)>>2)) != 0)' \
2079                                                     > /path/to/tcp-file.txt
2080                                                  
2081                                                  Extract individual response times, sorted by end time:
2082                                                  
2083                                                   mk-tcp-model /path/to/tcp-file.txt > requests.txt
2084                                                  
2085                                                  Sort the result by arrival time, for input to the next step:
2086                                                  
2087                                                   sort -n -k1,1 requests.txt > sorted.txt
2088                                                  
2089                                                  Slice the result into 10-second intervals and emit throughput, concurrency, and
2090                                                  response time metrics for each interval:
2091                                                  
2092                                                   mk-tcp-model --type=requests --run-time=10 sorted.txt > sliced.txt
2093                                                  
2094                                                  =head1 RISKS
2095                                                  
2096                                                  The following section is included to inform users about the potential risks,
2097                                                  whether known or unknown, of using this tool.  The two main categories of risks
2098                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
2099                                                  tools) and those created by bugs.
2100                                                  
2101                                                  mk-tcp-model merely reads and transforms its input, printing it to the output.
2102                                                  It should be very low risk.
2103                                                  
2104                                                  At the time of this release, we know of no bugs that could cause serious harm
2105                                                  to users.
2106                                                  
2107                                                  The authoritative source for updated information is always the online issue
2108                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
2109                                                  see a list of such issues at the following URL:
2110                                                  L<http://www.maatkit.org/bugs/mk-tcp-model>.
2111                                                  
2112                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
2113                                                  
2114                                                  =head1 DESCRIPTION
2115                                                  
2116                                                  This tool recognizes requests and responses in a TCP stream, and extracts the
2117                                                  "conversations".  You can use it to capture the response times of individual
2118                                                  queries to a database, for example.  It expects the input to be in the following
2119                                                  format, which should result from the sample shown in the SYNOPSIS:
2120                                                  
2121                                                   <date> <time.microseconds> IP <IP.port> > <IP.port>: <junk>
2122                                                  
2123                                                  The tool watches for "incoming" packets to the port you specify with the
2124                                                  L<"--watch-server"> option.  This begins a request.  If multiple inbound packets
2125                                                  follow each other, then the last inbound packet seen determines the time at
2126                                                  which the request is assumed to begin.  This is logical if one assumes that a
2127                                                  server must receive the whole SQL statement before beginning execution, for
2128                                                  example.
2129                                                  
2130                                                  When the first outbound packet is seen, that concludes the request.  We might
2131                                                  see an inbound packet, but never see a response.  This can happen when the
2132                                                  kernel drops packets, for example.  As a result, we never print a request until
2133                                                  we see the response to it, which means that the output is in completion order,
2134                                                  not arrival order.  This can be useful for some kinds of analysis, but others
2135                                                  require processing in arrival order.  Therefore, the second type of processing
2136                                                  this tool can do requires that you sort the output from the first stage and
2137                                                  supply it as input.
2138                                                  
2139                                                  The second type of processing is selected with the L<"--type"> option set to
2140                                                  "requests".  In this mode, the tool reads a group of requests and aggregates
2141                                                  them, then emits the aggregated metrics.
2142                                                  
2143                                                  =head1 OUTPUT
2144                                                  
2145                                                  In the default mode (parsing tcpdump output), requests are printed out one per
2146                                                  line, in the following format:
2147                                                  
2148                                                   <id> <start-time> <end-time> <elapsed> <IP:port>
2149                                                  
2150                                                  In "--type=requests" mode, the tool prints out one line per time interval as
2151                                                  defined by L<"--run-time">, with the following columns:
2152                                                  
2153                                                  =over
2154                                                  
2155                                                  =item ts
2156                                                  
2157                                                  The timestamp that defines the beginning of the interval.
2158                                                  
2159                                                  =item concurrency
2160                                                  
2161                                                  The average number of requests resident in the server during the interval.
2162                                                  
2163                                                  =item throughput
2164                                                  
2165                                                  The number of arrivals per second during the interval.
2166                                                  
2167                                                  =item arrivals
2168                                                  
2169                                                  The number of arrivals during the interval.
2170                                                  
2171                                                  =item completions
2172                                                  
2173                                                  The number of completions during the interval.
2174                                                  
2175                                                  =item res_time
2176                                                  
2177                                                  The total amount of time during which at least one request was resident in
2178                                                  the server during the interval.
2179                                                  
2180                                                  =item weighted_time
2181                                                  
2182                                                  The total response time of all the requests resident in the server during the
2183                                                  interval, including requests that neither arrived nor completed during the
2184                                                  interval.
2185                                                  
2186                                                  =item sum_time
2187                                                  
2188                                                  The total response time of all the requests that arrived in the interval.
2189                                                  
2190                                                  =item variance_mean
2191                                                  
2192                                                  The variance-to-mean ratio (index of dispersion) of the response times of the
2193                                                  requests that arrived in the interval.
2194                                                  
2195                                                  =item quantile_time
2196                                                  
2197                                                  The Nth percentile response time for all the requests that arrived in the
2198                                                  interval.  See also L<"--quantile">.
2199                                                  
2200                                                  =item obs_time
2201                                                  
2202                                                  The length of the observation time window.  This will usually be the same as the
2203                                                  interval length, except for the first and last intervals in a file, which might
2204                                                  have a shorter observation time.
2205                                                  
2206                                                  =back
2207                                                  
2208                                                  =head1 OPTIONS
2209                                                  
2210                                                  This tool accepts additional command-line arguments.  Refer to the
2211                                                  L<"SYNOPSIS"> and usage information for details.
2212                                                  
2213                                                  =over
2214                                                  
2215                                                  =item --config
2216                                                  
2217                                                  type: Array
2218                                                  
2219                                                  Read this comma-separated list of config files; if specified, this must be the
2220                                                  first option on the command line.
2221                                                  
2222                                                  =item --help
2223                                                  
2224                                                  Show help and exit.
2225                                                  
2226                                                  =item --progress
2227                                                  
2228                                                  type: array; default: time,30
2229                                                  
2230                                                  Print progress reports to STDERR.  The value is a comma-separated list with two
2231                                                  parts.  The first part can be percentage, time, or iterations; the second part
2232                                                  specifies how often an update should be printed, in percentage, seconds, or
2233                                                  number of iterations.
2234                                                  
2235                                                  =item --quantile
2236                                                  
2237                                                  type: float
2238                                                  
2239                                                  The percentile for the last column when L<"--type"> is "requests" (default .99).
2240                                                  
2241                                                  =item --run-time
2242                                                  
2243                                                  type: float
2244                                                  
2245                                                  The size of the aggregation interval in seconds when L<"--type"> is "requests"
2246                                                  (default 1).  Fractional values are permitted.
2247                                                  
2248                                                  =item --type
2249                                                  
2250                                                  type: string
2251                                                  
2252                                                  The type of input to parse (default tcpdump).  The permitted types are
2253                                                  
2254                                                  =over
2255                                                  
2256                                                  =item tcpdump
2257                                                  
2258                                                  The parser expects the input to be formatted with the following options: C<-x -n
2259                                                  -q -tttt>.  For example, if you want to capture output from your local machine,
2260                                                  you can do something like the following (the port must come last on FreeBSD):
2261                                                  
2262                                                    tcpdump -s 65535 -x -nn -q -tttt -i any -c 1000 port 3306 \
2263                                                      > mysql.tcp.txt
2264                                                    mk-query-digest --type tcpdump mysql.tcp.txt
2265                                                  
2266                                                  The other tcpdump parameters, such as -s, -c, and -i, are up to you.  Just make
2267                                                  sure the output looks like this (there is a line break in the first line to
2268                                                  avoid man-page problems):
2269                                                  
2270                                                    2009-04-12 09:50:16.804849 IP 127.0.0.1.42167
2271                                                           > 127.0.0.1.3306: tcp 37
2272                                                  
2273                                                  All MySQL servers running on port 3306 are automatically detected in the
2274                                                  tcpdump output.  Therefore, if the tcpdump out contains packets from
2275                                                  multiple servers on port 3306 (for example, 10.0.0.1:3306, 10.0.0.2:3306,
2276                                                  etc.), all packets/queries from all these servers will be analyzed
2277                                                  together as if they were one server.
2278                                                  
2279                                                  If you're analyzing traffic for a protocol that is not running on port
2280                                                  3306, see L<"--watch-server">.
2281                                                  
2282                                                  =back
2283                                                  
2284                                                  =item --version
2285                                                  
2286                                                  Show version and exit.
2287                                                  
2288                                                  =item --watch-server
2289                                                  
2290                                                  type: string; default: 10.10.10.10:3306
2291                                                  
2292                                                  This option tells mk-tcp-model which server IP address and port (such as
2293                                                  "10.0.0.1:3306") to watch when parsing tcpdump for L<"--type"> tcpdump.  If you
2294                                                  don't specify it, the tool watches all servers by looking for any IP address
2295                                                  using port 3306.  If you're watching a server with a non-standard port, this
2296                                                  won't work, so you must specify the IP address and port to watch.
2297                                                  
2298                                                  Currently, IP address filtering isn't implemented; so even though you must
2299                                                  specify the option in IP:port form, it ignores the IP and only looks at the port
2300                                                  number.
2301                                                  
2302                                                  =back
2303                                                  
2304                                                  =head1 DOWNLOADING
2305                                                  
2306                                                  You can download Maatkit from Google Code at
2307                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
2308                                                  easily with a command like the following:
2309                                                  
2310                                                     wget http://www.maatkit.org/get/toolname
2311                                                     or
2312                                                     wget http://www.maatkit.org/trunk/toolname
2313                                                  
2314                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
2315                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
2316                                                  needed.  The first URL gets the latest released version of the tool, and the
2317                                                  second gets the latest trunk code from Subversion.
2318                                                  
2319                                                  =head1 ENVIRONMENT
2320                                                  
2321                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
2322                                                  the Maatkit tools:
2323                                                  
2324                                                     MKDEBUG=1 mk-....
2325                                                  
2326                                                  =head1 SYSTEM REQUIREMENTS
2327                                                  
2328                                                  You need Perl and some core packages that ought to be installed in any
2329                                                  reasonably new version of Perl.
2330                                                  
2331                                                  =head1 BUGS
2332                                                  
2333                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-tcp-model>.
2334                                                  
2335                                                  Please use Google Code Issues and Groups to report bugs or request support:
2336                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
2337                                                  discuss Maatkit.
2338                                                  
2339                                                  Please include the complete command-line used to reproduce the problem you are
2340                                                  seeing, the version of all MySQL servers involved, the complete output of the
2341                                                  tool when run with L<"--version">, and if possible, debugging output produced by
2342                                                  running with the C<MKDEBUG=1> environment variable.
2343                                                  
2344                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
2345                                                  
2346                                                  This program is copyright 2011-@CURRENTYEAR@ Baron Schwartz.
2347                                                  Feedback and improvements are welcome.
2348                                                  
2349                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
2350                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
2351                                                  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
2352                                                  
2353                                                  This program is free software; you can redistribute it and/or modify it under
2354                                                  the terms of the GNU General Public License as published by the Free Software
2355                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
2356                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
2357                                                  licenses.
2358                                                  
2359                                                  You should have received a copy of the GNU General Public License along with
2360                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
2361                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
2362                                                  
2363                                                  =head1 AUTHOR
2364                                                  
2365                                                  Baron Schwartz
2366                                                  
2367                                                  =head1 ABOUT MAATKIT
2368                                                  
2369                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
2370                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
2371                                                  code contributors.  Both are employed by Percona.  Financial support for
2372                                                  Maatkit development is primarily provided by Percona and its clients. 
2373                                                  
2374                                                  =head1 VERSION
2375                                                  
2376                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 7407 $.
2377                                                  
2378                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
52    ***      0      0      0   unless $args{$arg}
121   ***     50      0      1   unless open my $fh, '<', $file
124   ***     50      0      1   if ($contents =~ /^=head1 DSN OPTIONS/m)
134   ***      0      0      0   if ($val)
135   ***      0      0      0   $val eq 'no' ? :
      ***      0      0      0   $val eq 'yes' ? :
183   ***     50      0      1   unless open my $fh, '<', $file
191          100    307      1   unless $para =~ /^=head1 $$self{'head1'}/
196          100      1      1   if $para =~ /^=over/
197   ***     50      0      1   if $$self{'skip_rules'}
205   ***     50      0      1   unless $para
208          100      8      2   if (my($option) = $para =~ /^=item $$self{'item'}/)
215          100      6      2   if ($para =~ /: /) { }
219   ***     50      0      8   unless $$self{'attributes'}{$attrib}
223   ***     50      0      6   if ($attribs{'short form'})
239   ***     50      0      8   if $para =~ /^=item/
241   ***     50      0      8   if (my($base_option) = $option =~ /^\[no\](.*)/)
246          100      2      6   defined $attribs{'default'} ? :
      ***     50      0      8   $attribs{'group'} ? :
254   ***     50      0     20   unless $para
255          100      1     19   if ($para =~ /^=head1/)
259          100      9     10   if $para =~ /^=item /
263   ***     50      0      1   unless @specs
274          100      8      1   if (ref $opt) { }
279   ***     50      0      8   if (not $long)
284   ***     50      0      8   if exists $$self{'opts'}{$long}
287   ***     50      0      8   if (length $long == 1)
292   ***     50      0      8   if ($short) { }
293   ***      0      0      0   if exists $$self{'short_opts'}{$short}
302   ***     50      0      8   $$opt{'spec'} =~ /!/ ? :
303   ***     50      0      8   $$opt{'spec'} =~ /\+/ ? :
304   ***     50      0      8   $$opt{'desc'} =~ /required/ ? :
317          100      2      6   if $type and $type =~ /[HhAadzm]/
319          100      5      3   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
320   ***     50      5      0   defined $def ? :
324          100      1      7   if ($long eq 'config')
328   ***     50      0      8   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
341   ***     50      0      1   if ($opt =~ /mutually exclusive|one and only one/)
346   ***     50      0      1   if ($opt =~ /at least one|one and only one/)
351   ***     50      0      1   if ($opt =~ /default to/)
356   ***     50      0      1   if ($opt =~ /restricted to option groups/)
365   ***     50      1      0   if ($opt =~ /accepts additional command-line arguments/)
371   ***     50      0      1   unless $rule_ok
388   ***      0      0      0   unless exists $$self{'opts'}{$long}
412   ***      0      0      0   unless exists $$self{'opts'}{$long}
432   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***      0      0      0   exists $$self{'opts'}{$opt} ? :
437   ***      0      0      0   if ($$opt{'is_cumulative'}) { }
452   ***     50      0      2   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100      6      2   exists $$self{'defaults'}{$long} ? :
461   ***     50      0      1   if (@ARGV and $ARGV[0] eq '--config')
465   ***     50      1      0   if ($self->has('config'))
471   ***     50      4      0   if ($EVAL_ERROR)
472   ***     50      0      4   $self->got('config') ? :
487   ***     50      0      1   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
490   ***     50      0      1   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
491   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
497   ***     50      0      1   if (@ARGV and $$self{'strict'})
503   ***      0      0      0   if (@set > 1)
514   ***      0      0      0   if (@set == 0)
533   ***     50      0      8   unless $long
535   ***     50      0      8   if ($$opt{'got'}) { }
      ***     50      0      8   elsif ($$opt{'is_required'}) { }
536   ***      0      0      0   if (exists $$self{'disables'}{$long})
543   ***      0      0      0   if (exists $$self{'allowed_groups'}{$long})
555   ***      0      0      0   if $restricted_opt eq $long
556   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
561   ***      0      0      0   if (@restricted_opts)
563   ***      0      0      0   if (@restricted_opts == 1) { }
584   ***     50      8      0   if ($$opt{'parsed'}) { }
592   ***     50      0      1   if @long == $long_last
602   ***     50      0      8   unless $opt
604          100      2      6   if (not $$opt{'type'})
611   ***     50      0      6   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0      6   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0      6   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0      6   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100      2      4   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
614   ***      0      0      0   if (not $suffix)
620   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
621   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
636   ***      0      0      0   if ($from_key)
638   ***      0      0      0   if ($$self{'opts'}{$from_key}{'parsed'}) { }
671   ***     50      0     12   length $opt == 1 ? :
672   ***     50      0     12   unless $long and exists $$self{'opts'}{$long}
679   ***     50      0      4   length $opt == 1 ? :
680   ***     50      0      4   unless $long and exists $$self{'opts'}{$long}
687   ***     50      0      1   length $opt == 1 ? :
688   ***     50      1      0   defined $long ? :
693   ***      0      0      0   length $opt == 1 ? :
694   ***      0      0      0   unless $long and exists $$self{'opts'}{$long}
713   ***      0      0      0   unless $$self{'usage'}
719   ***      0      0      0   unless $$self{'description'}
724   ***      0      0      0   unless $ENV{'DONT_BREAK_LINES'}
734   ***     50      1      0   if (not $$self{'description'} or not $$self{'usage'})
743   ***     50      0      1   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0      1   elsif (scalar @{$$self{'errors'};}) { }
744   ***      0      0      0   unless print $self->print_usage
745   ***      0      0      0   unless $return
748   ***      0      0      0   unless print $self->print_errors
749   ***      0      0      0   unless $return
758   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
767   ***      0      0      0   unless $$self{'got_opts'}
770   ***      0      0      0   $$_{'is_negatable'} ? :
      ***      0      0      0   $$_{'type'} ? :
778   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
      ***      0      0      0   $$self{'opts'}{$_}{'type'} ? :
798   ***      0      0      0   $group eq 'default' ? :
804   ***      0      0      0   $$opt{'is_negatable'} ? :
808   ***      0      0      0   $$opt{'type'} ? :
810   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
819   ***      0      0      0   if ($short) { }
830   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
834   ***      0      0      0   if ($$self{'DSNParser'})
842   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
854   ***      0      0      0   if ref $_[0] eq 'OptionParser'
857   ***      0      0      0   unless print $prompt
865   ***      0      0      0   unless print "\n"
868   ***      0      0      0   if ($EVAL_ERROR)
890   ***     50      4      0   unless open my $fh, '<', $filename
898   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
901   ***      0      0      0   if ($line eq '--')
906   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
924   ***      0      0      0   unless open my $fh, '<', $file
928   ***      0      0      0   unless $para =~ /^=pod$/m
932   ***      0      0      0   unless $para =~ /$regex/
937   ***      0      0      0   unless close $fh
951   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
967   ***      0      0      0   if (lc($val || '') eq 'null')
975   ***      0      0      0   if (defined $num) { }
976   ***      0      0      0   if ($factor)
992   ***     50      0      8   $$attribs{'short form'} ? :
      ***     50      0      8   $$attribs{'negatable'} ? :
      ***     50      0      8   $$attribs{'cumulative'} ? :
             100      6      2   $$attribs{'type'} ? :
1005  ***     50      0      1   unless open my $fh, '<', $file
1008  ***     50      0      1   unless $para
1017  ***     50      0      1   unless $usage and $desc
1036  ***      0      0      0   defined $_ ? :
1088  ***      0      0      0   defined $args{'p_ms'} ? :
1089  ***      0      0      0   defined $args{'p_s'} ? :
1092  ***      0      0      0   if $t < 0
1096  ***      0      0      0   if $t =~ /e/
1102  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
1124  ***      0      0      0   $p ? :
1131  ***      0      0      0   unless $secs
1134  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
1139  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
1160  ***      0      0      0   unless defined $val
1164  ***      0      0      0   if ($suffix =~ /[smhd]/) { }
1165  ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1170  ***      0      0      0   if $prefix and $prefix eq '-'
1180  ***      0      0      0   defined $args{'p'} ? :
1181  ***      0      0      0   defined $args{'d'} ? :
1188  ***      0      0      0   $num =~ /\./ || $n ? :
1199  ***      0      0      0   $gmt ? :
1205  ***      0      0      0   if (my($us) = $time =~ /(\.\d+)$/)
1217  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
1220  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
1232  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $us) = $val =~ /^$proper_ts$/)
1233  ***      0      0      0   $gmt ? :
1236  ***      0      0      0   if (defined $us)
1257  ***      0      0      0   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
      ***      0      0      0   elsif ($val =~ /^\d{9,}/) { }
      ***      0      0      0   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***      0      0      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
1258  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1275  ***      0      0      0   unless $hms
1280  ***      0      0      0   unless $hms
1285  ***      0      0      0   if $callback and ref $callback eq 'CODE'
1305  ***      0      0      0   unless $string
1311  ***      0      0      0   $comp & 1 ? :
1320  ***      0      0      0   defined $_ ? :
1356  ***     50      0      1   unless defined $args{$arg}
1358  ***     50      1      0   if (not $args{'report'} or not $args{'interval'})
1359  ***     50      1      0   if ($args{'spec'} and @{$args{'spec'};} == 2) { }
1386  ***     50      1      0   if $_[0] eq 'Progress'
1388  ***     50      0      1   if (@$spec != 2)
1391  ***     50      0      1   if (not $$spec[0] =~ /^(?:percentage|time|iterations)$/)
1395  ***     50      0      1   if (not $$spec[1] =~ /^\d+$/)
1416  ***     50      3      0   if ($$self{'report'} eq 'time' and $$self{'interval'} > $now - $$self{'last_reported'}) { }
      ***      0      0      0   elsif ($$self{'report'} eq 'iterations' and ($$self{'iterations'} - 1) % $$self{'interval'} > 0) { }
1431  ***      0      0      0   if $completed > $jobsize
1433  ***      0      0      0   $completed > 0 ? :
1435  ***      0      0      0   if ($$self{'report'} eq 'percentage' and $self->fraction_modulo($$self{'fraction'}) >= $self->fraction_modulo($fraction))
1447  ***      0      0      0   if ($completed > 0 and $completed <= $jobsize and $elapsed > 0)
1449  ***      0      0      0   if ($rate > 0)
1466  ***      0      0      0   defined $_ ? :
1513  ***     50      0      1   if (not defined $fn)
1517  ***     50      1      0   if ($fn ne '-')
1518  ***     50      0      1   if (not -e $fn or not -r $fn)
1526  ***     50      0      1   if (not @filenames)
1536  ***     50      0      1   if ($fn eq '-')
1539  ***     50      0      1   unless open my $fh, '<', $fn
1540  ***     50      1      0   if ($fh)
1550  ***      0      0      0   defined $_ ? :
1595  ***     50      0      8   unless $args{$arg}
1607  ***     50      0      8   unless $ts
1610         100      3      5   if ($dst =~ /\.$$self{'port'}$/o) { }
             100      3      2   elsif (defined(my $event = $$sessions{$dst})) { }
1631  ***     50      1      0   if $args{'oktorun'}
1639         100      1      7   if (not $last or $last ne $arg)
1650  ***      0      0      0   defined $_ ? :
1684  ***      0      0      0   unless $args{$arg}
1701  ***      0      0      0   unless $args{$arg}
1715  ***      0      0      0   if ($$self{'pending'}) { }
      ***      0      0      0   elsif (defined(my $line = &$next_event())) { }
1726  ***      0      0      0   if ($start) { }
      ***      0      0      0   elsif (@$buffer) { }
1727  ***      0      0      0   if (@$buffer and $$buffer[0] < $start) { }
1750  ***      0      0      0   if ($$self{'in_prg'})
1753  ***      0      0      0   if ($$self{'t_start'} < $$self{'current_ts'}) { }
1767  ***      0      0      0   if ($t_start > $$self{'t_start'}) { }
1769  ***      0      0      0   if ($$self{'in_prg'})
1775  ***      0      0      0   if (@$buffer and $$buffer[0] < $t_start)
1781  ***      0      0      0   if ($start) { }
1791  ***      0      0      0   if ($$self{'in_prg'})
1797  ***      0      0      0   if ($direction eq 'A') { }
1800  ***      0      0      0   if (defined $elapsed)
1814  ***      0      0      0   if $args{'oktorun'}
1828  ***      0      0      0   if (@times)
1877  ***      0      0      0   defined $_ ? :
1925  ***     50      1      0   if (not $o->get('help'))
1926  ***     50      1      0   if ($o->get('progress'))
1928  ***     50      0      1   if ($EVAL_ERROR)
1933  ***     50      0      1   if (not $o->get('type') =~ /^(tcpdump|requests)$/)
1944  ***     50      1      0   if ($o->get('type') eq 'tcpdump') { }
1982  ***     50      1      0   if ($o->get('progress') and $filename and -e $filename)
1995  ***     50      3      0   if ($o->get('type') eq 'tcpdump') { }
2010  ***     50      3      0   if $pr
2026  ***      0      0      0   if ($oktorun) { }
2038  ***      0      0      0   defined $_ ? :


Conditions
----------

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
317          100      2      4      2   $type and $type =~ /[HhAadzm]/
461   ***     33      0      1      0   @ARGV and $ARGV[0] eq '--config'
490   ***     33      0      1      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
497   ***     33      0      1      0   @ARGV and $$self{'strict'}
611   ***     33      0      6      0   $val and $$opt{'type'} eq 'm'
      ***     33      0      6      0   $val and $$opt{'type'} eq 'd'
      ***     33      0      6      0   $val and $$opt{'type'} eq 'z'
      ***     33      0      6      0   defined $val and $$opt{'type'} eq 'h'
      ***     66      0      4      1   defined $val and $$opt{'type'} eq 'a'
672   ***     33      0      0     12   $long and exists $$self{'opts'}{$long}
680   ***     33      0      0      4   $long and exists $$self{'opts'}{$long}
694   ***      0      0      0      0   $long and exists $$self{'opts'}{$long}
810   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
906   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1007  ***     66      0      1    256   defined($para = <$fh>) and not $para =~ /^=head1 SYNOPSIS/
1017  ***     33      0      0      1   $usage and $desc
1102  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
1170  ***      0      0      0      0   $prefix and $prefix eq '-'
1184  ***      0      0      0      0   $num >= $d and $n < @units - 1
1285  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
1359  ***     33      0      0      1   $args{'spec'} and @{$args{'spec'};} == 2
1416  ***     33      0      0      3   $$self{'report'} eq 'time' and $$self{'interval'} > $now - $$self{'last_reported'}
      ***      0      0      0      0   $$self{'report'} eq 'iterations' and ($$self{'iterations'} - 1) % $$self{'interval'} > 0
1435  ***      0      0      0      0   $$self{'report'} eq 'percentage' and $self->fraction_modulo($$self{'fraction'}) >= $self->fraction_modulo($fraction)
1447  ***      0      0      0      0   $completed > 0 and $completed <= $jobsize
      ***      0      0      0      0   $completed > 0 and $completed <= $jobsize and $elapsed > 0
1727  ***      0      0      0      0   @$buffer and $$buffer[0] < $start
1775  ***      0      0      0      0   @$buffer and $$buffer[0] < $t_start
1982  ***     33      0      0      1   $o->get('progress') and $filename
      ***     33      0      0      1   $o->get('progress') and $filename and -e $filename

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
42    ***     50      0      1   $ENV{'MKDEBUG'} || 0
56    ***     50      1      0   $program_name ||= $PROGRAM_NAME
57    ***     50      1      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
117   ***     50      0      1   $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model'
      ***     50      0      1   $file ||= $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model'
182   ***      0      0      0   $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model'
      ***     50      1      0   $file ||= $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model'
306   ***     50      8      0   $$opt{'group'} ||= 'default'
616   ***      0      0      0   $s || 's'
625   ***      0      0      0   $prefix || ''
655   ***      0      0      0   $val || ''
658   ***     50      2      0   $val || ''
714   ***      0      0      0   $$self{'usage'} || ''
720   ***      0      0      0   $$self{'description'} || $$self{'program_name'} || ''
732   ***     50      0      1   $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model'
      ***     50      0      1   $file ||= $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model'
737   ***     50      0      1   $$self{'description'} ||= $synop{'description'}
738   ***     50      0      1   $$self{'usage'} ||= $synop{'usage'}
812   ***      0      0      0   $s ||= 's'
840   ***      0      0      0   $$opt{'type'} || ''
967   ***      0      0      0   $val || ''
981   ***      0      0      0   $pre || ''
1001  ***      0      0      0   $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model'
      ***     50      1      0   $file ||= $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model'
1061  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1123  ***      0      0      0   $args{'p'} || 0
1125  ***      0      0      0   $of ||= 1
1130  ***      0      0      0   $secs ||= 0
1163  ***      0      0      0   $suffix || $default_suffix || 's'
1351  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1367  ***     50      1      0   $args{'name'} || 'Progress'
1368  ***     50      0      1   $args{'start'} ||= time
1413  ***     50      0      3   $now ||= time
1497  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1578  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1583  ***     50      1      0   $port || 3306
1678  ***     50      0      1   $ENV{'MKDEBUG'} || 0
1826  ***      0      0      0   $sum_times || 0
      ***      0      0      0   $arrivals || 1
1845  ***      0      0      0   $sum_times || 0
1846  ***      0      0      0   $mean_times || 1
1847  ***      0      0      0   $times[$quantile_cutoff - 1] || 0
1908  ***     50      0      1   $ENV{'MKDEBUG'} || 0

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
57    ***     33      1      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33      1      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
611   ***     33      0      0      6   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
             100      1      1      4   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
720   ***      0      0      0      0   $$self{'description'} || $$self{'program_name'}
734   ***     33      1      0      0   not $$self{'description'} or not $$self{'usage'}
1134  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
1163  ***      0      0      0      0   $suffix || $default_suffix
1188  ***      0      0      0      0   $num =~ /\./ || $n
1358  ***     33      1      0      0   not $args{'report'} or not $args{'interval'}
1407  ***      0      0      0      0   $start || time
1518  ***     33      0      0      1   not -e $fn or not -r $fn
1639  ***     66      1      0      7   not $last or $last ne $arg
1707  ***      0      0      0      0   $$self{'last_pos_in_log'} ||= $pos_in_log
1764  ***      0      0      0      0   $$self{'t_start'} ||= $timestamp


Covered Subroutines
-------------------

Subroutine         Count Location                                                     
------------------ ----- -------------------------------------------------------------
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1055
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1056
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1057
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1058
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1059
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1061
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1342
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1343
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1345
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1346
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1351
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1488
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1489
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1491
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1492
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1497
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1572
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1573
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1574
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1575
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1576
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1578
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1672
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1673
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1674
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1675
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1676
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1678
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1899
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1900
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1901
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1902
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1903
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1904
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1908
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1910
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:20  
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:21  
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:38  
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:39  
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:40  
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:41  
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:42  
BEGIN                  1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:44  
__ANON__               2 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1533
__ANON__               9 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1963
__ANON__               9 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1964
__ANON__               4 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1972
_check_opts            1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:528 
_get_participants      1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:385 
_parse_attribs         8 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:990 
_parse_specs           1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:270 
_parse_synopsis        1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1000
_pod_to_specs          1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:181 
_read_config_file      4 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:889 
_validate_type         8 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:601 
get                   12 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:670 
get_defaults_files     1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:176 
get_file_itr           1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1508
get_opts               1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:448 
get_specs              1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:116 
got                    4 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:678 
has                    1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:686 
main                   1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1916
make_ts                8 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1638
new                    1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1354
new                    1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1500
new                    1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1581
new                    1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:49  
parse_event            4 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1592
update                 3 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1411
usage_or_errors        1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:731 
validate_spec          1 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1386

Uncovered Subroutines
---------------------

Subroutine         Count Location                                                     
------------------ ----- -------------------------------------------------------------
DSNParser              0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:171 
__ANON__               0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:131 
__ANON__               0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1374
__ANON__               0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:485 
_d                     0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1035
_d                     0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1319
_d                     0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1465
_d                     0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1549
_d                     0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1649
_d                     0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1876
_d                     0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:2037
_parse_size            0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:965 
_set_option            0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:431 
any_unix_timestamp     0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1255
clone                  0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:942 
crc32                  0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1304
descr                  0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:718 
errors                 0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:707 
fraction_modulo        0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1458
get_defaults           0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:421 
get_groups             0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:426 
make_checksum          0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1294
make_event             0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1819
micro_t                0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1087
new                    0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1681
opts                   0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:397 
parse_event            0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1698
parse_timestamp        0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1216
percentage_of          0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1122
print_errors           0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:756 
print_usage            0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:766 
prompt_noecho          0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:854 
read_para_after        0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:923 
save_error             0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:701 
secs_to_time           0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1129
set                    0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:692 
set_callback           0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1401
set_defaults           0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:409 
short_opts             0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:403 
shorten                0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1179
sig_int                0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:2025
start                  0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1406
time_to_secs           0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1159
ts                     0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1198
unix_timestamp         0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:1231
usage                  0 /home/daniel/dev/maatkit/trunk/mk-tcp-model/mk-tcp-model:712 


