---------------------------- ------ ------ ------ ------ ------ ------ ------
File                           stmt   bran   cond    sub    pod   time  total
---------------------------- ------ ------ ------ ------ ------ ------ ------
...e/mk-online-schema-change   48.9   29.2   27.4   61.5    n/a  100.0   42.3
Total                          48.9   29.2   27.4   61.5    n/a  100.0   42.3
---------------------------- ------ ------ ------ ------ ------ ------ ------


Run:          -e
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu May  5 00:31:29 2011
Finish:       Thu May  5 00:31:29 2011

Run:          ./001_check_tables.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu May  5 00:31:30 2011
Finish:       Thu May  5 00:31:31 2011

Run:          ./101_basics.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu May  5 00:31:34 2011
Finish:       Thu May  5 00:31:37 2011

Run:          ./102_alter_active_table.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu May  5 00:31:41 2011
Finish:       Thu May  5 00:31:48 2011

Run:          ./103_option_sanity.t
Perl version: 118.53.46.49.48.46.48
OS:           linux
Start:        Thu May  5 00:31:51 2011
Finish:       Thu May  5 00:31:52 2011

/home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change

line  err   stmt   bran   cond    sub    pod   time   code
1                                                     #!/usr/bin/env perl
2                                                     # This program is copyright 2011-@CURRENTYEAR@ Percona Inc.
3                                                     # Feedback and improvements are welcome.
4                                                     #
5                                                     # THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
6                                                     # WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
7                                                     # MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
8                                                     #
9                                                     # This program is free software; you can redistribute it and/or modify it under
10                                                    # the terms of the GNU General Public License as published by the Free Software
11                                                    # Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
12                                                    # systems, you can issue `man perlgpl' or `man perlartistic' to read these
13                                                    # licenses.
14                                                    #
15                                                    # You should have received a copy of the GNU General Public License along with
16                                                    # this program; if not, write to the Free Software Foundation, Inc., 59 Temple
17                                                    # Place, Suite 330, Boston, MA  02111-1307  USA.
18                                                    
19             3                    3            27   use strict;
               3                                  8   
               3                                 21   
20             3                    3            19   use warnings FATAL => 'all';
               3                                 11   
               3                                 19   
21                                                    
22                                                    our $VERSION = '@VERSION@';
23                                                    our $DISTRIB = '@DISTRIB@';
24                                                    our $SVN_REV = sprintf("%d", (q$Revision: 7461 $ =~ m/(\d+)/g, 0));
25                                                    
26                                                    # ###########################################################################
27                                                    # OptionParser package 7102
28                                                    # This package is a copy without comments from the original.  The original
29                                                    # with comments and its test file can be found in the SVN repository at,
30                                                    #   trunk/common/OptionParser.pm
31                                                    #   trunk/common/t/OptionParser.t
32                                                    # See http://code.google.com/p/maatkit/wiki/Developers for more information.
33                                                    # ###########################################################################
34                                                    
35                                                    package OptionParser;
36                                                    
37             3                    3            20   use strict;
               3                                  8   
               3                                 17   
38             3                    3            19   use warnings FATAL => 'all';
               3                                  6   
               3                                 15   
39             3                    3            21   use List::Util qw(max);
               3                                  7   
               3                                 37   
40             3                    3            23   use English qw(-no_match_vars);
               3                                  8   
               3                                 19   
41    ***      3            50      3            22   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                 13   
               3                                 48   
42                                                    
43             3                    3            38   use Getopt::Long;
               3                                 11   
               3                                 20   
44                                                    
45                                                    my $POD_link_re = '[LC]<"?([^">]+)"?>';
46                                                    
47                                                    sub new {
48            16                   16           154      my ( $class, %args ) = @_;
49            16                                 71      my @required_args = qw();
50            16                                 82      foreach my $arg ( @required_args ) {
51    ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
52                                                       }
53                                                    
54            16                                238      my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
55    ***     16            50                   72      $program_name ||= $PROGRAM_NAME;
56    ***     16            33                  151      my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';
      ***                   33                        
      ***                   50                        
57                                                    
58            16                                170      my %attributes = (
59                                                          'type'       => 1,
60                                                          'short form' => 1,
61                                                          'group'      => 1,
62                                                          'default'    => 1,
63                                                          'cumulative' => 1,
64                                                          'negatable'  => 1,
65                                                       );
66                                                    
67            16                                792      my $self = {
68                                                          head1             => 'OPTIONS',        # These args are used internally
69                                                          skip_rules        => 0,                # to instantiate another Option-
70                                                          item              => '--(.*)',         # Parser obj that parses the
71                                                          attributes        => \%attributes,     # DSN OPTIONS section.  Tools
72                                                          parse_attributes  => \&_parse_attribs, # don't tinker with these args.
73                                                    
74                                                          %args,
75                                                    
76                                                          strict            => 1,  # disabled by a special rule
77                                                          program_name      => $program_name,
78                                                          opts              => {},
79                                                          got_opts          => 0,
80                                                          short_opts        => {},
81                                                          defaults          => {},
82                                                          groups            => {},
83                                                          allowed_groups    => {},
84                                                          errors            => [],
85                                                          rules             => [],  # desc of rules for --help
86                                                          mutex             => [],  # rule: opts are mutually exclusive
87                                                          atleast1          => [],  # rule: at least one opt is required
88                                                          disables          => {},  # rule: opt disables other opts 
89                                                          defaults_to       => {},  # rule: opt defaults to value of other opt
90                                                          DSNParser         => undef,
91                                                          default_files     => [
92                                                             "/etc/maatkit/maatkit.conf",
93                                                             "/etc/maatkit/$program_name.conf",
94                                                             "$home/.maatkit.conf",
95                                                             "$home/.$program_name.conf",
96                                                          ],
97                                                          types             => {
98                                                             string => 's', # standard Getopt type
99                                                             int    => 'i', # standard Getopt type
100                                                            float  => 'f', # standard Getopt type
101                                                            Hash   => 'H', # hash, formed from a comma-separated list
102                                                            hash   => 'h', # hash as above, but only if a value is given
103                                                            Array  => 'A', # array, similar to Hash
104                                                            array  => 'a', # array, similar to hash
105                                                            DSN    => 'd', # DSN
106                                                            size   => 'z', # size with kMG suffix (powers of 2^10)
107                                                            time   => 'm', # time, with an optional suffix of s/h/m/d
108                                                         },
109                                                      };
110                                                   
111           16                                166      return bless $self, $class;
112                                                   }
113                                                   
114                                                   sub get_specs {
115            8                    8            42      my ( $self, $file ) = @_;
116   ***      8            50                  153      $file ||= $self->{file} || __FILE__;
                           100                        
117            8                                 65      my @specs = $self->_pod_to_specs($file);
118            8                                186      $self->_parse_specs(@specs);
119                                                   
120   ***      8     50                         269      open my $fh, "<", $file or die "Cannot open $file: $OS_ERROR";
121            8                                 25      my $contents = do { local $/ = undef; <$fh> };
               8                                 50   
               8                               2318   
122            8                                 64      close $fh;
123   ***      8     50                         519      if ( $contents =~ m/^=head1 DSN OPTIONS/m ) {
124            8                                 21         MKDEBUG && _d('Parsing DSN OPTIONS');
125            8                                779         my $dsn_attribs = {
126                                                            dsn  => 1,
127                                                            copy => 1,
128                                                         };
129                                                         my $parse_dsn_attribs = sub {
130           72                   72           307            my ( $self, $option, $attribs ) = @_;
131          144                                447            map {
132           72                                321               my $val = $attribs->{$_};
133   ***    144     50                         640               if ( $val ) {
134          144    100                         618                  $val    = $val eq 'yes' ? 1
                    100                               
135                                                                          : $val eq 'no'  ? 0
136                                                                          :                 $val;
137          144                                877                  $attribs->{$_} = $val;
138                                                               }
139                                                            } keys %$attribs;
140                                                            return {
141           72                                842               key => $option,
142                                                               %$attribs,
143                                                            };
144            8                                100         };
145            8                                 85         my $dsn_o = new OptionParser(
146                                                            description       => 'DSN OPTIONS',
147                                                            head1             => 'DSN OPTIONS',
148                                                            dsn               => 0,         # XXX don't infinitely recurse!
149                                                            item              => '\* (.)',  # key opts are a single character
150                                                            skip_rules        => 1,         # no rules before opts
151                                                            attributes        => $dsn_attribs,
152                                                            parse_attributes  => $parse_dsn_attribs,
153                                                         );
154           72                                684         my @dsn_opts = map {
155            8                                 57            my $opts = {
156                                                               key  => $_->{spec}->{key},
157                                                               dsn  => $_->{spec}->{dsn},
158                                                               copy => $_->{spec}->{copy},
159                                                               desc => $_->{desc},
160                                                            };
161           72                                237            $opts;
162                                                         } $dsn_o->_pod_to_specs($file);
163            8                                223         $self->{DSNParser} = DSNParser->new(opts => \@dsn_opts);
164                                                      }
165                                                   
166            8                                 20      return;
167                                                   }
168                                                   
169                                                   sub DSNParser {
170            7                    7            27      my ( $self ) = @_;
171            7                                 30      return $self->{DSNParser};
172                                                   };
173                                                   
174                                                   sub get_defaults_files {
175            8                    8            31      my ( $self ) = @_;
176            8                                 31      return @{$self->{default_files}};
               8                                 72   
177                                                   }
178                                                   
179                                                   sub _pod_to_specs {
180           16                   16            74      my ( $self, $file ) = @_;
181   ***     16             0                   72      $file ||= $self->{file} || __FILE__;
      ***                   50                        
182   ***     16     50                         607      open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";
183                                                   
184           16                                 74      my @specs = ();
185           16                                 57      my @rules = ();
186           16                                 43      my $para;
187                                                   
188           16                                131      local $INPUT_RECORD_SEPARATOR = '';
189           16                                360      while ( $para = <$fh> ) {
190        11176    100                       86869         next unless $para =~ m/^=head1 $self->{head1}/;
191           16                                 61         last;
192                                                      }
193                                                   
194           16                                118      while ( $para = <$fh> ) {
195           32    100                         158         last if $para =~ m/^=over/;
196           16    100                         105         next if $self->{skip_rules};
197            8                                 34         chomp $para;
198            8                                100         $para =~ s/\s+/ /g;
199            8                                214         $para =~ s/$POD_link_re/$1/go;
200            8                                 23         MKDEBUG && _d('Option rule:', $para);
201            8                                 63         push @rules, $para;
202                                                      }
203                                                   
204   ***     16     50                          68      die "POD has no $self->{head1} section" unless $para;
205                                                   
206           16                                 52      do {
207          360    100                        3023         if ( my ($option) = $para =~ m/^=item $self->{item}/ ) {
208          328                                899            chomp $para;
209          328                                706            MKDEBUG && _d($para);
210          328                                776            my %attribs;
211                                                   
212          328                               1155            $para = <$fh>; # read next paragraph, possibly attributes
213                                                   
214          328    100                        1274            if ( $para =~ m/: / ) { # attributes
215          264                               1229               $para =~ s/\s+\Z//g;
216          432                               1967               %attribs = map {
217          264                               1197                     my ( $attrib, $val) = split(/: /, $_);
218   ***    432     50                        2084                     die "Unrecognized attribute for --$option: $attrib"
219                                                                        unless $self->{attributes}->{$attrib};
220          432                               2168                     ($attrib, $val);
221                                                                  } split(/; /, $para);
222          264    100                        1193               if ( $attribs{'short form'} ) {
223           72                                341                  $attribs{'short form'} =~ s/-//;
224                                                               }
225          264                               1288               $para = <$fh>; # read next paragraph, probably short help desc
226                                                            }
227                                                            else {
228           64                                164               MKDEBUG && _d('Option has no attributes');
229                                                            }
230                                                   
231          328                               2664            $para =~ s/\s+\Z//g;
232          328                               3021            $para =~ s/\s+/ /g;
233          328                               1810            $para =~ s/$POD_link_re/$1/go;
234                                                   
235          328                               1352            $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
236          328                                747            MKDEBUG && _d('Short help:', $para);
237                                                   
238   ***    328     50                        1274            die "No description after option spec $option" if $para =~ m/^=item/;
239                                                   
240          328    100                        1495            if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
241           32                                 91               $option = $base_option;
242           32                                115               $attribs{'negatable'} = 1;
243                                                            }
244                                                   
245          328    100                        1754            push @specs, {
      ***            50                               
246                                                               spec  => $self->{parse_attributes}->($self, $option, \%attribs), 
247                                                               desc  => $para
248                                                                  . (defined $attribs{default} ? " (default $attribs{default})" : ''),
249                                                               group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
250                                                            };
251                                                         }
252          360                               2393         while ( $para = <$fh> ) {
253   ***    480     50                        1632            last unless $para;
254          480    100                        1808            if ( $para =~ m/^=head1/ ) {
255           16                                 54               $para = undef; # Can't 'last' out of a do {} block.
256           16                                 83               last;
257                                                            }
258          464    100                        2857            last if $para =~ m/^=item /;
259                                                         }
260                                                      } while ( $para );
261                                                   
262   ***     16     50                          64      die "No valid specs in $self->{head1}" unless @specs;
263                                                   
264           16                                179      close $fh;
265           16                                 53      return @specs, @rules;
266                                                   }
267                                                   
268                                                   sub _parse_specs {
269            8                    8            70      my ( $self, @specs ) = @_;
270            8                                 37      my %disables; # special rule that requires deferred checking
271                                                   
272            8                                 41      foreach my $opt ( @specs ) {
273          264    100                         916         if ( ref $opt ) { # It's an option spec, not a rule.
274                                                            MKDEBUG && _d('Parsing opt spec:',
275          256                                543               map { ($_, '=>', $opt->{$_}) } keys %$opt);
276                                                   
277          256                               1684            my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
278   ***    256     50                        1008            if ( !$long ) {
279   ***      0                                  0               die "Cannot parse long option from spec $opt->{spec}";
280                                                            }
281          256                                879            $opt->{long} = $long;
282                                                   
283   ***    256     50                        1201            die "Duplicate long option --$long" if exists $self->{opts}->{$long};
284          256                               1142            $self->{opts}->{$long} = $opt;
285                                                   
286   ***    256     50                         959            if ( length $long == 1 ) {
287   ***      0                                  0               MKDEBUG && _d('Long opt', $long, 'looks like short opt');
288   ***      0                                  0               $self->{short_opts}->{$long} = $long;
289                                                            }
290                                                   
291          256    100                         824            if ( $short ) {
292   ***     72     50                         333               die "Duplicate short option -$short"
293                                                                  if exists $self->{short_opts}->{$short};
294           72                                384               $self->{short_opts}->{$short} = $long;
295           72                                252               $opt->{short} = $short;
296                                                            }
297                                                            else {
298          184                                624               $opt->{short} = undef;
299                                                            }
300                                                   
301          256    100                        1264            $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
302   ***    256     50                        1190            $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
303   ***    256     50                        1304            $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;
304                                                   
305   ***    256            50                 1010            $opt->{group} ||= 'default';
306          256                               1595            $self->{groups}->{ $opt->{group} }->{$long} = 1;
307                                                   
308          256                                836            $opt->{value} = undef;
309          256                                809            $opt->{got}   = 0;
310                                                   
311          256                               1234            my ( $type ) = $opt->{spec} =~ m/=(.)/;
312          256                                882            $opt->{type} = $type;
313          256                                539            MKDEBUG && _d($long, 'type:', $type);
314                                                   
315                                                   
316          256    100    100                 1752            $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );
317                                                   
318          256    100                        1462            if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
319   ***     64     50                         335               $self->{defaults}->{$long} = defined $def ? $def : 1;
320           64                                151               MKDEBUG && _d($long, 'default:', $def);
321                                                            }
322                                                   
323          256    100                         949            if ( $long eq 'config' ) {
324            8                                 52               $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
325                                                            }
326                                                   
327   ***    256     50                        1234            if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
328   ***      0                                  0               $disables{$long} = $dis;
329   ***      0                                  0               MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
330                                                            }
331                                                   
332          256                               1151            $self->{opts}->{$long} = $opt;
333                                                         }
334                                                         else { # It's an option rule, not a spec.
335            8                                 28            MKDEBUG && _d('Parsing rule:', $opt); 
336            8                                 26            push @{$self->{rules}}, $opt;
               8                                 46   
337            8                                 56            my @participants = $self->_get_participants($opt);
338            8                                 28            my $rule_ok = 0;
339                                                   
340   ***      8     50                          82            if ( $opt =~ m/mutually exclusive|one and only one/ ) {
341   ***      0                                  0               $rule_ok = 1;
342   ***      0                                  0               push @{$self->{mutex}}, \@participants;
      ***      0                                  0   
343   ***      0                                  0               MKDEBUG && _d(@participants, 'are mutually exclusive');
344                                                            }
345   ***      8     50                          76            if ( $opt =~ m/at least one|one and only one/ ) {
346   ***      0                                  0               $rule_ok = 1;
347   ***      0                                  0               push @{$self->{atleast1}}, \@participants;
      ***      0                                  0   
348   ***      0                                  0               MKDEBUG && _d(@participants, 'require at least one');
349                                                            }
350   ***      8     50                          48            if ( $opt =~ m/default to/ ) {
351   ***      0                                  0               $rule_ok = 1;
352   ***      0                                  0               $self->{defaults_to}->{$participants[0]} = $participants[1];
353   ***      0                                  0               MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
354                                                            }
355   ***      8     50                          63            if ( $opt =~ m/restricted to option groups/ ) {
356   ***      0                                  0               $rule_ok = 1;
357   ***      0                                  0               my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
358   ***      0                                  0               my @groups = split(',', $groups);
359   ***      0                                  0               %{$self->{allowed_groups}->{$participants[0]}} = map {
      ***      0                                  0   
360   ***      0                                  0                  s/\s+//;
361   ***      0                                  0                  $_ => 1;
362                                                               } @groups;
363                                                            }
364   ***      8     50                         131            if( $opt =~ m/accepts additional command-line arguments/ ) {
365            8                                 25               $rule_ok = 1;
366            8                                 33               $self->{strict} = 0;
367            8                                 28               MKDEBUG && _d("Strict mode disabled by rule");
368                                                            }
369                                                   
370   ***      8     50                          50            die "Unrecognized option rule: $opt" unless $rule_ok;
371                                                         }
372                                                      }
373                                                   
374            8                                 52      foreach my $long ( keys %disables ) {
375   ***      0                                  0         my @participants = $self->_get_participants($disables{$long});
376   ***      0                                  0         $self->{disables}->{$long} = \@participants;
377   ***      0                                  0         MKDEBUG && _d('Option', $long, 'disables', @participants);
378                                                      }
379                                                   
380            8                                 48      return; 
381                                                   }
382                                                   
383                                                   sub _get_participants {
384            8                    8            41      my ( $self, $str ) = @_;
385            8                                 30      my @participants;
386            8                                 57      foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
387   ***      0      0                           0         die "Option --$long does not exist while processing rule $str"
388                                                            unless exists $self->{opts}->{$long};
389   ***      0                                  0         push @participants, $long;
390                                                      }
391            8                                 18      MKDEBUG && _d('Participants for', $str, ':', @participants);
392            8                                 37      return @participants;
393                                                   }
394                                                   
395                                                   sub opts {
396   ***      0                    0             0      my ( $self ) = @_;
397   ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
398   ***      0                                  0      return %opts;
399                                                   }
400                                                   
401                                                   sub short_opts {
402   ***      0                    0             0      my ( $self ) = @_;
403   ***      0                                  0      my %short_opts = %{$self->{short_opts}};
      ***      0                                  0   
404   ***      0                                  0      return %short_opts;
405                                                   }
406                                                   
407                                                   sub set_defaults {
408   ***      0                    0             0      my ( $self, %defaults ) = @_;
409   ***      0                                  0      $self->{defaults} = {};
410   ***      0                                  0      foreach my $long ( keys %defaults ) {
411   ***      0      0                           0         die "Cannot set default for nonexistent option $long"
412                                                            unless exists $self->{opts}->{$long};
413   ***      0                                  0         $self->{defaults}->{$long} = $defaults{$long};
414   ***      0                                  0         MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
415                                                      }
416   ***      0                                  0      return;
417                                                   }
418                                                   
419                                                   sub get_defaults {
420   ***      0                    0             0      my ( $self ) = @_;
421   ***      0                                  0      return $self->{defaults};
422                                                   }
423                                                   
424                                                   sub get_groups {
425   ***      0                    0             0      my ( $self ) = @_;
426   ***      0                                  0      return $self->{groups};
427                                                   }
428                                                   
429                                                   sub _set_option {
430           22                   22            96      my ( $self, $opt, $val ) = @_;
431   ***     22      0                          52      my $long = exists $self->{opts}->{$opt}       ? $opt
      ***            50                               
432                                                               : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
433                                                               : die "Getopt::Long gave a nonexistent option: $opt";
434                                                   
435           22                                 43      $opt = $self->{opts}->{$long};
436   ***     22     50                         138      if ( $opt->{is_cumulative} ) {
437   ***      0                                  0         $opt->{value}++;
438                                                      }
439                                                      else {
440           22                                 80         $opt->{value} = $val;
441                                                      }
442           22                                 81      $opt->{got} = 1;
443           22                                 82      MKDEBUG && _d('Got option', $long, '=', $val);
444                                                   }
445                                                   
446                                                   sub get_opts {
447            9                    9          1025      my ( $self ) = @_; 
448                                                   
449            9                                 29      foreach my $long ( keys %{$self->{opts}} ) {
               9                                176   
450          288                               1162         $self->{opts}->{$long}->{got} = 0;
451   ***    288     50                        2194         $self->{opts}->{$long}->{value}
                    100                               
452                                                            = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
453                                                            : $self->{opts}->{$long}->{is_cumulative} ? 0
454                                                            : undef;
455                                                      }
456            9                                156      $self->{got_opts} = 0;
457                                                   
458            9                                 42      $self->{errors} = [];
459                                                   
460   ***      9     50     66                  117      if ( @ARGV && $ARGV[0] eq "--config" ) {
461   ***      0                                  0         shift @ARGV;
462   ***      0                                  0         $self->_set_option('config', shift @ARGV);
463                                                      }
464   ***      9     50                          77      if ( $self->has('config') ) {
465            9                                 29         my @extra_args;
466            9                                 75         foreach my $filename ( split(',', $self->get('config')) ) {
467           36                                 96            eval {
468           36                                169               push @extra_args, $self->_read_config_file($filename);
469                                                            };
470   ***     36     50                         189            if ( $EVAL_ERROR ) {
471   ***     36     50                         152               if ( $self->got('config') ) {
472   ***      0                                  0                  die $EVAL_ERROR;
473                                                               }
474                                                               elsif ( MKDEBUG ) {
475                                                                  _d($EVAL_ERROR);
476                                                               }
477                                                            }
478                                                         }
479            9                                 50         unshift @ARGV, @extra_args;
480                                                      }
481                                                   
482            9                                100      Getopt::Long::Configure('no_ignore_case', 'bundling');
483                                                      GetOptions(
484          279                   22          1861         map    { $_->{spec} => sub { $self->_set_option(@_); } }
              22                                122   
             288                               1074   
485            9                                 65         grep   { $_->{long} ne 'config' } # --config is handled specially above.
486   ***      9     50                          36         values %{$self->{opts}}
487                                                      ) or $self->save_error('Error parsing options');
488                                                   
489   ***      9     50     33                  469      if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
490   ***      0      0                           0         printf("%s  Ver %s Distrib %s Changeset %s\n",
491                                                            $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
492                                                               or die "Cannot print: $OS_ERROR";
493   ***      0                                  0         exit 0;
494                                                      }
495                                                   
496   ***      9     50     66                   92      if ( @ARGV && $self->{strict} ) {
497   ***      0                                  0         $self->save_error("Unrecognized command-line options @ARGV");
498                                                      }
499                                                   
500            9                                 27      foreach my $mutex ( @{$self->{mutex}} ) {
               9                                 54   
501   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      ***      0                                  0   
502   ***      0      0                           0         if ( @set > 1 ) {
503   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
504   ***      0                                  0                         @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
505                                                                    . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
506                                                                    . ' are mutually exclusive.';
507   ***      0                                  0            $self->save_error($err);
508                                                         }
509                                                      }
510                                                   
511            9                                 28      foreach my $required ( @{$self->{atleast1}} ) {
               9                                 47   
512   ***      0                                  0         my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      ***      0                                  0   
513   ***      0      0                           0         if ( @set == 0 ) {
514   ***      0                                  0            my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
      ***      0                                  0   
515   ***      0                                  0                         @{$required}[ 0 .. scalar(@$required) - 2] )
516                                                                    .' or --'.$self->{opts}->{$required->[-1]}->{long};
517   ***      0                                  0            $self->save_error("Specify at least one of $err");
518                                                         }
519                                                      }
520                                                   
521            9                                 31      $self->_check_opts( keys %{$self->{opts}} );
               9                                122   
522            9                                 51      $self->{got_opts} = 1;
523            9                                 29      return;
524                                                   }
525                                                   
526                                                   sub _check_opts {
527            9                    9           119      my ( $self, @long ) = @_;
528            9                                 44      my $long_last = scalar @long;
529            9                                 43      while ( @long ) {
530            9                                 74         foreach my $i ( 0..$#long ) {
531          288                                876            my $long = $long[$i];
532   ***    288     50                         942            next unless $long;
533          288                               1045            my $opt  = $self->{opts}->{$long};
534          288    100                        1459            if ( $opt->{got} ) {
      ***            50                               
535   ***     22     50                         109               if ( exists $self->{disables}->{$long} ) {
536   ***      0                                  0                  my @disable_opts = @{$self->{disables}->{$long}};
      ***      0                                  0   
537   ***      0                                  0                  map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
      ***      0                                  0   
538   ***      0                                  0                  MKDEBUG && _d('Unset options', @disable_opts,
539                                                                     'because', $long,'disables them');
540                                                               }
541                                                   
542   ***     22     50                         113               if ( exists $self->{allowed_groups}->{$long} ) {
543                                                   
544   ***      0                                  0                  my @restricted_groups = grep {
545   ***      0                                  0                     !exists $self->{allowed_groups}->{$long}->{$_}
546   ***      0                                  0                  } keys %{$self->{groups}};
547                                                   
548   ***      0                                  0                  my @restricted_opts;
549   ***      0                                  0                  foreach my $restricted_group ( @restricted_groups ) {
550   ***      0                                  0                     RESTRICTED_OPT:
551   ***      0                                  0                     foreach my $restricted_opt (
552                                                                        keys %{$self->{groups}->{$restricted_group}} )
553                                                                     {
554   ***      0      0                           0                        next RESTRICTED_OPT if $restricted_opt eq $long;
555   ***      0      0                           0                        push @restricted_opts, $restricted_opt
556                                                                           if $self->{opts}->{$restricted_opt}->{got};
557                                                                     }
558                                                                  }
559                                                   
560   ***      0      0                           0                  if ( @restricted_opts ) {
561   ***      0                                  0                     my $err;
562   ***      0      0                           0                     if ( @restricted_opts == 1 ) {
563   ***      0                                  0                        $err = "--$restricted_opts[0]";
564                                                                     }
565                                                                     else {
566   ***      0                                  0                        $err = join(', ',
567   ***      0                                  0                                  map { "--$self->{opts}->{$_}->{long}" }
568   ***      0                                  0                                  grep { $_ } 
569                                                                                  @restricted_opts[0..scalar(@restricted_opts) - 2]
570                                                                               )
571                                                                             . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
572                                                                     }
573   ***      0                                  0                     $self->save_error("--$long is not allowed with $err");
574                                                                  }
575                                                               }
576                                                   
577                                                            }
578                                                            elsif ( $opt->{is_required} ) { 
579   ***      0                                  0               $self->save_error("Required option --$long must be specified");
580                                                            }
581                                                   
582          288                                996            $self->_validate_type($opt);
583   ***    288     50                        1035            if ( $opt->{parsed} ) {
584          288                               1002               delete $long[$i];
585                                                            }
586                                                            else {
587   ***      0                                  0               MKDEBUG && _d('Temporarily failed to parse', $long);
588                                                            }
589                                                         }
590                                                   
591   ***      9     50                          44         die "Failed to parse options, possibly due to circular dependencies"
592                                                            if @long == $long_last;
593            9                                 42         $long_last = @long;
594                                                      }
595                                                   
596            9                                 33      return;
597                                                   }
598                                                   
599                                                   sub _validate_type {
600          288                  288           987      my ( $self, $opt ) = @_;
601   ***    288     50                        1003      return unless $opt;
602                                                   
603          288    100                        1192      if ( !$opt->{type} ) {
604          117                                366         $opt->{parsed} = 1;
605          117                                348         return;
606                                                      }
607                                                   
608          171                                535      my $val = $opt->{value};
609                                                   
610   ***    171     50     66                 4137      if ( $val && $opt->{type} eq 'm' ) {  # type time
      ***            50     66                        
      ***            50     66                        
      ***            50     66                        
      ***           100     33                        
                           100                        
                           100                        
611   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
612   ***      0                                  0         my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
613   ***      0      0                           0         if ( !$suffix ) {
614   ***      0                                  0            my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
615   ***      0             0                    0            $suffix = $s || 's';
616   ***      0                                  0            MKDEBUG && _d('No suffix given; using', $suffix, 'for',
617                                                               $opt->{long}, '(value:', $val, ')');
618                                                         }
619   ***      0      0                           0         if ( $suffix =~ m/[smhd]/ ) {
620   ***      0      0                           0            $val = $suffix eq 's' ? $num            # Seconds
      ***             0                               
      ***             0                               
621                                                                 : $suffix eq 'm' ? $num * 60       # Minutes
622                                                                 : $suffix eq 'h' ? $num * 3600     # Hours
623                                                                 :                  $num * 86400;   # Days
624   ***      0             0                    0            $opt->{value} = ($prefix || '') . $val;
625   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
626                                                         }
627                                                         else {
628   ***      0                                  0            $self->save_error("Invalid time suffix for --$opt->{long}");
629                                                         }
630                                                      }
631                                                      elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
632   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
633   ***      0                                  0         my $prev = {};
634   ***      0                                  0         my $from_key = $self->{defaults_to}->{ $opt->{long} };
635   ***      0      0                           0         if ( $from_key ) {
636   ***      0                                  0            MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
637   ***      0      0                           0            if ( $self->{opts}->{$from_key}->{parsed} ) {
638   ***      0                                  0               $prev = $self->{opts}->{$from_key}->{value};
639                                                            }
640                                                            else {
641   ***      0                                  0               MKDEBUG && _d('Cannot parse', $opt->{long}, 'until',
642                                                                  $from_key, 'parsed');
643   ***      0                                  0               return;
644                                                            }
645                                                         }
646   ***      0                                  0         my $defaults = $self->{DSNParser}->parse_options($self);
647   ***      0                                  0         $opt->{value} = $self->{DSNParser}->parse($val, $prev, $defaults);
648                                                      }
649                                                      elsif ( $val && $opt->{type} eq 'z' ) {  # type size
650   ***      0                                  0         MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
651   ***      0                                  0         $self->_parse_size($opt, $val);
652                                                      }
653                                                      elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
654   ***      0             0                    0         $opt->{value} = { map { $_ => 1 } split(/(?<!\\),\s*/, ($val || '')) };
      ***      0                                  0   
655                                                      }
656                                                      elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
657   ***     18            50                  209         $opt->{value} = [ split(/(?<!\\),\s*/, ($val || '')) ];
658                                                      }
659                                                      else {
660          153                                362         MKDEBUG && _d('Nothing to validate for option',
661                                                            $opt->{long}, 'type', $opt->{type}, 'value', $val);
662                                                      }
663                                                   
664          171                                556      $opt->{parsed} = 1;
665          171                                480      return;
666                                                   }
667                                                   
668                                                   sub get {
669          253                  253          1081      my ( $self, $opt ) = @_;
670          253    100                        1196      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
671   ***    253     50     33                 2367      die "Option $opt does not exist"
672                                                         unless $long && exists $self->{opts}->{$long};
673          253                             985541      return $self->{opts}->{$long}->{value};
674                                                   }
675                                                   
676                                                   sub got {
677           36                   36           153      my ( $self, $opt ) = @_;
678   ***     36     50                         161      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
679   ***     36     50     33                  415      die "Option $opt does not exist"
680                                                         unless $long && exists $self->{opts}->{$long};
681           36                                219      return $self->{opts}->{$long}->{got};
682                                                   }
683                                                   
684                                                   sub has {
685           72                   72           298      my ( $self, $opt ) = @_;
686           72    100                         504      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
687           72    100                         579      return defined $long ? exists $self->{opts}->{$long} : 0;
688                                                   }
689                                                   
690                                                   sub set {
691            2                    2            15      my ( $self, $opt, $val ) = @_;
692   ***      2     50                          16      my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
693   ***      2     50     33                   27      die "Option $opt does not exist"
694                                                         unless $long && exists $self->{opts}->{$long};
695            2                                 12      $self->{opts}->{$long}->{value} = $val;
696            2                                  8      return;
697                                                   }
698                                                   
699                                                   sub save_error {
700   ***      0                    0             0      my ( $self, $error ) = @_;
701   ***      0                                  0      push @{$self->{errors}}, $error;
      ***      0                                  0   
702   ***      0                                  0      return;
703                                                   }
704                                                   
705                                                   sub errors {
706   ***      0                    0             0      my ( $self ) = @_;
707   ***      0                                  0      return $self->{errors};
708                                                   }
709                                                   
710                                                   sub usage {
711   ***      0                    0             0      my ( $self ) = @_;
712   ***      0      0                           0      warn "No usage string is set" unless $self->{usage}; # XXX
713   ***      0             0                    0      return "Usage: " . ($self->{usage} || '') . "\n";
714                                                   }
715                                                   
716                                                   sub descr {
717   ***      0                    0             0      my ( $self ) = @_;
718   ***      0      0                           0      warn "No description string is set" unless $self->{description}; # XXX
719   ***      0             0                    0      my $descr  = ($self->{description} || $self->{program_name} || '')
      ***                    0                        
720                                                                 . "  For more details, please use the --help option, "
721                                                                 . "or try 'perldoc $PROGRAM_NAME' "
722                                                                 . "for complete documentation.";
723   ***      0      0                           0      $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g)
724                                                         unless $ENV{DONT_BREAK_LINES};
725   ***      0                                  0      $descr =~ s/ +$//mg;
726   ***      0                                  0      return $descr;
727                                                   }
728                                                   
729                                                   sub usage_or_errors {
730            7                    7            31      my ( $self, $file, $return ) = @_;
731   ***      7            50                   84      $file ||= $self->{file} || __FILE__;
      ***                   33                        
732                                                   
733   ***      7     50     33                   89      if ( !$self->{description} || !$self->{usage} ) {
734            7                                 15         MKDEBUG && _d("Getting description and usage from SYNOPSIS in", $file);
735            7                                 40         my %synop = $self->_parse_synopsis($file);
736   ***      7            33                  139         $self->{description} ||= $synop{description};
737   ***      7            33                   41         $self->{usage}       ||= $synop{usage};
738            7                                 25         MKDEBUG && _d("Description:", $self->{description},
739                                                            "\nUsage:", $self->{usage});
740                                                      }
741                                                   
742   ***      7     50                          49      if ( $self->{opts}->{help}->{got} ) {
      ***      7     50                          37   
743   ***      0      0                           0         print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
744   ***      0      0                           0         exit 0 unless $return;
745                                                      }
746                                                      elsif ( scalar @{$self->{errors}} ) {
747   ***      0      0                           0         print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
748   ***      0      0                           0         exit 0 unless $return;
749                                                      }
750                                                   
751            7                                 28      return;
752                                                   }
753                                                   
754                                                   sub print_errors {
755   ***      0                    0             0      my ( $self ) = @_;
756   ***      0                                  0      my $usage = $self->usage() . "\n";
757   ***      0      0                           0      if ( (my @errors = @{$self->{errors}}) ) {
      ***      0                                  0   
758   ***      0                                  0         $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
759                                                                 . "\n";
760                                                      }
761   ***      0                                  0      return $usage . "\n" . $self->descr();
762                                                   }
763                                                   
764                                                   sub print_usage {
765   ***      0                    0             0      my ( $self ) = @_;
766   ***      0      0                           0      die "Run get_opts() before print_usage()" unless $self->{got_opts};
767   ***      0                                  0      my @opts = values %{$self->{opts}};
      ***      0                                  0   
768                                                   
769   ***      0      0                           0      my $maxl = max(
      ***             0                               
770                                                         map {
771   ***      0                                  0            length($_->{long})               # option long name
772                                                            + ($_->{is_negatable} ? 4 : 0)   # "[no]" if opt is negatable
773                                                            + ($_->{type} ? 2 : 0)           # "=x" where x is the opt type
774                                                         }
775                                                         @opts);
776                                                   
777   ***      0      0                           0      my $maxs = max(0,
      ***             0                               
778                                                         map {
779   ***      0                                  0            length($_)
780                                                            + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0)
781                                                            + ($self->{opts}->{$_}->{type} ? 2 : 0)
782                                                         }
783   ***      0                                  0         values %{$self->{short_opts}});
784                                                   
785   ***      0                                  0      my $lcol = max($maxl, ($maxs + 3));
786   ***      0                                  0      my $rcol = 80 - $lcol - 6;
787   ***      0                                  0      my $rpad = ' ' x ( 80 - $rcol );
788                                                   
789   ***      0                                  0      $maxs = max($lcol - 3, $maxs);
790                                                   
791   ***      0                                  0      my $usage = $self->descr() . "\n" . $self->usage();
792                                                   
793   ***      0                                  0      my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
      ***      0                                  0   
      ***      0                                  0   
794   ***      0                                  0      push @groups, 'default';
795                                                   
796   ***      0                                  0      foreach my $group ( reverse @groups ) {
797   ***      0      0                           0         $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
798   ***      0                                  0         foreach my $opt (
      ***      0                                  0   
799   ***      0                                  0            sort { $a->{long} cmp $b->{long} }
800                                                            grep { $_->{group} eq $group }
801                                                            @opts )
802                                                         {
803   ***      0      0                           0            my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
804   ***      0                                  0            my $short = $opt->{short};
805   ***      0                                  0            my $desc  = $opt->{desc};
806                                                   
807   ***      0      0                           0            $long .= $opt->{type} ? "=$opt->{type}" : "";
808                                                   
809   ***      0      0      0                    0            if ( $opt->{type} && $opt->{type} eq 'm' ) {
810   ***      0                                  0               my ($s) = $desc =~ m/\(suffix (.)\)/;
811   ***      0             0                    0               $s    ||= 's';
812   ***      0                                  0               $desc =~ s/\s+\(suffix .\)//;
813   ***      0                                  0               $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
814                                                                      . "d=days; if no suffix, $s is used.";
815                                                            }
816   ***      0                                  0            $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
      ***      0                                  0   
817   ***      0                                  0            $desc =~ s/ +$//mg;
818   ***      0      0                           0            if ( $short ) {
819   ***      0                                  0               $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
820                                                            }
821                                                            else {
822   ***      0                                  0               $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
823                                                            }
824                                                         }
825                                                      }
826                                                   
827   ***      0                                  0      $usage .= "\nOption types: s=string, i=integer, f=float, h/H/a/A=comma-separated list, d=DSN, z=size, m=time\n";
828                                                   
829   ***      0      0                           0      if ( (my @rules = @{$self->{rules}}) ) {
      ***      0                                  0   
830   ***      0                                  0         $usage .= "\nRules:\n\n";
831   ***      0                                  0         $usage .= join("\n", map { "  $_" } @rules) . "\n";
      ***      0                                  0   
832                                                      }
833   ***      0      0                           0      if ( $self->{DSNParser} ) {
834   ***      0                                  0         $usage .= "\n" . $self->{DSNParser}->usage();
835                                                      }
836   ***      0                                  0      $usage .= "\nOptions and values after processing arguments:\n\n";
837   ***      0                                  0      foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      ***      0                                  0   
838   ***      0                                  0         my $val   = $opt->{value};
839   ***      0             0                    0         my $type  = $opt->{type} || '';
840   ***      0                                  0         my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
841   ***      0      0                           0         $val      = $bool              ? ( $val ? 'TRUE' : 'FALSE' )
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
      ***             0                               
842                                                                   : !defined $val      ? '(No value)'
843                                                                   : $type eq 'd'       ? $self->{DSNParser}->as_string($val)
844                                                                   : $type =~ m/H|h/    ? join(',', sort keys %$val)
845                                                                   : $type =~ m/A|a/    ? join(',', @$val)
846                                                                   :                    $val;
847   ***      0                                  0         $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
848                                                      }
849   ***      0                                  0      return $usage;
850                                                   }
851                                                   
852                                                   sub prompt_noecho {
853   ***      0      0             0             0      shift @_ if ref $_[0] eq __PACKAGE__;
854   ***      0                                  0      my ( $prompt ) = @_;
855   ***      0                                  0      local $OUTPUT_AUTOFLUSH = 1;
856   ***      0      0                           0      print $prompt
857                                                         or die "Cannot print: $OS_ERROR";
858   ***      0                                  0      my $response;
859   ***      0                                  0      eval {
860   ***      0                                  0         require Term::ReadKey;
861   ***      0                                  0         Term::ReadKey::ReadMode('noecho');
862   ***      0                                  0         chomp($response = <STDIN>);
863   ***      0                                  0         Term::ReadKey::ReadMode('normal');
864   ***      0      0                           0         print "\n"
865                                                            or die "Cannot print: $OS_ERROR";
866                                                      };
867   ***      0      0                           0      if ( $EVAL_ERROR ) {
868   ***      0                                  0         die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
869                                                      }
870   ***      0                                  0      return $response;
871                                                   }
872                                                   
873                                                   if ( MKDEBUG ) {
874                                                      print '# ', $^X, ' ', $], "\n";
875                                                      my $uname = `uname -a`;
876                                                      if ( $uname ) {
877                                                         $uname =~ s/\s+/ /g;
878                                                         print "# $uname\n";
879                                                      }
880                                                      printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
881                                                         $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
882                                                         ($main::SVN_REV || ''), __LINE__);
883                                                      print('# Arguments: ',
884                                                         join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
885                                                   }
886                                                   
887                                                   sub _read_config_file {
888           36                   36           162      my ( $self, $filename ) = @_;
889   ***     36     50                          81      open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
890   ***      0                                  0      my @args;
891   ***      0                                  0      my $prefix = '--';
892   ***      0                                  0      my $parse  = 1;
893                                                   
894                                                      LINE:
895   ***      0                                  0      while ( my $line = <$fh> ) {
896   ***      0                                  0         chomp $line;
897   ***      0      0                           0         next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
898   ***      0                                  0         $line =~ s/\s+#.*$//g;
899   ***      0                                  0         $line =~ s/^\s+|\s+$//g;
900   ***      0      0                           0         if ( $line eq '--' ) {
901   ***      0                                  0            $prefix = '';
902   ***      0                                  0            $parse  = 0;
903   ***      0                                  0            next LINE;
904                                                         }
905   ***      0      0      0                    0         if ( $parse
      ***             0                               
906                                                            && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
907                                                         ) {
908   ***      0                                  0            push @args, grep { defined $_ } ("$prefix$opt", $arg);
      ***      0                                  0   
909                                                         }
910                                                         elsif ( $line =~ m/./ ) {
911   ***      0                                  0            push @args, $line;
912                                                         }
913                                                         else {
914   ***      0                                  0            die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
915                                                         }
916                                                      }
917   ***      0                                  0      close $fh;
918   ***      0                                  0      return @args;
919                                                   }
920                                                   
921                                                   sub read_para_after {
922   ***      0                    0             0      my ( $self, $file, $regex ) = @_;
923   ***      0      0                           0      open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
924   ***      0                                  0      local $INPUT_RECORD_SEPARATOR = '';
925   ***      0                                  0      my $para;
926   ***      0                                  0      while ( $para = <$fh> ) {
927   ***      0      0                           0         next unless $para =~ m/^=pod$/m;
928   ***      0                                  0         last;
929                                                      }
930   ***      0                                  0      while ( $para = <$fh> ) {
931   ***      0      0                           0         next unless $para =~ m/$regex/;
932   ***      0                                  0         last;
933                                                      }
934   ***      0                                  0      $para = <$fh>;
935   ***      0                                  0      chomp($para);
936   ***      0      0                           0      close $fh or die "Can't close $file: $OS_ERROR";
937   ***      0                                  0      return $para;
938                                                   }
939                                                   
940                                                   sub clone {
941   ***      0                    0             0      my ( $self ) = @_;
942                                                   
943   ***      0                                  0      my %clone = map {
944   ***      0                                  0         my $hashref  = $self->{$_};
945   ***      0                                  0         my $val_copy = {};
946   ***      0                                  0         foreach my $key ( keys %$hashref ) {
947   ***      0                                  0            my $ref = ref $hashref->{$key};
948   ***      0                                  0            $val_copy->{$key} = !$ref           ? $hashref->{$key}
949   ***      0                                  0                              : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
950   ***      0      0                           0                              : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
      ***             0                               
      ***             0                               
951                                                                              : $hashref->{$key};
952                                                         }
953   ***      0                                  0         $_ => $val_copy;
954                                                      } qw(opts short_opts defaults);
955                                                   
956   ***      0                                  0      foreach my $scalar ( qw(got_opts) ) {
957   ***      0                                  0         $clone{$scalar} = $self->{$scalar};
958                                                      }
959                                                   
960   ***      0                                  0      return bless \%clone;     
961                                                   }
962                                                   
963                                                   sub _parse_size {
964   ***      0                    0             0      my ( $self, $opt, $val ) = @_;
965                                                   
966   ***      0      0      0                    0      if ( lc($val || '') eq 'null' ) {
967   ***      0                                  0         MKDEBUG && _d('NULL size for', $opt->{long});
968   ***      0                                  0         $opt->{value} = 'null';
969   ***      0                                  0         return;
970                                                      }
971                                                   
972   ***      0                                  0      my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
973   ***      0                                  0      my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
974   ***      0      0                           0      if ( defined $num ) {
975   ***      0      0                           0         if ( $factor ) {
976   ***      0                                  0            $num *= $factor_for{$factor};
977   ***      0                                  0            MKDEBUG && _d('Setting option', $opt->{y},
978                                                               'to num', $num, '* factor', $factor);
979                                                         }
980   ***      0             0                    0         $opt->{value} = ($pre || '') . $num;
981                                                      }
982                                                      else {
983   ***      0                                  0         $self->save_error("Invalid size for --$opt->{long}");
984                                                      }
985   ***      0                                  0      return;
986                                                   }
987                                                   
988                                                   sub _parse_attribs {
989          256                  256          1190      my ( $self, $option, $attribs ) = @_;
990          256                                861      my $types = $self->{types};
991          256    100                        4163      return $option
                    100                               
      ***            50                               
                    100                               
992                                                         . ($attribs->{'short form'} ? '|' . $attribs->{'short form'}   : '' )
993                                                         . ($attribs->{'negatable'}  ? '!'                              : '' )
994                                                         . ($attribs->{'cumulative'} ? '+'                              : '' )
995                                                         . ($attribs->{'type'}       ? '=' . $types->{$attribs->{type}} : '' );
996                                                   }
997                                                   
998                                                   sub _parse_synopsis {
999            7                    7            41      my ( $self, $file ) = @_;
1000  ***      7             0                   31      $file ||= $self->{file} || __FILE__;
      ***                   33                        
1001           7                                 15      MKDEBUG && _d("Parsing SYNOPSIS in", $file);
1002                                                  
1003           7                                299      local $INPUT_RECORD_SEPARATOR = '';  # read paragraphs
1004  ***      7     50                         292      open my $fh, "<", $file or die "Cannot open $file: $OS_ERROR";
1005           7                                 19      my $para;
1006  ***      7            66                27611      1 while defined($para = <$fh>) && $para !~ m/^=head1 SYNOPSIS/;
1007  ***      7     50                          29      die "$file does not contain a SYNOPSIS section" unless $para;
1008           7                                 22      my @synop;
1009           7                                 42      for ( 1..2 ) {  # 1 for the usage, 2 for the description
1010          14                                 69         my $para = <$fh>;
1011          14                                 66         push @synop, $para;
1012                                                     }
1013           7                                 77      close $fh;
1014           7                                 18      MKDEBUG && _d("Raw SYNOPSIS text:", @synop);
1015           7                                 41      my ($usage, $desc) = @synop;
1016  ***      7     50     33                   72      die "The SYNOPSIS section in $file is not formatted properly"
1017                                                        unless $usage && $desc;
1018                                                  
1019           7                                117      $usage =~ s/^\s*Usage:\s+(.+)/$1/;
1020           7                                 27      chomp $usage;
1021                                                  
1022           7                                 53      $desc =~ s/\n/ /g;
1023           7                                 84      $desc =~ s/\s{2,}/ /g;
1024           7                                 83      $desc =~ s/\. ([A-Z][a-z])/.  $1/g;
1025           7                                 87      $desc =~ s/\s+$//;
1026                                                  
1027                                                     return (
1028           7                                 23         description => $desc,
1029                                                        usage       => $usage,
1030                                                     );
1031                                                  };
1032                                                  
1033                                                  sub _d {
1034  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1035  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1036  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1037                                                          @_;
1038  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1039                                                  }
1040                                                  
1041                                                  1;
1042                                                  
1043                                                  # ###########################################################################
1044                                                  # End OptionParser package
1045                                                  # ###########################################################################
1046                                                  
1047                                                  # ###########################################################################
1048                                                  # VersionParser package 6667
1049                                                  # This package is a copy without comments from the original.  The original
1050                                                  # with comments and its test file can be found in the SVN repository at,
1051                                                  #   trunk/common/VersionParser.pm
1052                                                  #   trunk/common/t/VersionParser.t
1053                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1054                                                  # ###########################################################################
1055                                                  package VersionParser;
1056                                                  
1057           3                    3            36   use strict;
               3                                  9   
               3                                 23   
1058           3                    3            18   use warnings FATAL => 'all';
               3                                  8   
               3                                 21   
1059                                                  
1060           3                    3            20   use English qw(-no_match_vars);
               3                                  6   
               3                                 25   
1061                                                  
1062  ***      3            50      3            22   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  8   
               3                                 54   
1063                                                  
1064                                                  sub new {
1065           8                    8           570      my ( $class ) = @_;
1066           8                                120      bless {}, $class;
1067                                                  }
1068                                                  
1069                                                  sub parse {
1070          19                   19           856      my ( $self, $str ) = @_;
1071          19                                242      my $result = sprintf('%03d%03d%03d', $str =~ m/(\d+)/g);
1072          19                                 48      MKDEBUG && _d($str, 'parses to', $result);
1073          19                                142      return $result;
1074                                                  }
1075                                                  
1076                                                  sub version_ge {
1077          12                   12            59      my ( $self, $dbh, $target ) = @_;
1078          12    100                          91      if ( !$self->{$dbh} ) {
1079           7                                 19         $self->{$dbh} = $self->parse(
1080                                                           $dbh->selectrow_array('SELECT VERSION()'));
1081                                                     }
1082  ***     12     50                         161      my $result = $self->{$dbh} ge $self->parse($target) ? 1 : 0;
1083          12                                 28      MKDEBUG && _d($self->{$dbh}, 'ge', $target, ':', $result);
1084          12                                 64      return $result;
1085                                                  }
1086                                                  
1087                                                  sub innodb_version {
1088  ***      0                    0             0      my ( $self, $dbh ) = @_;
1089  ***      0      0                           0      return unless $dbh;
1090  ***      0                                  0      my $innodb_version = "NO";
1091                                                  
1092  ***      0                                  0      my ($innodb) =
1093  ***      0                                  0         grep { $_->{engine} =~ m/InnoDB/i }
1094                                                        map  {
1095  ***      0                                  0            my %hash;
1096  ***      0                                  0            @hash{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
1097  ***      0                                  0            \%hash;
1098                                                        }
1099  ***      0                                  0         @{ $dbh->selectall_arrayref("SHOW ENGINES", {Slice=>{}}) };
1100  ***      0      0                           0      if ( $innodb ) {
1101  ***      0                                  0         MKDEBUG && _d("InnoDB support:", $innodb->{support});
1102  ***      0      0                           0         if ( $innodb->{support} =~ m/YES|DEFAULT/i ) {
1103  ***      0                                  0            my $vars = $dbh->selectrow_hashref(
1104                                                              "SHOW VARIABLES LIKE 'innodb_version'");
1105  ***      0      0      0                    0            $innodb_version = !$vars ? "BUILTIN"
1106                                                                           :          ($vars->{Value} || $vars->{value});
1107                                                        }
1108                                                        else {
1109  ***      0                                  0            $innodb_version = $innodb->{support};  # probably DISABLED or NO
1110                                                        }
1111                                                     }
1112                                                  
1113  ***      0                                  0      MKDEBUG && _d("InnoDB version:", $innodb_version);
1114  ***      0                                  0      return $innodb_version;
1115                                                  }
1116                                                  
1117                                                  sub _d {
1118  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1119  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1120  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1121                                                          @_;
1122  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1123                                                  }
1124                                                  
1125                                                  1;
1126                                                  
1127                                                  # ###########################################################################
1128                                                  # End VersionParser package
1129                                                  # ###########################################################################
1130                                                  
1131                                                  # ###########################################################################
1132                                                  # DSNParser package 7388
1133                                                  # This package is a copy without comments from the original.  The original
1134                                                  # with comments and its test file can be found in the SVN repository at,
1135                                                  #   trunk/common/DSNParser.pm
1136                                                  #   trunk/common/t/DSNParser.t
1137                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1138                                                  # ###########################################################################
1139                                                  
1140                                                  package DSNParser;
1141                                                  
1142           3                    3            23   use strict;
               3                                  9   
               3                                 17   
1143           3                    3            18   use warnings FATAL => 'all';
               3                                  7   
               3                                 15   
1144           3                    3            19   use English qw(-no_match_vars);
               3                                 12   
               3                                 17   
1145  ***      3            50      3            22   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  9   
               3                                 41   
1146                                                  
1147           3                    3            20   use Data::Dumper;
               3                                  8   
               3                                301   
1148                                                  $Data::Dumper::Indent    = 0;
1149                                                  $Data::Dumper::Quotekeys = 0;
1150                                                  
1151                                                  eval {
1152                                                     require DBI;
1153                                                  };
1154                                                  my $have_dbi = $EVAL_ERROR ? 0 : 1;
1155                                                  
1156                                                  
1157                                                  sub new {
1158          11                   11           144      my ( $class, %args ) = @_;
1159          11                                 76      foreach my $arg ( qw(opts) ) {
1160  ***     11     50                         102         die "I need a $arg argument" unless $args{$arg};
1161                                                     }
1162          11                                 68      my $self = {
1163                                                        opts => {}  # h, P, u, etc.  Should come from DSN OPTIONS section in POD.
1164                                                     };
1165          11                                 36      foreach my $opt ( @{$args{opts}} ) {
              11                                 60   
1166  ***     99     50     33                  873         if ( !$opt->{key} || !$opt->{desc} ) {
1167  ***      0                                  0            die "Invalid DSN option: ", Dumper($opt);
1168                                                        }
1169                                                        MKDEBUG && _d('DSN option:',
1170                                                           join(', ',
1171          99                                219               map { "$_=" . (defined $opt->{$_} ? ($opt->{$_} || '') : 'undef') }
1172                                                                 keys %$opt
1173                                                           )
1174                                                        );
1175          99           100                  937         $self->{opts}->{$opt->{key}} = {
1176                                                           dsn  => $opt->{dsn},
1177                                                           desc => $opt->{desc},
1178                                                           copy => $opt->{copy} || 0,
1179                                                        };
1180                                                     }
1181          11                                234      return bless $self, $class;
1182                                                  }
1183                                                  
1184                                                  sub prop {
1185          51                   51           255      my ( $self, $prop, $value ) = @_;
1186          51    100                         252      if ( @_ > 2 ) {
1187           7                                 18         MKDEBUG && _d('Setting', $prop, 'property');
1188           7                                 28         $self->{$prop} = $value;
1189                                                     }
1190          51                                342      return $self->{$prop};
1191                                                  }
1192                                                  
1193                                                  sub parse {
1194          17                   17           410      my ( $self, $dsn, $prev, $defaults ) = @_;
1195  ***     17     50                          81      if ( !$dsn ) {
1196  ***      0                                  0         MKDEBUG && _d('No DSN to parse');
1197  ***      0                                  0         return;
1198                                                     }
1199          17                                 38      MKDEBUG && _d('Parsing', $dsn);
1200          17           100                   90      $prev     ||= {};
1201  ***     17            50                   74      $defaults ||= {};
1202          17                                 51      my %given_props;
1203          17                                 41      my %final_props;
1204          17                                 64      my $opts = $self->{opts};
1205                                                  
1206          17                                120      foreach my $dsn_part ( split(/,/, $dsn) ) {
1207  ***     33     50                         284         if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
1208          33                                184            $given_props{$prop_key} = $prop_val;
1209                                                        }
1210                                                        else {
1211  ***      0                                  0            MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
1212  ***      0                                  0            $given_props{h} = $dsn_part;
1213                                                        }
1214                                                     }
1215                                                  
1216          17                                 95      foreach my $key ( keys %$opts ) {
1217         153                                341         MKDEBUG && _d('Finding value for', $key);
1218         153                                523         $final_props{$key} = $given_props{$key};
1219         153    100    100                 1398         if (   !defined $final_props{$key}
      ***                   66                        
1220                                                             && defined $prev->{$key} && $opts->{$key}->{copy} )
1221                                                        {
1222           7                                 25            $final_props{$key} = $prev->{$key};
1223           7                                 19            MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
1224                                                        }
1225         153    100                         619         if ( !defined $final_props{$key} ) {
1226         113                                359            $final_props{$key} = $defaults->{$key};
1227         113                                314            MKDEBUG && _d('Copying value for', $key, 'from defaults');
1228                                                        }
1229                                                     }
1230                                                  
1231          17                                149      foreach my $key ( keys %given_props ) {
1232  ***     33     50                         158         die "Unknown DSN option '$key' in '$dsn'.  For more details, "
1233                                                              . "please use the --help option, or try 'perldoc $PROGRAM_NAME' "
1234                                                              . "for complete documentation."
1235                                                           unless exists $opts->{$key};
1236                                                     }
1237  ***     17     50                          76      if ( (my $required = $self->prop('required')) ) {
1238  ***      0                                  0         foreach my $key ( keys %$required ) {
1239  ***      0      0                           0            die "Missing required DSN option '$key' in '$dsn'.  For more details, "
1240                                                                 . "please use the --help option, or try 'perldoc $PROGRAM_NAME' "
1241                                                                 . "for complete documentation."
1242                                                              unless $final_props{$key};
1243                                                        }
1244                                                     }
1245                                                  
1246          17                                101      return \%final_props;
1247                                                  }
1248                                                  
1249                                                  sub parse_options {
1250           7                    7            29      my ( $self, $o ) = @_;
1251  ***      7     50                          50      die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
1252           7                                 35      my $dsn_string
1253                                                        = join(',',
1254          63    100                         235             map  { "$_=".$o->get($_); }
1255           7                                 58             grep { $o->has($_) && $o->get($_) }
1256           7                                 22             keys %{$self->{opts}}
1257                                                          );
1258           7                                 29      MKDEBUG && _d('DSN string made from options:', $dsn_string);
1259           7                                 46      return $self->parse($dsn_string);
1260                                                  }
1261                                                  
1262                                                  sub as_string {
1263  ***      0                    0             0      my ( $self, $dsn, $props ) = @_;
1264  ***      0      0                           0      return $dsn unless ref $dsn;
1265  ***      0      0                           0      my %allowed = $props ? map { $_=>1 } @$props : ();
      ***      0                                  0   
1266  ***      0      0                           0      return join(',',
1267  ***      0      0                           0         map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_})  }
1268  ***      0      0                           0         grep { defined $dsn->{$_} && $self->{opts}->{$_} }
1269  ***      0                                  0         grep { !$props || $allowed{$_}                   }
1270                                                        sort keys %$dsn );
1271                                                  }
1272                                                  
1273                                                  sub usage {
1274  ***      0                    0             0      my ( $self ) = @_;
1275  ***      0                                  0      my $usage
1276                                                        = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
1277                                                        . "  KEY  COPY  MEANING\n"
1278                                                        . "  ===  ====  =============================================\n";
1279  ***      0                                  0      my %opts = %{$self->{opts}};
      ***      0                                  0   
1280  ***      0                                  0      foreach my $key ( sort keys %opts ) {
1281  ***      0      0      0                    0         $usage .= "  $key    "
1282                                                               .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
1283                                                               .  ($opts{$key}->{desc} || '[No description]')
1284                                                               . "\n";
1285                                                     }
1286  ***      0                                  0      $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
1287  ***      0                                  0      return $usage;
1288                                                  }
1289                                                  
1290                                                  sub get_cxn_params {
1291          10                   10            78      my ( $self, $info ) = @_;
1292          10                                 33      my $dsn;
1293          10                                 30      my %opts = %{$self->{opts}};
              10                                124   
1294  ***     10            50                   68      my $driver = $self->prop('dbidriver') || '';
1295  ***     10     50                          46      if ( $driver eq 'Pg' ) {
1296  ***      0                                  0         $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
1297  ***      0                                  0            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1298  ***      0             0                    0                        grep { defined $info->{$_} }
1299                                                                       qw(h P));
1300                                                     }
1301                                                     else {
1302          13                                113         $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
1303          50                                193            . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
1304          10           100                  134                        grep { defined $info->{$_} }
1305                                                                       qw(F h P S A))
1306                                                           . ';mysql_read_default_group=client';
1307                                                     }
1308          10                                 34      MKDEBUG && _d($dsn);
1309          10                                111      return ($dsn, $info->{u}, $info->{p});
1310                                                  }
1311                                                  
1312                                                  sub fill_in_dsn {
1313  ***      0                    0             0      my ( $self, $dbh, $dsn ) = @_;
1314  ***      0                                  0      my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
1315  ***      0                                  0      my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
1316  ***      0                                  0      $user =~ s/@.*//;
1317  ***      0             0                    0      $dsn->{h} ||= $vars->{hostname}->{Value};
1318  ***      0             0                    0      $dsn->{S} ||= $vars->{'socket'}->{Value};
1319  ***      0             0                    0      $dsn->{P} ||= $vars->{port}->{Value};
1320  ***      0             0                    0      $dsn->{u} ||= $user;
1321  ***      0             0                    0      $dsn->{D} ||= $db;
1322                                                  }
1323                                                  
1324                                                  sub get_dbh {
1325          10                   10            61      my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
1326  ***     10            50                   43      $opts ||= {};
1327  ***     10     50                         133      my $defaults = {
1328                                                        AutoCommit         => 0,
1329                                                        RaiseError         => 1,
1330                                                        PrintError         => 0,
1331                                                        ShowErrorStatement => 1,
1332                                                        mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/i ? 1 : 0),
1333                                                     };
1334          10                                 55      @{$defaults}{ keys %$opts } = values %$opts;
              10                                 41   
1335                                                  
1336  ***     10     50                          55      if ( $opts->{mysql_use_result} ) {
1337  ***      0                                  0         $defaults->{mysql_use_result} = 1;
1338                                                     }
1339                                                  
1340  ***     10     50                          55      if ( !$have_dbi ) {
1341  ***      0                                  0         die "Cannot connect to MySQL because the Perl DBI module is not "
1342                                                           . "installed or not found.  Run 'perl -MDBI' to see the directories "
1343                                                           . "that Perl searches for DBI.  If DBI is not installed, try:\n"
1344                                                           . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
1345                                                           . "  RHEL/CentOS    yum install perl-DBI\n"
1346                                                           . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";
1347                                                  
1348                                                     }
1349                                                  
1350          10                                 24      my $dbh;
1351          10                                 39      my $tries = 2;
1352  ***     10            66                  115      while ( !$dbh && $tries-- ) {
1353                                                        MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
1354          10                                 30            join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');
1355                                                  
1356          10                                 33         eval {
1357          10                                143            $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);
1358                                                  
1359  ***     10     50                         117            if ( $cxn_string =~ m/mysql/i ) {
1360          10                                 29               my $sql;
1361                                                  
1362          10                                 41               $sql = 'SELECT @@SQL_MODE';
1363          10                                 30               MKDEBUG && _d($dbh, $sql);
1364          10                                 26               my ($sql_mode) = $dbh->selectrow_array($sql);
1365                                                  
1366  ***     10     50                        1600               $sql = 'SET @@SQL_QUOTE_SHOW_CREATE = 1'
1367                                                                   . '/*!40101, @@SQL_MODE=\'NO_AUTO_VALUE_ON_ZERO'
1368                                                                   . ($sql_mode ? ",$sql_mode" : '')
1369                                                                   . '\'*/';
1370          10                                 28               MKDEBUG && _d($dbh, $sql);
1371          10                                769               $dbh->do($sql);
1372                                                  
1373  ***     10     50                         100               if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
1374  ***      0                                  0                  $sql = "/*!40101 SET NAMES $charset*/";
1375  ***      0                                  0                  MKDEBUG && _d($dbh, ':', $sql);
1376  ***      0                                  0                  $dbh->do($sql);
1377  ***      0                                  0                  MKDEBUG && _d('Enabling charset for STDOUT');
1378  ***      0      0                           0                  if ( $charset eq 'utf8' ) {
1379  ***      0      0                           0                     binmode(STDOUT, ':utf8')
1380                                                                       or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
1381                                                                 }
1382                                                                 else {
1383  ***      0      0                           0                     binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
1384                                                                 }
1385                                                              }
1386                                                  
1387          10    100                          62               if ( $self->prop('set-vars') ) {
1388           7                                 34                  $sql = "SET " . $self->prop('set-vars');
1389           7                                 20                  MKDEBUG && _d($dbh, ':', $sql);
1390           7                                456                  $dbh->do($sql);
1391                                                              }
1392                                                           }
1393                                                        };
1394  ***     10     50     33                  109         if ( !$dbh && $EVAL_ERROR ) {
1395  ***      0                                  0            MKDEBUG && _d($EVAL_ERROR);
1396  ***      0      0                           0            if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
      ***             0                               
1397  ***      0                                  0               MKDEBUG && _d('Going to try again without utf8 support');
1398  ***      0                                  0               delete $defaults->{mysql_enable_utf8};
1399                                                           }
1400                                                           elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
1401  ***      0                                  0               die "Cannot connect to MySQL because the Perl DBD::mysql module is "
1402                                                                 . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
1403                                                                 . "the directories that Perl searches for DBD::mysql.  If "
1404                                                                 . "DBD::mysql is not installed, try:\n"
1405                                                                 . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
1406                                                                 . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
1407                                                                 . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
1408                                                           }
1409  ***      0      0                           0            if ( !$tries ) {
1410  ***      0                                  0               die $EVAL_ERROR;
1411                                                           }
1412                                                        }
1413                                                     }
1414                                                  
1415          10                                 25      MKDEBUG && _d('DBH info: ',
1416                                                        $dbh,
1417                                                        Dumper($dbh->selectrow_hashref(
1418                                                           'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
1419                                                        'Connection info:',      $dbh->{mysql_hostinfo},
1420                                                        'Character set info:',   Dumper($dbh->selectall_arrayref(
1421                                                                       'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
1422                                                        '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
1423                                                        '$DBI::VERSION:',        $DBI::VERSION,
1424                                                     );
1425                                                  
1426          10                                 60      return $dbh;
1427                                                  }
1428                                                  
1429                                                  sub get_hostname {
1430  ***      0                    0             0      my ( $self, $dbh ) = @_;
1431  ***      0      0      0                    0      if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
1432  ***      0                                  0         return $host;
1433                                                     }
1434  ***      0                                  0      my ( $hostname, $one ) = $dbh->selectrow_array(
1435                                                        'SELECT /*!50038 @@hostname, */ 1');
1436  ***      0                                  0      return $hostname;
1437                                                  }
1438                                                  
1439                                                  sub disconnect {
1440  ***      0                    0             0      my ( $self, $dbh ) = @_;
1441  ***      0                                  0      MKDEBUG && $self->print_active_handles($dbh);
1442  ***      0                                  0      $dbh->disconnect;
1443                                                  }
1444                                                  
1445                                                  sub print_active_handles {
1446  ***      0                    0             0      my ( $self, $thing, $level ) = @_;
1447  ***      0             0                    0      $level ||= 0;
1448  ***      0      0      0                    0      printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      ***             0      0                        
      ***                    0                        
1449                                                        $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
1450                                                        or die "Cannot print: $OS_ERROR";
1451  ***      0                                  0      foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      ***      0                                  0   
      ***      0                                  0   
1452  ***      0                                  0         $self->print_active_handles( $handle, $level + 1 );
1453                                                     }
1454                                                  }
1455                                                  
1456                                                  sub copy {
1457  ***      0                    0             0      my ( $self, $dsn_1, $dsn_2, %args ) = @_;
1458  ***      0      0                           0      die 'I need a dsn_1 argument' unless $dsn_1;
1459  ***      0      0                           0      die 'I need a dsn_2 argument' unless $dsn_2;
1460  ***      0                                  0      my %new_dsn = map {
1461  ***      0                                  0         my $key = $_;
1462  ***      0                                  0         my $val;
1463  ***      0      0                           0         if ( $args{overwrite} ) {
1464  ***      0      0                           0            $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
1465                                                        }
1466                                                        else {
1467  ***      0      0                           0            $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
1468                                                        }
1469  ***      0                                  0         $key => $val;
1470  ***      0                                  0      } keys %{$self->{opts}};
1471  ***      0                                  0      return \%new_dsn;
1472                                                  }
1473                                                  
1474                                                  sub _d {
1475  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1476  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1477  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1478                                                          @_;
1479  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1480                                                  }
1481                                                  
1482                                                  1;
1483                                                  
1484                                                  # ###########################################################################
1485                                                  # End DSNParser package
1486                                                  # ###########################################################################
1487                                                  
1488                                                  # ###########################################################################
1489                                                  # Daemon package 6255
1490                                                  # This package is a copy without comments from the original.  The original
1491                                                  # with comments and its test file can be found in the SVN repository at,
1492                                                  #   trunk/common/Daemon.pm
1493                                                  #   trunk/common/t/Daemon.t
1494                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1495                                                  # ###########################################################################
1496                                                  
1497                                                  package Daemon;
1498                                                  
1499           3                    3            27   use strict;
               3                                  8   
               3                                295   
1500           3                    3            19   use warnings FATAL => 'all';
               3                                  8   
               3                                270   
1501                                                  
1502           3                    3            18   use POSIX qw(setsid);
               3                                  6   
               3                                 22   
1503           3                    3            19   use English qw(-no_match_vars);
               3                                  6   
               3                                 18   
1504                                                  
1505  ***      3            50      3            25   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  7   
               3                                 42   
1506                                                  
1507                                                  sub new {
1508  ***      0                    0             0      my ( $class, %args ) = @_;
1509  ***      0                                  0      foreach my $arg ( qw(o) ) {
1510  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
1511                                                     }
1512  ***      0                                  0      my $o = $args{o};
1513  ***      0      0                           0      my $self = {
      ***             0                               
1514                                                        o        => $o,
1515                                                        log_file => $o->has('log') ? $o->get('log') : undef,
1516                                                        PID_file => $o->has('pid') ? $o->get('pid') : undef,
1517                                                     };
1518                                                  
1519  ***      0                                  0      check_PID_file(undef, $self->{PID_file});
1520                                                  
1521  ***      0                                  0      MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
1522  ***      0                                  0      return bless $self, $class;
1523                                                  }
1524                                                  
1525                                                  sub daemonize {
1526  ***      0                    0             0      my ( $self ) = @_;
1527                                                  
1528  ***      0                                  0      MKDEBUG && _d('About to fork and daemonize');
1529  ***      0      0                           0      defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
1530  ***      0      0                           0      if ( $pid ) {
1531  ***      0                                  0         MKDEBUG && _d('I am the parent and now I die');
1532  ***      0                                  0         exit;
1533                                                     }
1534                                                  
1535  ***      0                                  0      $self->{PID_owner} = $PID;
1536  ***      0                                  0      $self->{child}     = 1;
1537                                                  
1538  ***      0      0                           0      POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
1539  ***      0      0                           0      chdir '/'       or die "Cannot chdir to /: $OS_ERROR";
1540                                                  
1541  ***      0                                  0      $self->_make_PID_file();
1542                                                  
1543  ***      0                                  0      $OUTPUT_AUTOFLUSH = 1;
1544                                                  
1545  ***      0      0                           0      if ( -t STDIN ) {
1546  ***      0                                  0         close STDIN;
1547  ***      0      0                           0         open  STDIN, '/dev/null'
1548                                                           or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
1549                                                     }
1550                                                  
1551  ***      0      0                           0      if ( $self->{log_file} ) {
1552  ***      0                                  0         close STDOUT;
1553  ***      0      0                           0         open  STDOUT, '>>', $self->{log_file}
1554                                                           or die "Cannot open log file $self->{log_file}: $OS_ERROR";
1555                                                  
1556  ***      0                                  0         close STDERR;
1557  ***      0      0                           0         open  STDERR, ">&STDOUT"
1558                                                           or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
1559                                                     }
1560                                                     else {
1561  ***      0      0                           0         if ( -t STDOUT ) {
1562  ***      0                                  0            close STDOUT;
1563  ***      0      0                           0            open  STDOUT, '>', '/dev/null'
1564                                                              or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
1565                                                        }
1566  ***      0      0                           0         if ( -t STDERR ) {
1567  ***      0                                  0            close STDERR;
1568  ***      0      0                           0            open  STDERR, '>', '/dev/null'
1569                                                              or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
1570                                                        }
1571                                                     }
1572                                                  
1573  ***      0                                  0      MKDEBUG && _d('I am the child and now I live daemonized');
1574  ***      0                                  0      return;
1575                                                  }
1576                                                  
1577                                                  sub check_PID_file {
1578  ***      0                    0             0      my ( $self, $file ) = @_;
1579  ***      0      0                           0      my $PID_file = $self ? $self->{PID_file} : $file;
1580  ***      0                                  0      MKDEBUG && _d('Checking PID file', $PID_file);
1581  ***      0      0      0                    0      if ( $PID_file && -f $PID_file ) {
1582  ***      0                                  0         my $pid;
1583  ***      0                                  0         eval { chomp($pid = `cat $PID_file`); };
      ***      0                                  0   
1584  ***      0      0                           0         die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
1585  ***      0                                  0         MKDEBUG && _d('PID file exists; it contains PID', $pid);
1586  ***      0      0                           0         if ( $pid ) {
1587  ***      0                                  0            my $pid_is_alive = kill 0, $pid;
1588  ***      0      0                           0            if ( $pid_is_alive ) {
1589  ***      0                                  0               die "The PID file $PID_file already exists "
1590                                                                 . " and the PID that it contains, $pid, is running";
1591                                                           }
1592                                                           else {
1593  ***      0                                  0               warn "Overwriting PID file $PID_file because the PID that it "
1594                                                                 . "contains, $pid, is not running";
1595                                                           }
1596                                                        }
1597                                                        else {
1598  ***      0                                  0            die "The PID file $PID_file already exists but it does not "
1599                                                              . "contain a PID";
1600                                                        }
1601                                                     }
1602                                                     else {
1603  ***      0                                  0         MKDEBUG && _d('No PID file');
1604                                                     }
1605  ***      0                                  0      return;
1606                                                  }
1607                                                  
1608                                                  sub make_PID_file {
1609  ***      0                    0             0      my ( $self ) = @_;
1610  ***      0      0                           0      if ( exists $self->{child} ) {
1611  ***      0                                  0         die "Do not call Daemon::make_PID_file() for daemonized scripts";
1612                                                     }
1613  ***      0                                  0      $self->_make_PID_file();
1614  ***      0                                  0      $self->{PID_owner} = $PID;
1615  ***      0                                  0      return;
1616                                                  }
1617                                                  
1618                                                  sub _make_PID_file {
1619  ***      0                    0             0      my ( $self ) = @_;
1620                                                  
1621  ***      0                                  0      my $PID_file = $self->{PID_file};
1622  ***      0      0                           0      if ( !$PID_file ) {
1623  ***      0                                  0         MKDEBUG && _d('No PID file to create');
1624  ***      0                                  0         return;
1625                                                     }
1626                                                  
1627  ***      0                                  0      $self->check_PID_file();
1628                                                  
1629  ***      0      0                           0      open my $PID_FH, '>', $PID_file
1630                                                        or die "Cannot open PID file $PID_file: $OS_ERROR";
1631  ***      0      0                           0      print $PID_FH $PID
1632                                                        or die "Cannot print to PID file $PID_file: $OS_ERROR";
1633  ***      0      0                           0      close $PID_FH
1634                                                        or die "Cannot close PID file $PID_file: $OS_ERROR";
1635                                                  
1636  ***      0                                  0      MKDEBUG && _d('Created PID file:', $self->{PID_file});
1637  ***      0                                  0      return;
1638                                                  }
1639                                                  
1640                                                  sub _remove_PID_file {
1641  ***      0                    0             0      my ( $self ) = @_;
1642  ***      0      0      0                    0      if ( $self->{PID_file} && -f $self->{PID_file} ) {
1643  ***      0      0                           0         unlink $self->{PID_file}
1644                                                           or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
1645  ***      0                                  0         MKDEBUG && _d('Removed PID file');
1646                                                     }
1647                                                     else {
1648  ***      0                                  0         MKDEBUG && _d('No PID to remove');
1649                                                     }
1650  ***      0                                  0      return;
1651                                                  }
1652                                                  
1653                                                  sub DESTROY {
1654  ***      0                    0             0      my ( $self ) = @_;
1655                                                  
1656  ***      0      0      0                    0      $self->_remove_PID_file() if ($self->{PID_owner} || 0) == $PID;
1657                                                  
1658  ***      0                                  0      return;
1659                                                  }
1660                                                  
1661                                                  sub _d {
1662  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1663  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1664  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1665                                                          @_;
1666  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
1667                                                  }
1668                                                  
1669                                                  1;
1670                                                  
1671                                                  # ###########################################################################
1672                                                  # End Daemon package
1673                                                  # ###########################################################################
1674                                                  
1675                                                  # ###########################################################################
1676                                                  # Quoter package 6850
1677                                                  # This package is a copy without comments from the original.  The original
1678                                                  # with comments and its test file can be found in the SVN repository at,
1679                                                  #   trunk/common/Quoter.pm
1680                                                  #   trunk/common/t/Quoter.t
1681                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1682                                                  # ###########################################################################
1683                                                  
1684                                                  package Quoter;
1685                                                  
1686           3                    3            25   use strict;
               3                                  7   
               3                                 18   
1687           3                    3            19   use warnings FATAL => 'all';
               3                                  6   
               3                                 16   
1688           3                    3            17   use English qw(-no_match_vars);
               3                                  7   
               3                                 16   
1689                                                  
1690  ***      3            50      3            20   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  7   
               3                                 45   
1691                                                  
1692                                                  sub new {
1693           8                    8            57      my ( $class, %args ) = @_;
1694           8                                 81      return bless {}, $class;
1695                                                  }
1696                                                  
1697                                                  sub quote {
1698         104                  104           499      my ( $self, @vals ) = @_;
1699         104                                387      foreach my $val ( @vals ) {
1700         159                                638         $val =~ s/`/``/g;
1701                                                     }
1702         104                                381      return join('.', map { '`' . $_ . '`' } @vals);
             159                                981   
1703                                                  }
1704                                                  
1705                                                  sub quote_val {
1706          10                   10            38      my ( $self, $val ) = @_;
1707                                                  
1708  ***     10     50                          39      return 'NULL' unless defined $val;          # undef = NULL
1709  ***     10     50                          35      return "''" if $val eq '';                  # blank string = ''
1710  ***     10     50                          38      return $val if $val =~ m/^0x[0-9a-fA-F]+$/;  # hex data
1711                                                  
1712          10                                 30      $val =~ s/(['\\])/\\$1/g;
1713          10                                 71      return "'$val'";
1714                                                  }
1715                                                  
1716                                                  sub split_unquote {
1717          21                   21           116      my ( $self, $db_tbl, $default_db ) = @_;
1718          21                                134      $db_tbl =~ s/`//g;
1719          21                                126      my ( $db, $tbl ) = split(/[.]/, $db_tbl);
1720  ***     21     50                         102      if ( !$tbl ) {
1721          21                                 68         $tbl = $db;
1722          21                                 63         $db  = $default_db;
1723                                                     }
1724          21                                107      return ($db, $tbl);
1725                                                  }
1726                                                  
1727                                                  sub literal_like {
1728          29                   29           126      my ( $self, $like ) = @_;
1729  ***     29     50                         121      return unless $like;
1730          29                                282      $like =~ s/([%_])/\\$1/g;
1731          29                                153      return "'$like'";
1732                                                  }
1733                                                  
1734                                                  sub join_quote {
1735  ***      0                    0             0      my ( $self, $default_db, $db_tbl ) = @_;
1736  ***      0      0                           0      return unless $db_tbl;
1737  ***      0                                  0      my ($db, $tbl) = split(/[.]/, $db_tbl);
1738  ***      0      0                           0      if ( !$tbl ) {
1739  ***      0                                  0         $tbl = $db;
1740  ***      0                                  0         $db  = $default_db;
1741                                                     }
1742  ***      0      0      0                    0      $db  = "`$db`"  if $db  && $db  !~ m/^`/;
1743  ***      0      0      0                    0      $tbl = "`$tbl`" if $tbl && $tbl !~ m/^`/;
1744  ***      0      0                           0      return $db ? "$db.$tbl" : $tbl;
1745                                                  }
1746                                                  
1747                                                  1;
1748                                                  
1749                                                  # ###########################################################################
1750                                                  # End Quoter package
1751                                                  # ###########################################################################
1752                                                  
1753                                                  # ###########################################################################
1754                                                  # Transformers package 7226
1755                                                  # This package is a copy without comments from the original.  The original
1756                                                  # with comments and its test file can be found in the SVN repository at,
1757                                                  #   trunk/common/Transformers.pm
1758                                                  #   trunk/common/t/Transformers.t
1759                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
1760                                                  # ###########################################################################
1761                                                  
1762                                                  package Transformers;
1763                                                  
1764           3                    3            25   use strict;
               3                                  6   
               3                                 14   
1765           3                    3            18   use warnings FATAL => 'all';
               3                                 11   
               3                                 19   
1766           3                    3            31   use English qw(-no_match_vars);
               3                                  8   
               3                                 16   
1767           3                    3            41   use Time::Local qw(timegm timelocal);
               3                                  9   
               3                                 33   
1768           3                    3            22   use Digest::MD5 qw(md5_hex);
               3                                  7   
               3                                 23   
1769                                                  
1770  ***      3            50      3            18   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  8   
               3                                 39   
1771                                                  
1772                                                  require Exporter;
1773                                                  our @ISA         = qw(Exporter);
1774                                                  our %EXPORT_TAGS = ();
1775                                                  our @EXPORT      = ();
1776                                                  our @EXPORT_OK   = qw(
1777                                                     micro_t
1778                                                     percentage_of
1779                                                     secs_to_time
1780                                                     time_to_secs
1781                                                     shorten
1782                                                     ts
1783                                                     parse_timestamp
1784                                                     unix_timestamp
1785                                                     any_unix_timestamp
1786                                                     make_checksum
1787                                                     crc32
1788                                                  );
1789                                                  
1790                                                  our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
1791                                                  our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
1792                                                  our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks
1793                                                  
1794                                                  sub micro_t {
1795  ***      0                    0             0      my ( $t, %args ) = @_;
1796  ***      0      0                           0      my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
1797  ***      0      0                           0      my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
1798  ***      0                                  0      my $f;
1799                                                  
1800  ***      0      0                           0      $t = 0 if $t < 0;
1801                                                  
1802  ***      0      0                           0      $t = sprintf('%.17f', $t) if $t =~ /e/;
1803                                                  
1804  ***      0                                  0      $t =~ s/\.(\d{1,6})\d*/\.$1/;
1805                                                  
1806  ***      0      0      0                    0      if ($t > 0 && $t <= 0.000999) {
      ***             0      0                        
      ***             0                               
1807  ***      0                                  0         $f = ($t * 1000000) . 'us';
1808                                                     }
1809                                                     elsif ($t >= 0.001000 && $t <= 0.999999) {
1810  ***      0                                  0         $f = sprintf("%.${p_ms}f", $t * 1000);
1811  ***      0                                  0         $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
1812                                                     }
1813                                                     elsif ($t >= 1) {
1814  ***      0                                  0         $f = sprintf("%.${p_s}f", $t);
1815  ***      0                                  0         $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
1816                                                     }
1817                                                     else {
1818  ***      0                                  0         $f = 0;  # $t should = 0 at this point
1819                                                     }
1820                                                  
1821  ***      0                                  0      return $f;
1822                                                  }
1823                                                  
1824                                                  sub percentage_of {
1825  ***      0                    0             0      my ( $is, $of, %args ) = @_;
1826  ***      0             0                    0      my $p   = $args{p} || 0; # float precision
1827  ***      0      0                           0      my $fmt = $p ? "%.${p}f" : "%d";
1828  ***      0             0                    0      return sprintf $fmt, ($is * 100) / ($of ||= 1);
1829                                                  }
1830                                                  
1831                                                  sub secs_to_time {
1832  ***      0                    0             0      my ( $secs, $fmt ) = @_;
1833  ***      0             0                    0      $secs ||= 0;
1834  ***      0      0                           0      return '00:00' unless $secs;
1835                                                  
1836  ***      0      0      0                    0      $fmt ||= $secs >= 86_400 ? 'd'
      ***             0                               
1837                                                            : $secs >= 3_600  ? 'h'
1838                                                            :                   'm';
1839                                                  
1840                                                     return
1841  ***      0      0                           0         $fmt eq 'd' ? sprintf(
      ***             0                               
1842                                                           "%d+%02d:%02d:%02d",
1843                                                           int($secs / 86_400),
1844                                                           int(($secs % 86_400) / 3_600),
1845                                                           int(($secs % 3_600) / 60),
1846                                                           $secs % 60)
1847                                                        : $fmt eq 'h' ? sprintf(
1848                                                           "%02d:%02d:%02d",
1849                                                           int(($secs % 86_400) / 3_600),
1850                                                           int(($secs % 3_600) / 60),
1851                                                           $secs % 60)
1852                                                        : sprintf(
1853                                                           "%02d:%02d",
1854                                                           int(($secs % 3_600) / 60),
1855                                                           $secs % 60);
1856                                                  }
1857                                                  
1858                                                  sub time_to_secs {
1859  ***      0                    0             0      my ( $val, $default_suffix ) = @_;
1860  ***      0      0                           0      die "I need a val argument" unless defined $val;
1861  ***      0                                  0      my $t = 0;
1862  ***      0                                  0      my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
1863  ***      0             0                    0      $suffix = $suffix || $default_suffix || 's';
      ***                    0                        
1864  ***      0      0                           0      if ( $suffix =~ m/[smhd]/ ) {
1865  ***      0      0                           0         $t = $suffix eq 's' ? $num * 1        # Seconds
      ***             0                               
      ***             0                               
1866                                                           : $suffix eq 'm' ? $num * 60       # Minutes
1867                                                           : $suffix eq 'h' ? $num * 3600     # Hours
1868                                                           :                  $num * 86400;   # Days
1869                                                  
1870  ***      0      0      0                    0         $t *= -1 if $prefix && $prefix eq '-';
1871                                                     }
1872                                                     else {
1873  ***      0                                  0         die "Invalid suffix for $val: $suffix";
1874                                                     }
1875  ***      0                                  0      return $t;
1876                                                  }
1877                                                  
1878                                                  sub shorten {
1879  ***      0                    0             0      my ( $num, %args ) = @_;
1880  ***      0      0                           0      my $p = defined $args{p} ? $args{p} : 2;     # float precision
1881  ***      0      0                           0      my $d = defined $args{d} ? $args{d} : 1_024; # divisor
1882  ***      0                                  0      my $n = 0;
1883  ***      0                                  0      my @units = ('', qw(k M G T P E Z Y));
1884  ***      0             0                    0      while ( $num >= $d && $n < @units - 1 ) {
1885  ***      0                                  0         $num /= $d;
1886  ***      0                                  0         ++$n;
1887                                                     }
1888  ***      0      0      0                    0      return sprintf(
1889                                                        $num =~ m/\./ || $n
1890                                                           ? "%.${p}f%s"
1891                                                           : '%d',
1892                                                        $num, $units[$n]);
1893                                                  }
1894                                                  
1895                                                  sub ts {
1896         100                  100           417      my ( $time, $gmt ) = @_;
1897  ***    100     50                        1560      my ( $sec, $min, $hour, $mday, $mon, $year )
1898                                                        = $gmt ? gmtime($time) : localtime($time);
1899         100                                406      $mon  += 1;
1900         100                                293      $year += 1900;
1901         100                                753      my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
1902                                                        $year, $mon, $mday, $hour, $min, $sec);
1903  ***    100     50                         662      if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
1904  ***      0                                  0         $us = sprintf("%.6f", $us);
1905  ***      0                                  0         $us =~ s/^0\././;
1906  ***      0                                  0         $val .= $us;
1907                                                     }
1908         100                                868      return $val;
1909                                                  }
1910                                                  
1911                                                  sub parse_timestamp {
1912  ***      0                    0             0      my ( $val ) = @_;
1913  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $f)
1914                                                           = $val =~ m/^$mysql_ts$/ )
1915                                                     {
1916  ***      0      0                           0         return sprintf "%d-%02d-%02d %02d:%02d:"
      ***             0                               
1917                                                                       . (defined $f ? '%09.6f' : '%02d'),
1918                                                                       $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
1919                                                     }
1920  ***      0                                  0      return $val;
1921                                                  }
1922                                                  
1923                                                  sub unix_timestamp {
1924  ***      0                    0             0      my ( $val, $gmt ) = @_;
1925  ***      0      0                           0      if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
1926  ***      0      0                           0         $val = $gmt
1927                                                           ? timegm($s, $i, $h, $d, $m - 1, $y)
1928                                                           : timelocal($s, $i, $h, $d, $m - 1, $y);
1929  ***      0      0                           0         if ( defined $us ) {
1930  ***      0                                  0            $us = sprintf('%.6f', $us);
1931  ***      0                                  0            $us =~ s/^0\././;
1932  ***      0                                  0            $val .= $us;
1933                                                        }
1934                                                     }
1935  ***      0                                  0      return $val;
1936                                                  }
1937                                                  
1938                                                  sub any_unix_timestamp {
1939  ***      0                    0             0      my ( $val, $callback ) = @_;
1940                                                  
1941  ***      0      0                           0      if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      ***             0                               
      ***             0                               
      ***             0                               
1942  ***      0      0                           0         $n = $suffix eq 's' ? $n            # Seconds
      ***             0                               
      ***             0                               
      ***             0                               
1943                                                           : $suffix eq 'm' ? $n * 60       # Minutes
1944                                                           : $suffix eq 'h' ? $n * 3600     # Hours
1945                                                           : $suffix eq 'd' ? $n * 86400    # Days
1946                                                           :                  $n;           # default: Seconds
1947  ***      0                                  0         MKDEBUG && _d('ts is now - N[shmd]:', $n);
1948  ***      0                                  0         return time - $n;
1949                                                     }
1950                                                     elsif ( $val =~ m/^\d{9,}/ ) {
1951  ***      0                                  0         MKDEBUG && _d('ts is already a unix timestamp');
1952  ***      0                                  0         return $val;
1953                                                     }
1954                                                     elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
1955  ***      0                                  0         MKDEBUG && _d('ts is MySQL slow log timestamp');
1956  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
1957  ***      0                                  0         return unix_timestamp(parse_timestamp($val));
1958                                                     }
1959                                                     elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
1960  ***      0                                  0         MKDEBUG && _d('ts is properly formatted timestamp');
1961  ***      0      0                           0         $val .= ' 00:00:00' unless $hms;
1962  ***      0                                  0         return unix_timestamp($val);
1963                                                     }
1964                                                     else {
1965  ***      0                                  0         MKDEBUG && _d('ts is MySQL expression');
1966  ***      0      0      0                    0         return $callback->($val) if $callback && ref $callback eq 'CODE';
1967                                                     }
1968                                                  
1969  ***      0                                  0      MKDEBUG && _d('Unknown ts type:', $val);
1970  ***      0                                  0      return;
1971                                                  }
1972                                                  
1973                                                  sub make_checksum {
1974  ***      0                    0             0      my ( $val ) = @_;
1975  ***      0                                  0      my $checksum = uc substr(md5_hex($val), -16);
1976  ***      0                                  0      MKDEBUG && _d($checksum, 'checksum for', $val);
1977  ***      0                                  0      return $checksum;
1978                                                  }
1979                                                  
1980                                                  sub crc32 {
1981  ***      0                    0             0      my ( $string ) = @_;
1982  ***      0      0                           0      return unless $string;
1983  ***      0                                  0      my $poly = 0xEDB88320;
1984  ***      0                                  0      my $crc  = 0xFFFFFFFF;
1985  ***      0                                  0      foreach my $char ( split(//, $string) ) {
1986  ***      0                                  0         my $comp = ($crc ^ ord($char)) & 0xFF;
1987  ***      0                                  0         for ( 1 .. 8 ) {
1988  ***      0      0                           0            $comp = $comp & 1 ? $poly ^ ($comp >> 1) : $comp >> 1;
1989                                                        }
1990  ***      0                                  0         $crc = (($crc >> 8) & 0x00FFFFFF) ^ $comp;
1991                                                     }
1992  ***      0                                  0      return $crc ^ 0xFFFFFFFF;
1993                                                  }
1994                                                  
1995                                                  sub _d {
1996  ***      0                    0             0      my ($package, undef, $line) = caller 0;
1997  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
1998  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
1999                                                          @_;
2000  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2001                                                  }
2002                                                  
2003                                                  1;
2004                                                  
2005                                                  # ###########################################################################
2006                                                  # End Transformers package
2007                                                  # ###########################################################################
2008                                                  
2009                                                  # ###########################################################################
2010                                                  # TableParser package 7156
2011                                                  # This package is a copy without comments from the original.  The original
2012                                                  # with comments and its test file can be found in the SVN repository at,
2013                                                  #   trunk/common/TableParser.pm
2014                                                  #   trunk/common/t/TableParser.t
2015                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
2016                                                  # ###########################################################################
2017                                                  
2018                                                  package TableParser;
2019                                                  
2020           3                    3            24   use strict;
               3                                  8   
               3                                 22   
2021           3                    3            28   use warnings FATAL => 'all';
               3                                 11   
               3                                 18   
2022           3                    3            17   use English qw(-no_match_vars);
               3                                  7   
               3                                 22   
2023           3                    3            21   use Data::Dumper;
               3                                  8   
               3                                 16   
2024                                                  $Data::Dumper::Indent    = 1;
2025                                                  $Data::Dumper::Sortkeys  = 1;
2026                                                  $Data::Dumper::Quotekeys = 0;
2027                                                  
2028  ***      3            50      3            19   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  6   
               3                                 41   
2029                                                  
2030                                                  sub new {
2031           8                    8            64      my ( $class, %args ) = @_;
2032           8                                 41      my @required_args = qw(Quoter);
2033           8                                 53      foreach my $arg ( @required_args ) {
2034  ***      8     50                          65         die "I need a $arg argument" unless $args{$arg};
2035                                                     }
2036           8                                 47      my $self = { %args };
2037           8                                 82      return bless $self, $class;
2038                                                  }
2039                                                  
2040                                                  sub parse {
2041          14                   14            75      my ( $self, $ddl, $opts ) = @_;
2042  ***     14     50                          65      return unless $ddl;
2043  ***     14     50                          84      if ( ref $ddl eq 'ARRAY' ) {
2044  ***     14     50                         103         if ( lc $ddl->[0] eq 'table' ) {
2045          14                                 59            $ddl = $ddl->[1];
2046                                                        }
2047                                                        else {
2048                                                           return {
2049  ***      0                                  0               engine => 'VIEW',
2050                                                           };
2051                                                        }
2052                                                     }
2053                                                  
2054  ***     14     50                         159      if ( $ddl !~ m/CREATE (?:TEMPORARY )?TABLE `/ ) {
2055  ***      0                                  0         die "Cannot parse table definition; is ANSI quoting "
2056                                                           . "enabled or SQL_QUOTE_SHOW_CREATE disabled?";
2057                                                     }
2058                                                  
2059          14                                155      my ($name)     = $ddl =~ m/CREATE (?:TEMPORARY )?TABLE\s+(`.+?`)/;
2060  ***     14     50                         121      (undef, $name) = $self->{Quoter}->split_unquote($name) if $name;
2061                                                  
2062          14                                302      $ddl =~ s/(`[^`]+`)/\L$1/g;
2063                                                  
2064          14                                 93      my $engine = $self->get_engine($ddl);
2065                                                  
2066          14                                311      my @defs   = $ddl =~ m/^(\s+`.*?),?$/gm;
2067          14                                 57      my @cols   = map { $_ =~ m/`([^`]+)`/ } @defs;
              40                                227   
2068          14                                 46      MKDEBUG && _d('Table cols:', join(', ', map { "`$_`" } @cols));
2069                                                  
2070          14                                 39      my %def_for;
2071          14                                 99      @def_for{@cols} = @defs;
2072                                                  
2073          14                                 45      my (@nums, @null);
2074          14                                 44      my (%type_for, %is_nullable, %is_numeric, %is_autoinc);
2075          14                                 77      foreach my $col ( @cols ) {
2076          40                                130         my $def = $def_for{$col};
2077          40                                265         my ( $type ) = $def =~ m/`[^`]+`\s([a-z]+)/;
2078  ***     40     50                         157         die "Can't determine column type for $def" unless $type;
2079          40                                130         $type_for{$col} = $type;
2080          40    100                         258         if ( $type =~ m/(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/ ) {
2081          12                                 46            push @nums, $col;
2082          12                                 48            $is_numeric{$col} = 1;
2083                                                        }
2084          40    100                         191         if ( $def !~ m/NOT NULL/ ) {
2085          24                                 82            push @null, $col;
2086          24                                 83            $is_nullable{$col} = 1;
2087                                                        }
2088          40    100                         238         $is_autoinc{$col} = $def =~ m/AUTO_INCREMENT/i ? 1 : 0;
2089                                                     }
2090                                                  
2091          14                                111      my ($keys, $clustered_key) = $self->get_keys($ddl, $opts, \%is_nullable);
2092                                                  
2093          14                                108      my ($charset) = $ddl =~ m/DEFAULT CHARSET=(\w+)/;
2094                                                  
2095                                                     return {
2096          40                                187         name           => $name,
2097                                                        cols           => \@cols,
2098          40                                415         col_posn       => { map { $cols[$_] => $_ } 0..$#cols },
2099          14                                140         is_col         => { map { $_ => 1 } @cols },
2100                                                        null_cols      => \@null,
2101                                                        is_nullable    => \%is_nullable,
2102                                                        is_autoinc     => \%is_autoinc,
2103                                                        clustered_key  => $clustered_key,
2104                                                        keys           => $keys,
2105                                                        defs           => \%def_for,
2106                                                        numeric_cols   => \@nums,
2107                                                        is_numeric     => \%is_numeric,
2108                                                        engine         => $engine,
2109                                                        type_for       => \%type_for,
2110                                                        charset        => $charset,
2111                                                     };
2112                                                  }
2113                                                  
2114                                                  sub sort_indexes {
2115  ***      0                    0             0      my ( $self, $tbl ) = @_;
2116                                                  
2117                                                     my @indexes
2118  ***      0                                  0         = sort {
2119  ***      0                                  0            (($a ne 'PRIMARY') <=> ($b ne 'PRIMARY'))
2120                                                           || ( !$tbl->{keys}->{$a}->{is_unique} <=> !$tbl->{keys}->{$b}->{is_unique} )
2121                                                           || ( $tbl->{keys}->{$a}->{is_nullable} <=> $tbl->{keys}->{$b}->{is_nullable} )
2122  ***      0      0      0                    0            || ( scalar(@{$tbl->{keys}->{$a}->{cols}}) <=> scalar(@{$tbl->{keys}->{$b}->{cols}}) )
      ***      0             0                    0   
2123                                                        }
2124                                                        grep {
2125  ***      0                                  0            $tbl->{keys}->{$_}->{type} eq 'BTREE'
2126                                                        }
2127  ***      0                                  0         sort keys %{$tbl->{keys}};
2128                                                  
2129  ***      0                                  0      MKDEBUG && _d('Indexes sorted best-first:', join(', ', @indexes));
2130  ***      0                                  0      return @indexes;
2131                                                  }
2132                                                  
2133                                                  sub find_best_index {
2134  ***      0                    0             0      my ( $self, $tbl, $index ) = @_;
2135  ***      0                                  0      my $best;
2136  ***      0      0                           0      if ( $index ) {
2137  ***      0                                  0         ($best) = grep { uc $_ eq uc $index } keys %{$tbl->{keys}};
      ***      0                                  0   
      ***      0                                  0   
2138                                                     }
2139  ***      0      0                           0      if ( !$best ) {
2140  ***      0      0                           0         if ( $index ) {
2141  ***      0                                  0            die "Index '$index' does not exist in table";
2142                                                        }
2143                                                        else {
2144  ***      0                                  0            ($best) = $self->sort_indexes($tbl);
2145                                                        }
2146                                                     }
2147  ***      0                                  0      MKDEBUG && _d('Best index found is', $best);
2148  ***      0                                  0      return $best;
2149                                                  }
2150                                                  
2151                                                  sub find_possible_keys {
2152  ***      0                    0             0      my ( $self, $dbh, $database, $table, $quoter, $where ) = @_;
2153  ***      0      0                           0      return () unless $where;
2154  ***      0                                  0      my $sql = 'EXPLAIN SELECT * FROM ' . $quoter->quote($database, $table)
2155                                                        . ' WHERE ' . $where;
2156  ***      0                                  0      MKDEBUG && _d($sql);
2157  ***      0                                  0      my $expl = $dbh->selectrow_hashref($sql);
2158  ***      0                                  0      $expl = { map { lc($_) => $expl->{$_} } keys %$expl };
      ***      0                                  0   
2159  ***      0      0                           0      if ( $expl->{possible_keys} ) {
2160  ***      0                                  0         MKDEBUG && _d('possible_keys =', $expl->{possible_keys});
2161  ***      0                                  0         my @candidates = split(',', $expl->{possible_keys});
2162  ***      0                                  0         my %possible   = map { $_ => 1 } @candidates;
      ***      0                                  0   
2163  ***      0      0                           0         if ( $expl->{key} ) {
2164  ***      0                                  0            MKDEBUG && _d('MySQL chose', $expl->{key});
2165  ***      0                                  0            unshift @candidates, grep { $possible{$_} } split(',', $expl->{key});
      ***      0                                  0   
2166  ***      0                                  0            MKDEBUG && _d('Before deduping:', join(', ', @candidates));
2167  ***      0                                  0            my %seen;
2168  ***      0                                  0            @candidates = grep { !$seen{$_}++ } @candidates;
      ***      0                                  0   
2169                                                        }
2170  ***      0                                  0         MKDEBUG && _d('Final list:', join(', ', @candidates));
2171  ***      0                                  0         return @candidates;
2172                                                     }
2173                                                     else {
2174  ***      0                                  0         MKDEBUG && _d('No keys in possible_keys');
2175  ***      0                                  0         return ();
2176                                                     }
2177                                                  }
2178                                                  
2179                                                  sub check_table {
2180          29                   29           209      my ( $self, %args ) = @_;
2181          29                                158      my @required_args = qw(dbh db tbl);
2182          29                                116      foreach my $arg ( @required_args ) {
2183  ***     87     50                         407         die "I need a $arg argument" unless $args{$arg};
2184                                                     }
2185          29                                143      my ($dbh, $db, $tbl) = @args{@required_args};
2186          29                                115      my $q      = $self->{Quoter};
2187          29                                145      my $db_tbl = $q->quote($db, $tbl);
2188          29                                 71      MKDEBUG && _d('Checking', $db_tbl);
2189                                                  
2190          29                                114      my $sql = "SHOW TABLES FROM " . $q->quote($db)
2191                                                             . ' LIKE ' . $q->literal_like($tbl);
2192          29                                 70      MKDEBUG && _d($sql);
2193          29                                 79      my $row;
2194          29                                 77      eval {
2195          29                                 72         $row = $dbh->selectrow_arrayref($sql);
2196                                                     };
2197  ***     29     50                        6976      if ( $EVAL_ERROR ) {
2198  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
2199  ***      0                                  0         return 0;
2200                                                     }
2201  ***     29    100     66                  296      if ( !$row->[0] || $row->[0] ne $tbl ) {
2202          16                                 44         MKDEBUG && _d('Table does not exist');
2203          16                                157         return 0;
2204                                                     }
2205                                                  
2206          13                                 32      MKDEBUG && _d('Table exists; no privs to check');
2207  ***     13     50                         126      return 1 unless $args{all_privs};
2208                                                  
2209  ***      0                                  0      $sql = "SHOW FULL COLUMNS FROM $db_tbl";
2210  ***      0                                  0      MKDEBUG && _d($sql);
2211  ***      0                                  0      eval {
2212  ***      0                                  0         $row = $dbh->selectrow_hashref($sql);
2213                                                     };
2214  ***      0      0                           0      if ( $EVAL_ERROR ) {
2215  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
2216  ***      0                                  0         return 0;
2217                                                     }
2218  ***      0      0                           0      if ( !scalar keys %$row ) {
2219  ***      0                                  0         MKDEBUG && _d('Table has no columns:', Dumper($row));
2220  ***      0                                  0         return 0;
2221                                                     }
2222  ***      0             0                    0      my $privs = $row->{privileges} || $row->{Privileges};
2223                                                  
2224  ***      0                                  0      $sql = "DELETE FROM $db_tbl LIMIT 0";
2225  ***      0                                  0      MKDEBUG && _d($sql);
2226  ***      0                                  0      eval {
2227  ***      0                                  0         $dbh->do($sql);
2228                                                     };
2229  ***      0      0                           0      my $can_delete = $EVAL_ERROR ? 0 : 1;
2230                                                  
2231  ***      0                                  0      MKDEBUG && _d('User privs on', $db_tbl, ':', $privs,
2232                                                        ($can_delete ? 'delete' : ''));
2233                                                  
2234  ***      0      0      0                    0      if ( !($privs =~ m/select/ && $privs =~ m/insert/ && $privs =~ m/update/
      ***                    0                        
      ***                    0                        
2235                                                            && $can_delete) ) {
2236  ***      0                                  0         MKDEBUG && _d('User does not have all privs');
2237  ***      0                                  0         return 0;
2238                                                     }
2239                                                  
2240  ***      0                                  0      MKDEBUG && _d('User has all privs');
2241  ***      0                                  0      return 1;
2242                                                  }
2243                                                  
2244                                                  sub get_engine {
2245          28                   28           141      my ( $self, $ddl, $opts ) = @_;
2246          28                                319      my ( $engine ) = $ddl =~ m/\).*?(?:ENGINE|TYPE)=(\w+)/;
2247          28                                 72      MKDEBUG && _d('Storage engine:', $engine);
2248  ***     28            50                  160      return $engine || undef;
2249                                                  }
2250                                                  
2251                                                  sub get_keys {
2252          14                   14            78      my ( $self, $ddl, $opts, $is_nullable ) = @_;
2253          14                                 63      my $engine        = $self->get_engine($ddl);
2254          14                                 46      my $keys          = {};
2255          14                                 40      my $clustered_key = undef;
2256                                                  
2257                                                     KEY:
2258          14                                161      foreach my $key ( $ddl =~ m/^  ((?:[A-Z]+ )?KEY .*)$/gm ) {
2259                                                  
2260  ***     12     50                          59         next KEY if $key =~ m/FOREIGN/;
2261                                                  
2262          12                                 38         my $key_ddl = $key;
2263          12                                 31         MKDEBUG && _d('Parsed key:', $key_ddl);
2264                                                  
2265  ***     12     50                          82         if ( $engine !~ m/MEMORY|HEAP/ ) {
2266          12                                 59            $key =~ s/USING HASH/USING BTREE/;
2267                                                        }
2268                                                  
2269          12                                 91         my ( $type, $cols ) = $key =~ m/(?:USING (\w+))? \((.+)\)/;
2270          12                                 61         my ( $special ) = $key =~ m/(FULLTEXT|SPATIAL)/;
2271  ***     12            33                  190         $type = $type || $special || 'BTREE';
      ***                   50                        
2272  ***     12     50     33                   96         if ( $opts->{mysql_version} && $opts->{mysql_version} lt '004001000'
      ***                   33                        
2273                                                           && $engine =~ m/HEAP|MEMORY/i )
2274                                                        {
2275  ***      0                                  0            $type = 'HASH'; # MySQL pre-4.1 supports only HASH indexes on HEAP
2276                                                        }
2277                                                  
2278          12                                115         my ($name) = $key =~ m/(PRIMARY|`[^`]*`)/;
2279  ***     12     50                          80         my $unique = $key =~ m/PRIMARY|UNIQUE/ ? 1 : 0;
2280          12                                 34         my @cols;
2281          12                                 33         my @col_prefixes;
2282          12                                 92         foreach my $col_def ( $cols =~ m/`[^`]+`(?:\(\d+\))?/g ) {
2283          12                                 75            my ($name, $prefix) = $col_def =~ m/`([^`]+)`(?:\((\d+)\))?/;
2284          12                                 45            push @cols, $name;
2285          12                                 54            push @col_prefixes, $prefix;
2286                                                        }
2287          12                                 49         $name =~ s/`//g;
2288                                                  
2289          12                                 35         MKDEBUG && _d( $name, 'key cols:', join(', ', map { "`$_`" } @cols));
2290                                                  
2291          12                                 64         $keys->{$name} = {
2292                                                           name         => $name,
2293                                                           type         => $type,
2294                                                           colnames     => $cols,
2295                                                           cols         => \@cols,
2296                                                           col_prefixes => \@col_prefixes,
2297                                                           is_unique    => $unique,
2298          12                                161            is_nullable  => scalar(grep { $is_nullable->{$_} } @cols),
2299          12                                 71            is_col       => { map { $_ => 1 } @cols },
2300                                                           ddl          => $key_ddl,
2301                                                        };
2302                                                  
2303  ***     12    100     66                  137         if ( $engine =~ m/InnoDB/i && !$clustered_key ) {
2304           4                                 14            my $this_key = $keys->{$name};
2305  ***      4     50      0                   21            if ( $this_key->{name} eq 'PRIMARY' ) {
      ***             0                               
2306           4                                 12               $clustered_key = 'PRIMARY';
2307                                                           }
2308                                                           elsif ( $this_key->{is_unique} && !$this_key->{is_nullable} ) {
2309  ***      0                                  0               $clustered_key = $this_key->{name};
2310                                                           }
2311           4                                 26            MKDEBUG && $clustered_key && _d('This key is the clustered key');
2312                                                        }
2313                                                     }
2314                                                  
2315          14                                 95      return $keys, $clustered_key;
2316                                                  }
2317                                                  
2318                                                  sub get_fks {
2319  ***      0                    0             0      my ( $self, $ddl, $opts ) = @_;
2320  ***      0                                  0      my $fks = {};
2321                                                  
2322  ***      0                                  0      foreach my $fk (
2323                                                        $ddl =~ m/CONSTRAINT .* FOREIGN KEY .* REFERENCES [^\)]*\)/mg )
2324                                                     {
2325  ***      0                                  0         my ( $name ) = $fk =~ m/CONSTRAINT `(.*?)`/;
2326  ***      0                                  0         my ( $cols ) = $fk =~ m/FOREIGN KEY \(([^\)]+)\)/;
2327  ***      0                                  0         my ( $parent, $parent_cols ) = $fk =~ m/REFERENCES (\S+) \(([^\)]+)\)/;
2328                                                  
2329  ***      0      0      0                    0         if ( $parent !~ m/\./ && $opts->{database} ) {
2330  ***      0                                  0            $parent = "`$opts->{database}`.$parent";
2331                                                        }
2332                                                  
2333  ***      0                                  0         $fks->{$name} = {
2334                                                           name           => $name,
2335                                                           colnames       => $cols,
2336  ***      0                                  0            cols           => [ map { s/[ `]+//g; $_; } split(',', $cols) ],
      ***      0                                  0   
2337                                                           parent_tbl     => $parent,
2338                                                           parent_colnames=> $parent_cols,
2339  ***      0                                  0            parent_cols    => [ map { s/[ `]+//g; $_; } split(',', $parent_cols) ],
      ***      0                                  0   
2340                                                           ddl            => $fk,
2341                                                        };
2342                                                     }
2343                                                  
2344  ***      0                                  0      return $fks;
2345                                                  }
2346                                                  
2347                                                  sub remove_auto_increment {
2348  ***      0                    0             0      my ( $self, $ddl ) = @_;
2349  ***      0                                  0      $ddl =~ s/(^\).*?) AUTO_INCREMENT=\d+\b/$1/m;
2350  ***      0                                  0      return $ddl;
2351                                                  }
2352                                                  
2353                                                  sub remove_secondary_indexes {
2354  ***      0                    0             0      my ( $self, $ddl ) = @_;
2355  ***      0                                  0      my $sec_indexes_ddl;
2356  ***      0                                  0      my $tbl_struct = $self->parse($ddl);
2357                                                  
2358  ***      0      0      0                    0      if ( ($tbl_struct->{engine} || '') =~ m/InnoDB/i ) {
2359  ***      0                                  0         my $clustered_key = $tbl_struct->{clustered_key};
2360  ***      0             0                    0         $clustered_key  ||= '';
2361                                                  
2362  ***      0                                  0         my @sec_indexes   = map {
2363  ***      0                                  0            my $key_def = $_->{ddl};
2364  ***      0                                  0            $key_def =~ s/([\(\)])/\\$1/g;
2365  ***      0                                  0            $ddl =~ s/\s+$key_def//i;
2366                                                  
2367  ***      0                                  0            my $key_ddl = "ADD $_->{ddl}";
2368  ***      0      0                           0            $key_ddl   .= ',' unless $key_ddl =~ m/,$/;
2369  ***      0                                  0            $key_ddl;
2370                                                        }
2371  ***      0                                  0         grep { $_->{name} ne $clustered_key }
2372  ***      0                                  0         values %{$tbl_struct->{keys}};
2373  ***      0                                  0         MKDEBUG && _d('Secondary indexes:', Dumper(\@sec_indexes));
2374                                                  
2375  ***      0      0                           0         if ( @sec_indexes ) {
2376  ***      0                                  0            $sec_indexes_ddl = join(' ', @sec_indexes);
2377  ***      0                                  0            $sec_indexes_ddl =~ s/,$//;
2378                                                        }
2379                                                  
2380  ***      0                                  0         $ddl =~ s/,(\n\) )/$1/s;
2381                                                     }
2382                                                     else {
2383  ***      0                                  0         MKDEBUG && _d('Not removing secondary indexes from',
2384                                                           $tbl_struct->{engine}, 'table');
2385                                                     }
2386                                                  
2387  ***      0                                  0      return $ddl, $sec_indexes_ddl, $tbl_struct;
2388                                                  }
2389                                                  
2390                                                  sub _d {
2391  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2392  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2393  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2394                                                          @_;
2395  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2396                                                  }
2397                                                  
2398                                                  1;
2399                                                  
2400                                                  # ###########################################################################
2401                                                  # End TableParser package
2402                                                  # ###########################################################################
2403                                                  
2404                                                  # ###########################################################################
2405                                                  # MySQLDump package 6345
2406                                                  # This package is a copy without comments from the original.  The original
2407                                                  # with comments and its test file can be found in the SVN repository at,
2408                                                  #   trunk/common/MySQLDump.pm
2409                                                  #   trunk/common/t/MySQLDump.t
2410                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
2411                                                  # ###########################################################################
2412                                                  package MySQLDump;
2413                                                  
2414           3                    3            27   use strict;
               3                                  7   
               3                                 23   
2415           3                    3            17   use warnings FATAL => 'all';
               3                                  9   
               3                                 17   
2416                                                  
2417           3                    3            22   use English qw(-no_match_vars);
               3                                  8   
               3                                 17   
2418                                                  
2419  ***      3            50      3            19   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  7   
               3                                 54   
2420                                                  
2421                                                  ( our $before = <<'EOF') =~ s/^   //gm;
2422                                                     /*!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT */;
2423                                                     /*!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS */;
2424                                                     /*!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION */;
2425                                                     /*!40101 SET NAMES utf8 */;
2426                                                     /*!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE */;
2427                                                     /*!40103 SET TIME_ZONE='+00:00' */;
2428                                                     /*!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 */;
2429                                                     /*!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 */;
2430                                                     /*!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='NO_AUTO_VALUE_ON_ZERO' */;
2431                                                     /*!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 */;
2432                                                  EOF
2433                                                  
2434                                                  ( our $after = <<'EOF') =~ s/^   //gm;
2435                                                     /*!40103 SET TIME_ZONE=@OLD_TIME_ZONE */;
2436                                                     /*!40101 SET SQL_MODE=@OLD_SQL_MODE */;
2437                                                     /*!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS */;
2438                                                     /*!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS */;
2439                                                     /*!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT */;
2440                                                     /*!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS */;
2441                                                     /*!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION */;
2442                                                     /*!40111 SET SQL_NOTES=@OLD_SQL_NOTES */;
2443                                                  EOF
2444                                                  
2445                                                  sub new {
2446           8                    8            62      my ( $class, %args ) = @_;
2447           8                                 48      my $self = {
2448                                                        cache => 0,  # Afaik no script uses this cache any longer because
2449                                                     };
2450           8                                 77      return bless $self, $class;
2451                                                  }
2452                                                  
2453                                                  sub dump {
2454  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl, $what ) = @_;
2455                                                  
2456  ***      0      0                           0      if ( $what eq 'table' ) {
      ***             0                               
      ***             0                               
2457  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2458  ***      0      0                           0         return unless $ddl;
2459  ***      0      0                           0         if ( $ddl->[0] eq 'table' ) {
2460  ***      0                                  0            return $before
2461                                                              . 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2462                                                              . $ddl->[1] . ";\n";
2463                                                        }
2464                                                        else {
2465  ***      0                                  0            return 'DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . ";\n"
2466                                                              . '/*!50001 DROP VIEW IF EXISTS '
2467                                                              . $quoter->quote($tbl) . "*/;\n/*!50001 "
2468                                                              . $self->get_tmp_table($dbh, $quoter, $db, $tbl) . "*/;\n";
2469                                                        }
2470                                                     }
2471                                                     elsif ( $what eq 'triggers' ) {
2472  ***      0                                  0         my $trgs = $self->get_triggers($dbh, $quoter, $db, $tbl);
2473  ***      0      0      0                    0         if ( $trgs && @$trgs ) {
2474  ***      0                                  0            my $result = $before . "\nDELIMITER ;;\n";
2475  ***      0                                  0            foreach my $trg ( @$trgs ) {
2476  ***      0      0                           0               if ( $trg->{sql_mode} ) {
2477  ***      0                                  0                  $result .= qq{/*!50003 SET SESSION SQL_MODE='$trg->{sql_mode}' */;;\n};
2478                                                              }
2479  ***      0                                  0               $result .= "/*!50003 CREATE */ ";
2480  ***      0      0                           0               if ( $trg->{definer} ) {
2481  ***      0                                  0                  my ( $user, $host )
2482  ***      0                                  0                     = map { s/'/''/g; "'$_'"; }
      ***      0                                  0   
2483                                                                      split('@', $trg->{definer}, 2);
2484  ***      0                                  0                  $result .= "/*!50017 DEFINER=$user\@$host */ ";
2485                                                              }
2486  ***      0                                  0               $result .= sprintf("/*!50003 TRIGGER %s %s %s ON %s\nFOR EACH ROW %s */;;\n\n",
2487                                                                 $quoter->quote($trg->{trigger}),
2488  ***      0                                  0                  @{$trg}{qw(timing event)},
2489                                                                 $quoter->quote($trg->{table}),
2490                                                                 $trg->{statement});
2491                                                           }
2492  ***      0                                  0            $result .= "DELIMITER ;\n\n/*!50003 SET SESSION SQL_MODE=\@OLD_SQL_MODE */;\n\n";
2493  ***      0                                  0            return $result;
2494                                                        }
2495                                                        else {
2496  ***      0                                  0            return undef;
2497                                                        }
2498                                                     }
2499                                                     elsif ( $what eq 'view' ) {
2500  ***      0                                  0         my $ddl = $self->get_create_table($dbh, $quoter, $db, $tbl);
2501  ***      0                                  0         return '/*!50001 DROP TABLE IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2502                                                           . '/*!50001 DROP VIEW IF EXISTS ' . $quoter->quote($tbl) . "*/;\n"
2503                                                           . '/*!50001 ' . $ddl->[1] . "*/;\n";
2504                                                     }
2505                                                     else {
2506  ***      0                                  0         die "You didn't say what to dump.";
2507                                                     }
2508                                                  }
2509                                                  
2510                                                  sub _use_db {
2511          14                   14            82      my ( $self, $dbh, $quoter, $new ) = @_;
2512  ***     14     50                          77      if ( !$new ) {
2513  ***      0                                  0         MKDEBUG && _d('No new DB to use');
2514  ***      0                                  0         return;
2515                                                     }
2516          14                                 83      my $sql = 'USE ' . $quoter->quote($new);
2517          14                                 36      MKDEBUG && _d($dbh, $sql);
2518          14                                927      $dbh->do($sql);
2519          14                                 74      return;
2520                                                  }
2521                                                  
2522                                                  sub get_create_table {
2523          14                   14        236265      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2524  ***     14     50     33                  128      if ( !$self->{cache} || !$self->{tables}->{$db}->{$tbl} ) {
2525          14                                 54         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2526                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2527                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2528                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2529          14                                 39         MKDEBUG && _d($sql);
2530          14                                 43         eval { $dbh->do($sql); };
              14                               1938   
2531          14                                 51         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2532          14                                 99         $self->_use_db($dbh, $quoter, $db);
2533          14                                 70         $sql = "SHOW CREATE TABLE " . $quoter->quote($db, $tbl);
2534          14                                 35         MKDEBUG && _d($sql);
2535          14                                 41         my $href;
2536          14                                 36         eval { $href = $dbh->selectrow_hashref($sql); };
              14                                 34   
2537  ***     14     50                         101         if ( $EVAL_ERROR ) {
2538  ***      0                                  0            warn "Failed to $sql.  The table may be damaged.\nError: $EVAL_ERROR";
2539  ***      0                                  0            return;
2540                                                        }
2541                                                  
2542          14                                 43         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2543                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2544          14                                 35         MKDEBUG && _d($sql);
2545          14                               1022         $dbh->do($sql);
2546          14                                 99         my ($key) = grep { m/create table/i } keys %$href;
              28                                203   
2547  ***     14     50                          70         if ( $key ) {
2548          14                                 34            MKDEBUG && _d('This table is a base table');
2549          14                                188            $self->{tables}->{$db}->{$tbl} = [ 'table', $href->{$key} ];
2550                                                        }
2551                                                        else {
2552  ***      0                                  0            MKDEBUG && _d('This table is a view');
2553  ***      0                                  0            ($key) = grep { m/create view/i } keys %$href;
      ***      0                                  0   
2554  ***      0                                  0            $self->{tables}->{$db}->{$tbl} = [ 'view', $href->{$key} ];
2555                                                        }
2556                                                     }
2557          14                                159      return $self->{tables}->{$db}->{$tbl};
2558                                                  }
2559                                                  
2560                                                  sub get_columns {
2561  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2562  ***      0                                  0      MKDEBUG && _d('Get columns for', $db, $tbl);
2563  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{columns}->{$db}->{$tbl} ) {
2564  ***      0                                  0         $self->_use_db($dbh, $quoter, $db);
2565  ***      0                                  0         my $sql = "SHOW COLUMNS FROM " . $quoter->quote($db, $tbl);
2566  ***      0                                  0         MKDEBUG && _d($sql);
2567  ***      0                                  0         my $cols = $dbh->selectall_arrayref($sql, { Slice => {} });
2568                                                  
2569  ***      0                                  0         $self->{columns}->{$db}->{$tbl} = [
2570                                                           map {
2571  ***      0                                  0               my %row;
2572  ***      0                                  0               @row{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2573  ***      0                                  0               \%row;
2574                                                           } @$cols
2575                                                        ];
2576                                                     }
2577  ***      0                                  0      return $self->{columns}->{$db}->{$tbl};
2578                                                  }
2579                                                  
2580                                                  sub get_tmp_table {
2581  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2582  ***      0                                  0      my $result = 'CREATE TABLE ' . $quoter->quote($tbl) . " (\n";
2583  ***      0                                  0      $result .= join(",\n",
2584  ***      0                                  0         map { '  ' . $quoter->quote($_->{field}) . ' ' . $_->{type} }
2585  ***      0                                  0         @{$self->get_columns($dbh, $quoter, $db, $tbl)});
2586  ***      0                                  0      $result .= "\n)";
2587  ***      0                                  0      MKDEBUG && _d($result);
2588  ***      0                                  0      return $result;
2589                                                  }
2590                                                  
2591                                                  sub get_triggers {
2592  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $tbl ) = @_;
2593  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{triggers}->{$db} ) {
2594  ***      0                                  0         $self->{triggers}->{$db} = {};
2595  ***      0                                  0         my $sql = '/*!40101 SET @OLD_SQL_MODE := @@SQL_MODE, '
2596                                                           . q{@@SQL_MODE := REPLACE(REPLACE(@@SQL_MODE, 'ANSI_QUOTES', ''), ',,', ','), }
2597                                                           . '@OLD_QUOTE := @@SQL_QUOTE_SHOW_CREATE, '
2598                                                           . '@@SQL_QUOTE_SHOW_CREATE := 1 */';
2599  ***      0                                  0         MKDEBUG && _d($sql);
2600  ***      0                                  0         eval { $dbh->do($sql); };
      ***      0                                  0   
2601  ***      0                                  0         MKDEBUG && $EVAL_ERROR && _d($EVAL_ERROR);
2602  ***      0                                  0         $sql = "SHOW TRIGGERS FROM " . $quoter->quote($db);
2603  ***      0                                  0         MKDEBUG && _d($sql);
2604  ***      0                                  0         my $sth = $dbh->prepare($sql);
2605  ***      0                                  0         $sth->execute();
2606  ***      0      0                           0         if ( $sth->rows ) {
2607  ***      0                                  0            my $trgs = $sth->fetchall_arrayref({});
2608  ***      0                                  0            foreach my $trg (@$trgs) {
2609  ***      0                                  0               my %trg;
2610  ***      0                                  0               @trg{ map { lc $_ } keys %$trg } = values %$trg;
      ***      0                                  0   
2611  ***      0                                  0               push @{ $self->{triggers}->{$db}->{ $trg{table} } }, \%trg;
      ***      0                                  0   
2612                                                           }
2613                                                        }
2614  ***      0                                  0         $sql = '/*!40101 SET @@SQL_MODE := @OLD_SQL_MODE, '
2615                                                           . '@@SQL_QUOTE_SHOW_CREATE := @OLD_QUOTE */';
2616  ***      0                                  0         MKDEBUG && _d($sql);
2617  ***      0                                  0         $dbh->do($sql);
2618                                                     }
2619  ***      0      0                           0      if ( $tbl ) {
2620  ***      0                                  0         return $self->{triggers}->{$db}->{$tbl};
2621                                                     }
2622  ***      0                                  0      return values %{$self->{triggers}->{$db}};
      ***      0                                  0   
2623                                                  }
2624                                                  
2625                                                  sub get_databases {
2626  ***      0                    0             0      my ( $self, $dbh, $quoter, $like ) = @_;
2627  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{databases} || $like ) {
      ***                    0                        
2628  ***      0                                  0         my $sql = 'SHOW DATABASES';
2629  ***      0                                  0         my @params;
2630  ***      0      0                           0         if ( $like ) {
2631  ***      0                                  0            $sql .= ' LIKE ?';
2632  ***      0                                  0            push @params, $like;
2633                                                        }
2634  ***      0                                  0         my $sth = $dbh->prepare($sql);
2635  ***      0                                  0         MKDEBUG && _d($sql, @params);
2636  ***      0                                  0         $sth->execute( @params );
2637  ***      0                                  0         my @dbs = map { $_->[0] } @{$sth->fetchall_arrayref()};
      ***      0                                  0   
      ***      0                                  0   
2638  ***      0      0                           0         $self->{databases} = \@dbs unless $like;
2639  ***      0                                  0         return @dbs;
2640                                                     }
2641  ***      0                                  0      return @{$self->{databases}};
      ***      0                                  0   
2642                                                  }
2643                                                  
2644                                                  sub get_table_status {
2645  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
2646  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_status}->{$db} || $like ) {
      ***                    0                        
2647  ***      0                                  0         my $sql = "SHOW TABLE STATUS FROM " . $quoter->quote($db);
2648  ***      0                                  0         my @params;
2649  ***      0      0                           0         if ( $like ) {
2650  ***      0                                  0            $sql .= ' LIKE ?';
2651  ***      0                                  0            push @params, $like;
2652                                                        }
2653  ***      0                                  0         MKDEBUG && _d($sql, @params);
2654  ***      0                                  0         my $sth = $dbh->prepare($sql);
2655  ***      0                                  0         $sth->execute(@params);
2656  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref({})};
      ***      0                                  0   
2657  ***      0                                  0         @tables = map {
2658  ***      0                                  0            my %tbl; # Make a copy with lowercased keys
2659  ***      0                                  0            @tbl{ map { lc $_ } keys %$_ } = values %$_;
      ***      0                                  0   
2660  ***      0             0                    0            $tbl{engine} ||= $tbl{type} || $tbl{comment};
      ***                    0                        
2661  ***      0                                  0            delete $tbl{type};
2662  ***      0                                  0            \%tbl;
2663                                                        } @tables;
2664  ***      0      0                           0         $self->{table_status}->{$db} = \@tables unless $like;
2665  ***      0                                  0         return @tables;
2666                                                     }
2667  ***      0                                  0      return @{$self->{table_status}->{$db}};
      ***      0                                  0   
2668                                                  }
2669                                                  
2670                                                  sub get_table_list {
2671  ***      0                    0             0      my ( $self, $dbh, $quoter, $db, $like ) = @_;
2672  ***      0      0      0                    0      if ( !$self->{cache} || !$self->{table_list}->{$db} || $like ) {
      ***                    0                        
2673  ***      0                                  0         my $sql = "SHOW /*!50002 FULL*/ TABLES FROM " . $quoter->quote($db);
2674  ***      0                                  0         my @params;
2675  ***      0      0                           0         if ( $like ) {
2676  ***      0                                  0            $sql .= ' LIKE ?';
2677  ***      0                                  0            push @params, $like;
2678                                                        }
2679  ***      0                                  0         MKDEBUG && _d($sql, @params);
2680  ***      0                                  0         my $sth = $dbh->prepare($sql);
2681  ***      0                                  0         $sth->execute(@params);
2682  ***      0                                  0         my @tables = @{$sth->fetchall_arrayref()};
      ***      0                                  0   
2683  ***      0      0      0                    0         @tables = map {
2684  ***      0                                  0            my %tbl = (
2685                                                              name   => $_->[0],
2686                                                              engine => ($_->[1] || '') eq 'VIEW' ? 'VIEW' : '',
2687                                                           );
2688  ***      0                                  0            \%tbl;
2689                                                        } @tables;
2690  ***      0      0                           0         $self->{table_list}->{$db} = \@tables unless $like;
2691  ***      0                                  0         return @tables;
2692                                                     }
2693  ***      0                                  0      return @{$self->{table_list}->{$db}};
      ***      0                                  0   
2694                                                  }
2695                                                  
2696                                                  sub _d {
2697  ***      0                    0             0      my ($package, undef, $line) = caller 0;
2698  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
2699  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
2700                                                          @_;
2701  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
2702                                                  }
2703                                                  
2704                                                  1;
2705                                                  
2706                                                  # ###########################################################################
2707                                                  # End MySQLDump package
2708                                                  # ###########################################################################
2709                                                  
2710                                                  # ###########################################################################
2711                                                  # TableChunker package 7169
2712                                                  # This package is a copy without comments from the original.  The original
2713                                                  # with comments and its test file can be found in the SVN repository at,
2714                                                  #   trunk/common/TableChunker.pm
2715                                                  #   trunk/common/t/TableChunker.t
2716                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
2717                                                  # ###########################################################################
2718                                                  
2719                                                  package TableChunker;
2720                                                  
2721           3                    3            25   use strict;
               3                                  8   
               3                                 20   
2722           3                    3            19   use warnings FATAL => 'all';
               3                                  7   
               3                                 18   
2723           3                    3            19   use English qw(-no_match_vars);
               3                                  6   
               3                                 17   
2724  ***      3            50      3            20   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  7   
               3                                 40   
2725                                                  
2726           3                    3            20   use POSIX qw(floor ceil);
               3                                  7   
               3                                 25   
2727           3                    3            20   use List::Util qw(min max);
               3                                  9   
               3                                 18   
2728           3                    3            18   use Data::Dumper;
               3                                 16   
               3                                 16   
2729                                                  $Data::Dumper::Indent    = 1;
2730                                                  $Data::Dumper::Sortkeys  = 1;
2731                                                  $Data::Dumper::Quotekeys = 0;
2732                                                  
2733                                                  sub new {
2734           8                    8            85      my ( $class, %args ) = @_;
2735           8                                 46      foreach my $arg ( qw(Quoter MySQLDump) ) {
2736  ***     16     50                          80         die "I need a $arg argument" unless $args{$arg};
2737                                                     }
2738                                                  
2739           8                                 46      my %int_types  = map { $_ => 1 } qw(bigint date datetime int mediumint smallint time timestamp tinyint year);
              80                                435   
2740           8                                 52      my %real_types = map { $_ => 1 } qw(decimal double float);
              24                                118   
2741                                                  
2742           8                                 93      my $self = {
2743                                                        %args,
2744                                                        int_types  => \%int_types,
2745                                                        real_types => \%real_types,
2746                                                        EPOCH      => '1970-01-01',
2747                                                     };
2748                                                  
2749           8                                 83      return bless $self, $class;
2750                                                  }
2751                                                  
2752                                                  sub find_chunk_columns {
2753           9                    9            57      my ( $self, %args ) = @_;
2754           9                                 51      foreach my $arg ( qw(tbl_struct) ) {
2755  ***      9     50                          56         die "I need a $arg argument" unless $args{$arg};
2756                                                     }
2757           9                                 36      my $tbl_struct = $args{tbl_struct};
2758                                                  
2759           9                                 24      my @possible_indexes;
2760           9                                 25      foreach my $index ( values %{ $tbl_struct->{keys} } ) {
               9                                 51   
2761                                                  
2762  ***      8     50                          42         next unless $index->{type} eq 'BTREE';
2763                                                  
2764  ***      8     50                          24         next if grep { defined } @{$index->{col_prefixes}};
               8                                 42   
               8                                 39   
2765                                                  
2766  ***      8     50                          41         if ( $args{exact} ) {
2767  ***      8     50     33                   70            next unless $index->{is_unique} && @{$index->{cols}} == 1;
               8                                 71   
2768                                                        }
2769                                                  
2770           8                                 36         push @possible_indexes, $index;
2771                                                     }
2772                                                     MKDEBUG && _d('Possible chunk indexes in order:',
2773           9                                 23         join(', ', map { $_->{name} } @possible_indexes));
2774                                                  
2775           9                                 27      my $can_chunk_exact = 0;
2776           9                                 25      my @candidate_cols;
2777           9                                 35      foreach my $index ( @possible_indexes ) { 
2778           8                                 34         my $col = $index->{cols}->[0];
2779                                                  
2780           8                                 34         my $col_type = $tbl_struct->{type_for}->{$col};
2781  ***      8     50     33                   74         next unless $self->{int_types}->{$col_type}
      ***                   33                        
2782                                                                 || $self->{real_types}->{$col_type}
2783                                                                 || $col_type =~ m/char/;
2784                                                  
2785           8                                 84         push @candidate_cols, { column => $col, index => $index->{name} };
2786                                                     }
2787                                                  
2788  ***      9    100     50                   89      $can_chunk_exact = 1 if $args{exact} && scalar @candidate_cols;
2789                                                  
2790           9                                 23      if ( MKDEBUG ) {
2791                                                        my $chunk_type = $args{exact} ? 'Exact' : 'Inexact';
2792                                                        _d($chunk_type, 'chunkable:',
2793                                                           join(', ', map { "$_->{column} on $_->{index}" } @candidate_cols));
2794                                                     }
2795                                                  
2796           9                                 22      my @result;
2797           9                                 27      MKDEBUG && _d('Ordering columns by order in tbl, PK first');
2798           9    100                          48      if ( $tbl_struct->{keys}->{PRIMARY} ) {
2799           8                                 48         my $pk_first_col = $tbl_struct->{keys}->{PRIMARY}->{cols}->[0];
2800           8                                 24         @result          = grep { $_->{column} eq $pk_first_col } @candidate_cols;
               8                                 45   
2801           8                                 27         @candidate_cols  = grep { $_->{column} ne $pk_first_col } @candidate_cols;
               8                                 96   
2802                                                     }
2803           9                                 31      my $i = 0;
2804           9                                 27      my %col_pos = map { $_ => $i++ } @{$tbl_struct->{cols}};
              26                                114   
               9                                 42   
2805           9                                 67      push @result, sort { $col_pos{$a->{column}} <=> $col_pos{$b->{column}} }
      ***      0                                  0   
2806                                                                      @candidate_cols;
2807                                                  
2808           9                                 22      if ( MKDEBUG ) {
2809                                                        _d('Chunkable columns:',
2810                                                           join(', ', map { "$_->{column} on $_->{index}" } @result));
2811                                                        _d('Can chunk exactly:', $can_chunk_exact);
2812                                                     }
2813                                                  
2814           9                                 60      return ($can_chunk_exact, @result);
2815                                                  }
2816                                                  
2817                                                  sub calculate_chunks {
2818           5                    5            56      my ( $self, %args ) = @_;
2819           5                                 38      my @required_args = qw(dbh db tbl tbl_struct chunk_col rows_in_range chunk_size);
2820           5                                 38      foreach my $arg ( @required_args ) {
2821  ***     35     50                         153         die "I need a $arg argument" unless defined $args{$arg};
2822                                                     }
2823                                                     MKDEBUG && _d('Calculate chunks for',
2824           5                                 15         join(", ", map {"$_=".(defined $args{$_} ? $args{$_} : "undef")}
2825                                                           qw(db tbl chunk_col min max rows_in_range chunk_size zero_chunk exact)
2826                                                        ));
2827                                                  
2828  ***      5     50                          27      if ( !$args{rows_in_range} ) {
2829  ***      0                                  0         MKDEBUG && _d("Empty table");
2830  ***      0                                  0         return '1=1';
2831                                                     }
2832                                                  
2833           5    100                          37      if ( $args{rows_in_range} < $args{chunk_size} ) {
2834           4                                  7         MKDEBUG && _d("Chunk size larger than rows in range");
2835           4                                 37         return '1=1';
2836                                                     }
2837                                                  
2838           1                                  5      my $q          = $self->{Quoter};
2839           1                                  3      my $dbh        = $args{dbh};
2840           1                                  4      my $chunk_col  = $args{chunk_col};
2841           1                                  3      my $tbl_struct = $args{tbl_struct};
2842           1                                  6      my $col_type   = $tbl_struct->{type_for}->{$chunk_col};
2843           1                                  3      MKDEBUG && _d('chunk col type:', $col_type);
2844                                                  
2845           1                                  3      my %chunker;
2846  ***      1     50     33                    6      if ( $tbl_struct->{is_numeric}->{$chunk_col} || $col_type =~ /date|time/ ) {
      ***             0                               
2847           1                                 13         %chunker = $self->_chunk_numeric(%args);
2848                                                     }
2849                                                     elsif ( $col_type =~ m/char/ ) {
2850  ***      0                                  0         %chunker = $self->_chunk_char(%args);
2851                                                     }
2852                                                     else {
2853  ***      0                                  0         die "Cannot chunk $col_type columns";
2854                                                     }
2855           1                                  4      MKDEBUG && _d("Chunker:", Dumper(\%chunker));
2856           1                                  8      my ($col, $start_point, $end_point, $interval, $range_func)
2857                                                        = @chunker{qw(col start_point end_point interval range_func)};
2858                                                  
2859           1                                  3      my @chunks;
2860  ***      1     50                           4      if ( $start_point < $end_point ) {
2861                                                  
2862  ***      1     50                           6         push @chunks, "$col = 0" if $chunker{have_zero_chunk};
2863                                                  
2864           1                                  3         my ($beg, $end);
2865           1                                  3         my $iter = 0;
2866                                                        for ( my $i = $start_point; $i < $end_point; $i += $interval ) {
2867           5                                 28            ($beg, $end) = $self->$range_func($dbh, $i, $interval, $end_point);
2868                                                  
2869           5    100                          21            if ( $iter++ == 0 ) {
2870  ***      1     50                          11               push @chunks,
2871                                                                 ($chunker{have_zero_chunk} ? "$col > 0 AND " : "")
2872                                                                 ."$col < " . $q->quote_val($end);
2873                                                           }
2874                                                           else {
2875           4                                 18               push @chunks, "$col >= " . $q->quote_val($beg) . " AND $col < " . $q->quote_val($end);
2876                                                           }
2877           1                                  4         }
2878                                                  
2879  ***      1            50                   11         my $chunk_range = lc $args{chunk_range} || 'open';
2880           1                                 11         my $nullable    = $args{tbl_struct}->{is_nullable}->{$args{chunk_col}};
2881           1                                  3         pop @chunks;
2882  ***      1     50                          23         if ( @chunks ) {
2883  ***      1     50                           6            push @chunks, "$col >= " . $q->quote_val($beg)
2884                                                              . ($chunk_range eq 'openclosed'
2885                                                                 ? " AND $col <= " . $q->quote_val($args{max}) : "");
2886                                                        }
2887                                                        else {
2888  ***      0      0                           0            push @chunks, $nullable ? "$col IS NOT NULL" : '1=1';
2889                                                        }
2890  ***      1     50                           5         if ( $nullable ) {
2891  ***      0                                  0            push @chunks, "$col IS NULL";
2892                                                        }
2893                                                     }
2894                                                     else {
2895  ***      0                                  0         MKDEBUG && _d('No chunks; using single chunk 1=1');
2896  ***      0                                  0         push @chunks, '1=1';
2897                                                     }
2898                                                  
2899           1                                 12      return @chunks;
2900                                                  }
2901                                                  
2902                                                  sub _chunk_numeric {
2903           1                    1            12      my ( $self, %args ) = @_;
2904           1                                  8      my @required_args = qw(dbh db tbl tbl_struct chunk_col rows_in_range chunk_size);
2905           1                                  6      foreach my $arg ( @required_args ) {
2906  ***      7     50                          31         die "I need a $arg argument" unless defined $args{$arg};
2907                                                     }
2908           1                                  6      my $q        = $self->{Quoter};
2909           1                                  8      my $db_tbl   = $q->quote($args{db}, $args{tbl});
2910           1                                  6      my $col_type = $args{tbl_struct}->{type_for}->{$args{chunk_col}};
2911                                                  
2912           1                                  3      my $range_func;
2913  ***      1     50                          20      if ( $col_type =~ m/(?:int|year|float|double|decimal)$/ ) {
      ***             0                               
      ***             0                               
2914           1                                  3         $range_func  = 'range_num';
2915                                                     }
2916                                                     elsif ( $col_type =~ m/^(?:timestamp|date|time)$/ ) {
2917  ***      0                                  0         $range_func  = "range_$col_type";
2918                                                     }
2919                                                     elsif ( $col_type eq 'datetime' ) {
2920  ***      0                                  0         $range_func  = 'range_datetime';
2921                                                     }
2922                                                  
2923           1                                  3      my ($start_point, $end_point);
2924           1                                  3      eval {
2925           1                                 12         $start_point = $self->value_to_number(
2926                                                           value       => $args{min},
2927                                                           column_type => $col_type,
2928                                                           dbh         => $args{dbh},
2929                                                        );
2930           1                                  6         $end_point  = $self->value_to_number(
2931                                                           value       => $args{max},
2932                                                           column_type => $col_type,
2933                                                           dbh         => $args{dbh},
2934                                                        );
2935                                                     };
2936  ***      1     50                           5      if ( $EVAL_ERROR ) {
2937  ***      0      0                           0         if ( $EVAL_ERROR =~ m/don't know how to chunk/ ) {
2938  ***      0                                  0            die $EVAL_ERROR;
2939                                                        }
2940                                                        else {
2941  ***      0      0                           0            die "Error calculating chunk start and end points for table "
2942                                                              . "`$args{tbl_struct}->{name}` on column `$args{chunk_col}` "
2943                                                              . "with min/max values "
2944                                                              . join('/',
2945  ***      0                                  0                     map { defined $args{$_} ? $args{$_} : 'undef' } qw(min max))
2946                                                              . ":\n\n"
2947                                                              . $EVAL_ERROR
2948                                                              . "\nVerify that the min and max values are valid for the column.  "
2949                                                              . "If they are valid, this error could be caused by a bug in the "
2950                                                              . "tool.";
2951                                                        }
2952                                                     }
2953                                                  
2954  ***      1     50                           5      if ( !defined $start_point ) {
2955  ***      0                                  0         MKDEBUG && _d('Start point is undefined');
2956  ***      0                                  0         $start_point = 0;
2957                                                     }
2958  ***      1     50     33                   19      if ( !defined $end_point || $end_point < $start_point ) {
2959  ***      0                                  0         MKDEBUG && _d('End point is undefined or before start point');
2960  ***      0                                  0         $end_point = 0;
2961                                                     }
2962           1                                  3      MKDEBUG && _d("Actual chunk range:", $start_point, "to", $end_point);
2963                                                  
2964           1                                  4      my $have_zero_chunk = 0;
2965  ***      1     50                           4      if ( $args{zero_chunk} ) {
2966  ***      0      0      0                    0         if ( $start_point != $end_point && $start_point >= 0 ) {
2967  ***      0                                  0            MKDEBUG && _d('Zero chunking');
2968  ***      0                                  0            my $nonzero_val = $self->get_nonzero_value(
2969                                                              %args,
2970                                                              db_tbl   => $db_tbl,
2971                                                              col      => $args{chunk_col},
2972                                                              col_type => $col_type,
2973                                                              val      => $args{min}
2974                                                           );
2975  ***      0                                  0            $start_point = $self->value_to_number(
2976                                                              value       => $nonzero_val,
2977                                                              column_type => $col_type,
2978                                                              dbh         => $args{dbh},
2979                                                           );
2980  ***      0                                  0            $have_zero_chunk = 1;
2981                                                        }
2982                                                        else {
2983  ***      0                                  0            MKDEBUG && _d("Cannot zero chunk");
2984                                                        }
2985                                                     }
2986           1                                  3      MKDEBUG && _d("Using chunk range:", $start_point, "to", $end_point);
2987                                                  
2988           1                                 10      my $interval = $args{chunk_size}
2989                                                                  * ($end_point - $start_point)
2990                                                                  / $args{rows_in_range};
2991  ***      1     50                           7      if ( $self->{int_types}->{$col_type} ) {
2992           1                                 26         $interval = ceil($interval);
2993                                                     }
2994  ***      1            33                    5      $interval ||= $args{chunk_size};
2995  ***      1     50                           4      if ( $args{exact} ) {
2996  ***      0                                  0         $interval = $args{chunk_size};
2997                                                     }
2998           1                                  6      MKDEBUG && _d('Chunk interval:', $interval, 'units');
2999                                                  
3000                                                     return (
3001           1                                  5         col             => $q->quote($args{chunk_col}),
3002                                                        start_point     => $start_point,
3003                                                        end_point       => $end_point,
3004                                                        interval        => $interval,
3005                                                        range_func      => $range_func,
3006                                                        have_zero_chunk => $have_zero_chunk,
3007                                                     );
3008                                                  }
3009                                                  
3010                                                  sub _chunk_char {
3011  ***      0                    0             0      my ( $self, %args ) = @_;
3012  ***      0                                  0      my @required_args = qw(dbh db tbl tbl_struct chunk_col rows_in_range chunk_size);
3013  ***      0                                  0      foreach my $arg ( @required_args ) {
3014  ***      0      0                           0         die "I need a $arg argument" unless defined $args{$arg};
3015                                                     }
3016  ***      0                                  0      my $q         = $self->{Quoter};
3017  ***      0                                  0      my $db_tbl    = $q->quote($args{db}, $args{tbl});
3018  ***      0                                  0      my $dbh       = $args{dbh};
3019  ***      0                                  0      my $chunk_col = $args{chunk_col};
3020  ***      0                                  0      my $row;
3021  ***      0                                  0      my $sql;
3022                                                  
3023  ***      0                                  0      $sql = "SELECT MIN($chunk_col), MAX($chunk_col) FROM $db_tbl "
3024                                                          . "ORDER BY `$chunk_col`";
3025  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
3026  ***      0                                  0      $row = $dbh->selectrow_arrayref($sql);
3027  ***      0                                  0      my ($min_col, $max_col) = ($row->[0], $row->[1]);
3028                                                  
3029  ***      0                                  0      $sql = "SELECT ORD(?) AS min_col_ord, ORD(?) AS max_col_ord";
3030  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
3031  ***      0                                  0      my $ord_sth = $dbh->prepare($sql);  # avoid quoting issues
3032  ***      0                                  0      $ord_sth->execute($min_col, $max_col);
3033  ***      0                                  0      $row = $ord_sth->fetchrow_arrayref();
3034  ***      0                                  0      my ($min_col_ord, $max_col_ord) = ($row->[0], $row->[1]);
3035  ***      0                                  0      MKDEBUG && _d("Min/max col char code:", $min_col_ord, $max_col_ord);
3036                                                  
3037  ***      0                                  0      my $base;
3038  ***      0                                  0      my @chars;
3039  ***      0                                  0      MKDEBUG && _d("Table charset:", $args{tbl_struct}->{charset});
3040  ***      0      0      0                    0      if ( ($args{tbl_struct}->{charset} || "") eq "latin1" ) {
3041  ***      0                                  0         my @sorted_latin1_chars = (
3042                                                            32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,
3043                                                            46,  47,  48,  49,  50,  51,  52,  53,  54,  55,  56,  57,  58,  59,
3044                                                            60,  61,  62,  63,  64,  65,  66,  67,  68,  69,  70,  71,  72,  73,
3045                                                            74,  75,  76,  77,  78,  79,  80,  81,  82,  83,  84,  85,  86,  87,
3046                                                            88,  89,  90,  91,  92,  93,  94,  95,  96, 123, 124, 125, 126, 161,
3047                                                           162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175,
3048                                                           176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189,
3049                                                           190, 191, 215, 216, 222, 223, 247, 255);
3050                                                  
3051  ***      0                                  0         my ($first_char, $last_char);
3052  ***      0                                  0         for my $i ( 0..$#sorted_latin1_chars ) {
3053  ***      0      0      0                    0            $first_char = $i and last if $sorted_latin1_chars[$i] >= $min_col_ord;
3054                                                        }
3055  ***      0                                  0         for my $i ( $first_char..$#sorted_latin1_chars ) {
3056  ***      0      0      0                    0            $last_char = $i and last if $sorted_latin1_chars[$i] >= $max_col_ord;
3057                                                        };
3058                                                  
3059  ***      0                                  0         @chars = map { chr $_; } @sorted_latin1_chars[$first_char..$last_char];
      ***      0                                  0   
3060  ***      0                                  0         $base  = scalar @chars;
3061                                                     }
3062                                                     else {
3063                                                  
3064  ***      0                                  0         my $tmp_tbl    = '__maatkit_char_chunking_map';
3065  ***      0                                  0         my $tmp_db_tbl = $q->quote($args{db}, $tmp_tbl);
3066  ***      0                                  0         $sql = "DROP TABLE IF EXISTS $tmp_db_tbl";
3067  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
3068  ***      0                                  0         $dbh->do($sql);
3069  ***      0                                  0         my $col_def = $args{tbl_struct}->{defs}->{$chunk_col};
3070  ***      0                                  0         $sql        = "CREATE TEMPORARY TABLE $tmp_db_tbl ($col_def) "
3071                                                                    . "ENGINE=MEMORY";
3072  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
3073  ***      0                                  0         $dbh->do($sql);
3074                                                  
3075  ***      0                                  0         $sql = "INSERT INTO $tmp_db_tbl VALUE (CHAR(?))";
3076  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
3077  ***      0                                  0         my $ins_char_sth = $dbh->prepare($sql);  # avoid quoting issues
3078  ***      0                                  0         for my $char_code ( $min_col_ord..$max_col_ord ) {
3079  ***      0                                  0            $ins_char_sth->execute($char_code);
3080                                                        }
3081                                                  
3082  ***      0                                  0         $sql = "SELECT `$chunk_col` FROM $tmp_db_tbl "
3083                                                             . "WHERE `$chunk_col` BETWEEN ? AND ? "
3084                                                             . "ORDER BY `$chunk_col`";
3085  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
3086  ***      0                                  0         my $sel_char_sth = $dbh->prepare($sql);
3087  ***      0                                  0         $sel_char_sth->execute($min_col, $max_col);
3088                                                  
3089  ***      0                                  0         @chars = map { $_->[0] } @{ $sel_char_sth->fetchall_arrayref() };
      ***      0                                  0   
      ***      0                                  0   
3090  ***      0                                  0         $base  = scalar @chars;
3091                                                  
3092  ***      0                                  0         $sql = "DROP TABLE $tmp_db_tbl";
3093  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
3094  ***      0                                  0         $dbh->do($sql);
3095                                                     }
3096  ***      0                                  0      MKDEBUG && _d("Base", $base, "chars:", @chars);
3097                                                  
3098                                                  
3099  ***      0                                  0      $sql = "SELECT MAX(LENGTH($chunk_col)) FROM $db_tbl ORDER BY `$chunk_col`";
3100  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
3101  ***      0                                  0      $row = $dbh->selectrow_arrayref($sql);
3102  ***      0                                  0      my $max_col_len = $row->[0];
3103  ***      0                                  0      MKDEBUG && _d("Max column value:", $max_col, $max_col_len);
3104  ***      0                                  0      my $n_values;
3105  ***      0                                  0      for my $n_chars ( 1..$max_col_len ) {
3106  ***      0                                  0         $n_values = $base**$n_chars;
3107  ***      0      0                           0         if ( $n_values >= $args{chunk_size} ) {
3108  ***      0                                  0            MKDEBUG && _d($n_chars, "chars in base", $base, "expresses",
3109                                                              $n_values, "values");
3110  ***      0                                  0            last;
3111                                                        }
3112                                                     }
3113                                                  
3114  ***      0                                  0      my $n_chunks = $args{rows_in_range} / $args{chunk_size};
3115  ***      0             0                    0      my $interval = floor($n_values / $n_chunks) || 1;
3116                                                  
3117                                                     my $range_func = sub {
3118  ***      0                    0             0         my ( $self, $dbh, $start, $interval, $max ) = @_;
3119  ***      0                                  0         my $start_char = $self->base_count(
3120                                                           count_to => $start,
3121                                                           base     => $base,
3122                                                           symbols  => \@chars,
3123                                                        );
3124  ***      0                                  0         my $end_char = $self->base_count(
3125                                                           count_to => min($max, $start + $interval),
3126                                                           base     => $base,
3127                                                           symbols  => \@chars,
3128                                                        );
3129  ***      0                                  0         return $start_char, $end_char;
3130  ***      0                                  0      };
3131                                                  
3132                                                     return (
3133  ***      0                                  0         col         => $q->quote($chunk_col),
3134                                                        start_point => 0,
3135                                                        end_point   => $n_values,
3136                                                        interval    => $interval,
3137                                                        range_func  => $range_func,
3138                                                     );
3139                                                  }
3140                                                  
3141                                                  sub get_first_chunkable_column {
3142  ***      0                    0             0      my ( $self, %args ) = @_;
3143  ***      0                                  0      foreach my $arg ( qw(tbl_struct) ) {
3144  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3145                                                     }
3146                                                  
3147  ***      0                                  0      my ($exact, @cols) = $self->find_chunk_columns(%args);
3148  ***      0                                  0      my $col = $cols[0]->{column};
3149  ***      0                                  0      my $idx = $cols[0]->{index};
3150                                                  
3151  ***      0                                  0      my $wanted_col = $args{chunk_column};
3152  ***      0                                  0      my $wanted_idx = $args{chunk_index};
3153  ***      0                                  0      MKDEBUG && _d("Preferred chunk col/idx:", $wanted_col, $wanted_idx);
3154                                                  
3155  ***      0      0      0                    0      if ( $wanted_col && $wanted_idx ) {
      ***             0                               
      ***             0                               
3156  ***      0                                  0         foreach my $chunkable_col ( @cols ) {
3157  ***      0      0      0                    0            if (    $wanted_col eq $chunkable_col->{column}
3158                                                                && $wanted_idx eq $chunkable_col->{index} ) {
3159  ***      0                                  0               $col = $wanted_col;
3160  ***      0                                  0               $idx = $wanted_idx;
3161  ***      0                                  0               last;
3162                                                           }
3163                                                        }
3164                                                     }
3165                                                     elsif ( $wanted_col ) {
3166  ***      0                                  0         foreach my $chunkable_col ( @cols ) {
3167  ***      0      0                           0            if ( $wanted_col eq $chunkable_col->{column} ) {
3168  ***      0                                  0               $col = $wanted_col;
3169  ***      0                                  0               $idx = $chunkable_col->{index};
3170  ***      0                                  0               last;
3171                                                           }
3172                                                        }
3173                                                     }
3174                                                     elsif ( $wanted_idx ) {
3175  ***      0                                  0         foreach my $chunkable_col ( @cols ) {
3176  ***      0      0                           0            if ( $wanted_idx eq $chunkable_col->{index} ) {
3177  ***      0                                  0               $col = $chunkable_col->{column};
3178  ***      0                                  0               $idx = $wanted_idx;
3179  ***      0                                  0               last;
3180                                                           }
3181                                                        }
3182                                                     }
3183                                                  
3184  ***      0                                  0      MKDEBUG && _d('First chunkable col/index:', $col, $idx);
3185  ***      0                                  0      return $col, $idx;
3186                                                  }
3187                                                  
3188                                                  sub size_to_rows {
3189  ***      0                    0             0      my ( $self, %args ) = @_;
3190  ***      0                                  0      my @required_args = qw(dbh db tbl chunk_size);
3191  ***      0                                  0      foreach my $arg ( @required_args ) {
3192  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3193                                                     }
3194  ***      0                                  0      my ($dbh, $db, $tbl, $chunk_size) = @args{@required_args};
3195  ***      0                                  0      my $q  = $self->{Quoter};
3196  ***      0                                  0      my $du = $self->{MySQLDump};
3197                                                  
3198  ***      0                                  0      my ($n_rows, $avg_row_length);
3199                                                  
3200  ***      0                                  0      my ( $num, $suffix ) = $chunk_size =~ m/^(\d+)([MGk])?$/;
3201  ***      0      0                           0      if ( $suffix ) { # Convert to bytes.
      ***             0                               
3202  ***      0      0                           0         $chunk_size = $suffix eq 'k' ? $num * 1_024
      ***             0                               
3203                                                                    : $suffix eq 'M' ? $num * 1_024 * 1_024
3204                                                                    :                  $num * 1_024 * 1_024 * 1_024;
3205                                                     }
3206                                                     elsif ( $num ) {
3207  ***      0                                  0         $n_rows = $num;
3208                                                     }
3209                                                     else {
3210  ***      0                                  0         die "Invalid chunk size $chunk_size; must be an integer "
3211                                                           . "with optional suffix kMG";
3212                                                     }
3213                                                  
3214  ***      0      0      0                    0      if ( $suffix || $args{avg_row_length} ) {
3215  ***      0                                  0         my ($status) = $du->get_table_status($dbh, $q, $db, $tbl);
3216  ***      0                                  0         $avg_row_length = $status->{avg_row_length};
3217  ***      0      0                           0         if ( !defined $n_rows ) {
3218  ***      0      0                           0            $n_rows = $avg_row_length ? ceil($chunk_size / $avg_row_length) : undef;
3219                                                        }
3220                                                     }
3221                                                  
3222  ***      0                                  0      return $n_rows, $avg_row_length;
3223                                                  }
3224                                                  
3225                                                  sub get_range_statistics {
3226           5                    5            57      my ( $self, %args ) = @_;
3227           5                                 44      my @required_args = qw(dbh db tbl chunk_col tbl_struct);
3228           5                                 32      foreach my $arg ( @required_args ) {
3229  ***     25     50                         114         die "I need a $arg argument" unless $args{$arg};
3230                                                     }
3231           5                                 30      my ($dbh, $db, $tbl, $col) = @args{@required_args};
3232           5                                 16      my $where = $args{where};
3233           5                                 18      my $q     = $self->{Quoter};
3234                                                  
3235           5                                 25      my $col_type       = $args{tbl_struct}->{type_for}->{$col};
3236           5                                 22      my $col_is_numeric = $args{tbl_struct}->{is_numeric}->{$col};
3237                                                  
3238           5                                 23      my $db_tbl = $q->quote($db, $tbl);
3239           5                                 22      $col       = $q->quote($col);
3240                                                  
3241           5                                 18      my ($min, $max);
3242           5                                 19      eval {
3243  ***      5     50                          48         my $sql = "SELECT MIN($col), MAX($col) FROM $db_tbl"
      ***            50                               
3244                                                                . ($args{index_hint} ? " $args{index_hint}" : "")
3245                                                                . ($where ? " WHERE ($where)" : '');
3246           5                                 10         MKDEBUG && _d($dbh, $sql);
3247           5                                 11         ($min, $max) = $dbh->selectrow_array($sql);
3248           5                               3378         MKDEBUG && _d("Actual end points:", $min, $max);
3249                                                  
3250           5                                 73         ($min, $max) = $self->get_valid_end_points(
3251                                                           %args,
3252                                                           dbh      => $dbh,
3253                                                           db_tbl   => $db_tbl,
3254                                                           col      => $col,
3255                                                           col_type => $col_type,
3256                                                           min      => $min,
3257                                                           max      => $max,
3258                                                        );
3259           5                                 20         MKDEBUG && _d("Valid end points:", $min, $max);
3260                                                     };
3261  ***      5     50                          24      if ( $EVAL_ERROR ) {
3262  ***      0                                  0         die "Error getting min and max values for table $db_tbl "
3263                                                           . "on column $col: $EVAL_ERROR";
3264                                                     }
3265                                                  
3266  ***      5     50                          47      my $sql = "EXPLAIN SELECT * FROM $db_tbl"
      ***            50                               
3267                                                             . ($args{index_hint} ? " $args{index_hint}" : "")
3268                                                             . ($where ? " WHERE $where" : '');
3269           5                                 11      MKDEBUG && _d($sql);
3270           5                                 12      my $expl = $dbh->selectrow_hashref($sql);
3271                                                  
3272                                                     return (
3273           5                                 91         min           => $min,
3274                                                        max           => $max,
3275                                                        rows_in_range => $expl->{rows},
3276                                                     );
3277                                                  }
3278                                                  
3279                                                  sub inject_chunks {
3280  ***      0                    0             0      my ( $self, %args ) = @_;
3281  ***      0                                  0      foreach my $arg ( qw(database table chunks chunk_num query) ) {
3282  ***      0      0                           0         die "I need a $arg argument" unless defined $args{$arg};
3283                                                     }
3284  ***      0                                  0      MKDEBUG && _d('Injecting chunk', $args{chunk_num});
3285  ***      0                                  0      my $query   = $args{query};
3286  ***      0                                  0      my $comment = sprintf("/*%s.%s:%d/%d*/",
3287                                                        $args{database}, $args{table},
3288  ***      0                                  0         $args{chunk_num} + 1, scalar @{$args{chunks}});
3289  ***      0                                  0      $query =~ s!/\*PROGRESS_COMMENT\*/!$comment!;
3290  ***      0                                  0      my $where = "WHERE (" . $args{chunks}->[$args{chunk_num}] . ')';
3291  ***      0      0      0                    0      if ( $args{where} && grep { $_ } @{$args{where}} ) {
      ***      0                                  0   
      ***      0                                  0   
3292  ***      0                                  0         $where .= " AND ("
3293  ***      0                                  0            . join(" AND ", map { "($_)" } grep { $_ } @{$args{where}} )
      ***      0                                  0   
      ***      0                                  0   
3294                                                           . ")";
3295                                                     }
3296  ***      0                                  0      my $db_tbl     = $self->{Quoter}->quote(@args{qw(database table)});
3297  ***      0             0                    0      my $index_hint = $args{index_hint} || '';
3298                                                  
3299  ***      0                                  0      MKDEBUG && _d('Parameters:',
3300                                                        Dumper({WHERE => $where, DB_TBL => $db_tbl, INDEX_HINT => $index_hint}));
3301  ***      0                                  0      $query =~ s!/\*WHERE\*/! $where!;
3302  ***      0                                  0      $query =~ s!/\*DB_TBL\*/!$db_tbl!;
3303  ***      0                                  0      $query =~ s!/\*INDEX_HINT\*/! $index_hint!;
3304  ***      0                                  0      $query =~ s!/\*CHUNK_NUM\*/! $args{chunk_num} AS chunk_num,!;
3305                                                  
3306  ***      0                                  0      return $query;
3307                                                  }
3308                                                  
3309                                                  
3310                                                  sub value_to_number {
3311           2                    2            14      my ( $self, %args ) = @_;
3312           2                                  9      my @required_args = qw(column_type dbh);
3313           2                                 10      foreach my $arg ( @required_args ) {
3314  ***      4     50                          19         die "I need a $arg argument" unless defined $args{$arg};
3315                                                     }
3316           2                                  6      my $val = $args{value};
3317           2                                  9      my ($col_type, $dbh) = @args{@required_args};
3318           2                                  5      MKDEBUG && _d('Converting MySQL', $col_type, $val);
3319                                                  
3320  ***      2     50                          10      return unless defined $val;  # value is NULL
3321                                                  
3322           2                                 13      my %mysql_conv_func_for = (
3323                                                        timestamp => 'UNIX_TIMESTAMP',
3324                                                        date      => 'TO_DAYS',
3325                                                        time      => 'TIME_TO_SEC',
3326                                                        datetime  => 'TO_DAYS',
3327                                                     );
3328                                                  
3329           2                                  5      my $num;
3330  ***      2     50                          18      if ( $col_type =~ m/(?:int|year|float|double|decimal)$/ ) {
      ***             0                               
      ***             0                               
3331           2                                 12         $num = $val;
3332                                                     }
3333                                                     elsif ( $col_type =~ m/^(?:timestamp|date|time)$/ ) {
3334  ***      0                                  0         my $func = $mysql_conv_func_for{$col_type};
3335  ***      0                                  0         my $sql = "SELECT $func(?)";
3336  ***      0                                  0         MKDEBUG && _d($dbh, $sql, $val);
3337  ***      0                                  0         my $sth = $dbh->prepare($sql);
3338  ***      0                                  0         $sth->execute($val);
3339  ***      0                                  0         ($num) = $sth->fetchrow_array();
3340                                                     }
3341                                                     elsif ( $col_type eq 'datetime' ) {
3342  ***      0                                  0         $num = $self->timestampdiff($dbh, $val);
3343                                                     }
3344                                                     else {
3345  ***      0                                  0         die "I don't know how to chunk $col_type\n";
3346                                                     }
3347           2                                  5      MKDEBUG && _d('Converts to', $num);
3348           2                                 11      return $num;
3349                                                  }
3350                                                  
3351                                                  sub range_num {
3352           5                    5            22      my ( $self, $dbh, $start, $interval, $max ) = @_;
3353           5                                 30      my $end = min($max, $start + $interval);
3354                                                  
3355                                                  
3356  ***      5     50                          23      $start = sprintf('%.17f', $start) if $start =~ /e/;
3357  ***      5     50                          21      $end   = sprintf('%.17f', $end)   if $end   =~ /e/;
3358                                                  
3359           5                                 17      $start =~ s/\.(\d{5}).*$/.$1/;
3360           5                                 11      $end   =~ s/\.(\d{5}).*$/.$1/;
3361                                                  
3362  ***      5     50                          19      if ( $end > $start ) {
3363           5                                 23         return ( $start, $end );
3364                                                     }
3365                                                     else {
3366  ***      0                                  0         die "Chunk size is too small: $end !> $start\n";
3367                                                     }
3368                                                  }
3369                                                  
3370                                                  sub range_time {
3371  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
3372  ***      0                                  0      my $sql = "SELECT SEC_TO_TIME($start), SEC_TO_TIME(LEAST($max, $start + $interval))";
3373  ***      0                                  0      MKDEBUG && _d($sql);
3374  ***      0                                  0      return $dbh->selectrow_array($sql);
3375                                                  }
3376                                                  
3377                                                  sub range_date {
3378  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
3379  ***      0                                  0      my $sql = "SELECT FROM_DAYS($start), FROM_DAYS(LEAST($max, $start + $interval))";
3380  ***      0                                  0      MKDEBUG && _d($sql);
3381  ***      0                                  0      return $dbh->selectrow_array($sql);
3382                                                  }
3383                                                  
3384                                                  sub range_datetime {
3385  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
3386  ***      0                                  0      my $sql = "SELECT DATE_ADD('$self->{EPOCH}', INTERVAL $start SECOND), "
3387                                                         . "DATE_ADD('$self->{EPOCH}', INTERVAL LEAST($max, $start + $interval) SECOND)";
3388  ***      0                                  0      MKDEBUG && _d($sql);
3389  ***      0                                  0      return $dbh->selectrow_array($sql);
3390                                                  }
3391                                                  
3392                                                  sub range_timestamp {
3393  ***      0                    0             0      my ( $self, $dbh, $start, $interval, $max ) = @_;
3394  ***      0                                  0      my $sql = "SELECT FROM_UNIXTIME($start), FROM_UNIXTIME(LEAST($max, $start + $interval))";
3395  ***      0                                  0      MKDEBUG && _d($sql);
3396  ***      0                                  0      return $dbh->selectrow_array($sql);
3397                                                  }
3398                                                  
3399                                                  sub timestampdiff {
3400  ***      0                    0             0      my ( $self, $dbh, $time ) = @_;
3401  ***      0                                  0      my $sql = "SELECT (COALESCE(TO_DAYS('$time'), 0) * 86400 + TIME_TO_SEC('$time')) "
3402                                                        . "- TO_DAYS('$self->{EPOCH} 00:00:00') * 86400";
3403  ***      0                                  0      MKDEBUG && _d($sql);
3404  ***      0                                  0      my ( $diff ) = $dbh->selectrow_array($sql);
3405  ***      0                                  0      $sql = "SELECT DATE_ADD('$self->{EPOCH}', INTERVAL $diff SECOND)";
3406  ***      0                                  0      MKDEBUG && _d($sql);
3407  ***      0                                  0      my ( $check ) = $dbh->selectrow_array($sql);
3408  ***      0      0                           0      die <<"   EOF"
3409                                                     Incorrect datetime math: given $time, calculated $diff but checked to $check.
3410                                                     This could be due to a version of MySQL that overflows on large interval
3411                                                     values to DATE_ADD(), or the given datetime is not a valid date.  If not,
3412                                                     please report this as a bug.
3413                                                     EOF
3414                                                        unless $check eq $time;
3415  ***      0                                  0      return $diff;
3416                                                  }
3417                                                  
3418                                                  
3419                                                  
3420                                                  
3421                                                  sub get_valid_end_points {
3422           5                    5            92      my ( $self, %args ) = @_;
3423           5                                 34      my @required_args = qw(dbh db_tbl col col_type);
3424           5                                 23      foreach my $arg ( @required_args ) {
3425  ***     20     50                          95         die "I need a $arg argument" unless $args{$arg};
3426                                                     }
3427           5                                 31      my ($dbh, $db_tbl, $col, $col_type) = @args{@required_args};
3428           5                                 23      my ($real_min, $real_max)           = @args{qw(min max)};
3429                                                  
3430  ***      5     50                          46      my $err_fmt = "Error finding a valid %s value for table $db_tbl on "
3431                                                                 . "column $col. The real %s value %s is invalid and "
3432                                                                 . "no other valid values were found.  Verify that the table "
3433                                                                 . "has at least one valid value for this column"
3434                                                                 . ($args{where} ? " where $args{where}." : ".");
3435                                                  
3436           5                                 15      my $valid_min = $real_min;
3437           5    100                          25      if ( defined $valid_min ) {
3438           3                                  7         MKDEBUG && _d("Validating min end point:", $real_min);
3439           3                                 34         $valid_min = $self->_get_valid_end_point(
3440                                                           %args,
3441                                                           val      => $real_min,
3442                                                           endpoint => 'min',
3443                                                        );
3444  ***      3      0                          25         die sprintf($err_fmt, 'minimum', 'minimum',
      ***            50                               
3445                                                           (defined $real_min ? $real_min : "NULL"))
3446                                                           unless defined $valid_min;
3447                                                     }
3448                                                  
3449           5                                 19      my $valid_max = $real_max;
3450           5    100                          25      if ( defined $valid_max ) {
3451           3                                  7         MKDEBUG && _d("Validating max end point:", $real_min);
3452           3                                 23         $valid_max = $self->_get_valid_end_point(
3453                                                           %args,
3454                                                           val      => $real_max,
3455                                                           endpoint => 'max',
3456                                                        );
3457  ***      3      0                          16         die sprintf($err_fmt, 'maximum', 'maximum',
      ***            50                               
3458                                                           (defined $real_max ? $real_max : "NULL"))
3459                                                           unless defined $valid_max;
3460                                                     }
3461                                                  
3462           5                                 33      return $valid_min, $valid_max;
3463                                                  }
3464                                                  
3465                                                  sub _get_valid_end_point {
3466           6                    6            73      my ( $self, %args ) = @_;
3467           6                                 38      my @required_args = qw(dbh db_tbl col col_type);
3468           6                                 27      foreach my $arg ( @required_args ) {
3469  ***     24     50                         104         die "I need a $arg argument" unless $args{$arg};
3470                                                     }
3471           6                                 29      my ($dbh, $db_tbl, $col, $col_type) = @args{@required_args};
3472           6                                 21      my $val = $args{val};
3473                                                  
3474  ***      6     50                          25      return $val unless defined $val;
3475                                                  
3476  ***      6     50                          70      my $validate = $col_type =~ m/time|date/ ? \&_validate_temporal_value
3477                                                                  :                             undef;
3478                                                  
3479  ***      6     50                          29      if ( !$validate ) {
3480           6                                 13         MKDEBUG && _d("No validator for", $col_type, "values");
3481           6                                 40         return $val;
3482                                                     }
3483                                                  
3484  ***      0      0                           0      return $val if defined $validate->($dbh, $val);
3485                                                  
3486  ***      0                                  0      MKDEBUG && _d("Value is invalid, getting first valid value");
3487  ***      0                                  0      $val = $self->get_first_valid_value(
3488                                                        %args,
3489                                                        val      => $val,
3490                                                        validate => $validate,
3491                                                     );
3492                                                  
3493  ***      0                                  0      return $val;
3494                                                  }
3495                                                  
3496                                                  sub get_first_valid_value {
3497  ***      0                    0             0      my ( $self, %args ) = @_;
3498  ***      0                                  0      my @required_args = qw(dbh db_tbl col validate endpoint);
3499  ***      0                                  0      foreach my $arg ( @required_args ) {
3500  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3501                                                     }
3502  ***      0                                  0      my ($dbh, $db_tbl, $col, $validate, $endpoint) = @args{@required_args};
3503  ***      0      0                           0      my $tries = defined $args{tries} ? $args{tries} : 5;
3504  ***      0                                  0      my $val   = $args{val};
3505                                                  
3506  ***      0      0                           0      return unless defined $val;
3507                                                  
3508  ***      0      0                           0      my $cmp = $endpoint =~ m/min/i ? '>'
      ***             0                               
3509                                                             : $endpoint =~ m/max/i ? '<'
3510                                                             :                        die "Invalid endpoint arg: $endpoint";
3511  ***      0      0                           0      my $sql = "SELECT $col FROM $db_tbl "
      ***             0                               
3512                                                             . ($args{index_hint} ? "$args{index_hint} " : "")
3513                                                             . "WHERE $col $cmp ? AND $col IS NOT NULL "
3514                                                             . ($args{where} ? "AND ($args{where}) " : "")
3515                                                             . "ORDER BY $col LIMIT 1";
3516  ***      0                                  0      MKDEBUG && _d($dbh, $sql);
3517  ***      0                                  0      my $sth = $dbh->prepare($sql);
3518                                                  
3519  ***      0                                  0      my $last_val = $val;
3520  ***      0                                  0      while ( $tries-- ) {
3521  ***      0                                  0         $sth->execute($last_val);
3522  ***      0                                  0         my ($next_val) = $sth->fetchrow_array();
3523  ***      0                                  0         MKDEBUG && _d('Next value:', $next_val, '; tries left:', $tries);
3524  ***      0      0                           0         if ( !defined $next_val ) {
3525  ***      0                                  0            MKDEBUG && _d('No more rows in table');
3526  ***      0                                  0            last;
3527                                                        }
3528  ***      0      0                           0         if ( defined $validate->($dbh, $next_val) ) {
3529  ***      0                                  0            MKDEBUG && _d('First valid value:', $next_val);
3530  ***      0                                  0            $sth->finish();
3531  ***      0                                  0            return $next_val;
3532                                                        }
3533  ***      0                                  0         $last_val = $next_val;
3534                                                     }
3535  ***      0                                  0      $sth->finish();
3536  ***      0                                  0      $val = undef;  # no valid value found
3537                                                  
3538  ***      0                                  0      return $val;
3539                                                  }
3540                                                  
3541                                                  sub _validate_temporal_value {
3542  ***      0                    0             0      my ( $dbh, $val ) = @_;
3543  ***      0                                  0      my $sql = "SELECT IF(TIME_FORMAT(?,'%H:%i:%s')=?, TIME_TO_SEC(?), TO_DAYS(?))";
3544  ***      0                                  0      my $res;
3545  ***      0                                  0      eval {
3546  ***      0                                  0         MKDEBUG && _d($dbh, $sql, $val);
3547  ***      0                                  0         my $sth = $dbh->prepare($sql);
3548  ***      0                                  0         $sth->execute($val, $val, $val, $val);
3549  ***      0                                  0         ($res) = $sth->fetchrow_array();
3550  ***      0                                  0         $sth->finish();
3551                                                     };
3552  ***      0      0                           0      if ( $EVAL_ERROR ) {
3553  ***      0                                  0         MKDEBUG && _d($EVAL_ERROR);
3554                                                     }
3555  ***      0                                  0      return $res;
3556                                                  }
3557                                                  
3558                                                  sub get_nonzero_value {
3559  ***      0                    0             0      my ( $self, %args ) = @_;
3560  ***      0                                  0      my @required_args = qw(dbh db_tbl col col_type);
3561  ***      0                                  0      foreach my $arg ( @required_args ) {
3562  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3563                                                     }
3564  ***      0                                  0      my ($dbh, $db_tbl, $col, $col_type) = @args{@required_args};
3565  ***      0      0                           0      my $tries = defined $args{tries} ? $args{tries} : 5;
3566  ***      0                                  0      my $val   = $args{val};
3567                                                  
3568                                                     my $is_nonzero = $col_type =~ m/time|date/ ? \&_validate_temporal_value
3569  ***      0      0             0             0                     :                             sub { return $_[1]; };
      ***      0                                  0   
3570                                                  
3571  ***      0      0                           0      if ( !$is_nonzero->($dbh, $val) ) {  # quasi-double-negative, sorry
3572  ***      0                                  0         MKDEBUG && _d('Discarding zero value:', $val);
3573  ***      0      0                           0         my $sql = "SELECT $col FROM $db_tbl "
      ***             0                               
3574                                                                . ($args{index_hint} ? "$args{index_hint} " : "")
3575                                                                . "WHERE $col > ? AND $col IS NOT NULL "
3576                                                                . ($args{where} ? "AND ($args{where}) " : '')
3577                                                                . "ORDER BY $col LIMIT 1";
3578  ***      0                                  0         MKDEBUG && _d($sql);
3579  ***      0                                  0         my $sth = $dbh->prepare($sql);
3580                                                  
3581  ***      0                                  0         my $last_val = $val;
3582  ***      0                                  0         while ( $tries-- ) {
3583  ***      0                                  0            $sth->execute($last_val);
3584  ***      0                                  0            my ($next_val) = $sth->fetchrow_array();
3585  ***      0      0                           0            if ( $is_nonzero->($dbh, $next_val) ) {
3586  ***      0                                  0               MKDEBUG && _d('First non-zero value:', $next_val);
3587  ***      0                                  0               $sth->finish();
3588  ***      0                                  0               return $next_val;
3589                                                           }
3590  ***      0                                  0            $last_val = $next_val;
3591                                                        }
3592  ***      0                                  0         $sth->finish();
3593  ***      0                                  0         $val = undef;  # no non-zero value found
3594                                                     }
3595                                                  
3596  ***      0                                  0      return $val;
3597                                                  }
3598                                                  
3599                                                  sub base_count {
3600  ***      0                    0             0      my ( $self, %args ) = @_;
3601  ***      0                                  0      my @required_args = qw(count_to base symbols);
3602  ***      0                                  0      foreach my $arg ( @required_args ) {
3603  ***      0      0                           0         die "I need a $arg argument" unless defined $args{$arg};
3604                                                     }
3605  ***      0                                  0      my ($n, $base, $symbols) = @args{@required_args};
3606                                                  
3607  ***      0      0                           0      return $symbols->[0] if $n == 0;
3608                                                  
3609  ***      0                                  0      my $highest_power = floor(log($n)/log($base));
3610  ***      0      0                           0      if ( $highest_power == 0 ){
3611  ***      0                                  0         return $symbols->[$n];
3612                                                     }
3613                                                  
3614  ***      0                                  0      my @base_powers;
3615  ***      0                                  0      for my $power ( 0..$highest_power ) {
3616  ***      0             0                    0         push @base_powers, ($base**$power) || 1;  
3617                                                     }
3618                                                  
3619  ***      0                                  0      my @base_multiples;
3620  ***      0                                  0      foreach my $base_power ( reverse @base_powers ) {
3621  ***      0                                  0         my $multiples = floor($n / $base_power);
3622  ***      0                                  0         push @base_multiples, $multiples;
3623  ***      0                                  0         $n -= $multiples * $base_power;
3624                                                     }
3625                                                  
3626  ***      0                                  0      return join('', map { $symbols->[$_] } @base_multiples);
      ***      0                                  0   
3627                                                  }
3628                                                  
3629                                                  sub _d {
3630  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3631  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3632  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3633                                                          @_;
3634  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3635                                                  }
3636                                                  
3637                                                  1;
3638                                                  
3639                                                  # ###########################################################################
3640                                                  # End TableChunker package
3641                                                  # ###########################################################################
3642                                                  
3643                                                  # ###########################################################################
3644                                                  # Progress package 7096
3645                                                  # This package is a copy without comments from the original.  The original
3646                                                  # with comments and its test file can be found in the SVN repository at,
3647                                                  #   trunk/common/Progress.pm
3648                                                  #   trunk/common/t/Progress.t
3649                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
3650                                                  # ###########################################################################
3651                                                  package Progress;
3652                                                  
3653           3                    3            34   use strict;
               3                                  9   
               3                                 26   
3654           3                    3            19   use warnings FATAL => 'all';
               3                                  9   
               3                                 24   
3655                                                  
3656           3                    3            22   use English qw(-no_match_vars);
               3                                 11   
               3                                 25   
3657           3                    3            22   use Data::Dumper;
               3                                  7   
               3                                 18   
3658                                                  $Data::Dumper::Indent    = 1;
3659                                                  $Data::Dumper::Sortkeys  = 1;
3660                                                  $Data::Dumper::Quotekeys = 0;
3661                                                  
3662  ***      3            50      3            24   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  7   
               3                                 47   
3663                                                  
3664                                                  sub new {
3665           5                    5            61      my ( $class, %args ) = @_;
3666           5                                 34      foreach my $arg (qw(jobsize)) {
3667  ***      5     50                          34         die "I need a $arg argument" unless defined $args{$arg};
3668                                                     }
3669  ***      5     50     33                   34      if ( (!$args{report} || !$args{interval}) ) {
3670  ***      5     50     33                   34         if ( $args{spec} && @{$args{spec}} == 2 ) {
               5                                 43   
3671           5                                 15            @args{qw(report interval)} = @{$args{spec}};
               5                                 49   
3672                                                        }
3673                                                        else {
3674  ***      0                                  0            die "I need either report and interval arguments, or a spec";
3675                                                        }
3676                                                     }
3677                                                  
3678  ***      5            50                   32      my $name  = $args{name} || "Progress";
3679  ***      5            33                   33      $args{start} ||= time();
3680           5                                 12      my $self;
3681                                                     $self = {
3682                                                        last_reported => $args{start},
3683                                                        fraction      => 0,       # How complete the job is
3684                                                        callback      => sub {
3685  ***      0                    0             0            my ($fraction, $elapsed, $remaining, $eta) = @_;
3686  ***      0                                  0            printf STDERR "$name: %3d%% %s remain\n",
3687                                                              $fraction * 100,
3688                                                              Transformers::secs_to_time($remaining),
3689                                                              Transformers::ts($eta);
3690                                                        },
3691           5                                 97         %args,
3692                                                     };
3693           5                                 64      return bless $self, $class;
3694                                                  }
3695                                                  
3696                                                  sub validate_spec {
3697  ***      7     50             7            43      shift @_ if $_[0] eq 'Progress'; # Permit calling as Progress-> or Progress::
3698           7                                 26      my ( $spec ) = @_;
3699  ***      7     50                          32      if ( @$spec != 2 ) {
3700  ***      0                                  0         die "spec array requires a two-part argument\n";
3701                                                     }
3702  ***      7     50                          78      if ( $spec->[0] !~ m/^(?:percentage|time|iterations)$/ ) {
3703  ***      0                                  0         die "spec array's first element must be one of "
3704                                                          . "percentage,time,iterations\n";
3705                                                     }
3706  ***      7     50                          65      if ( $spec->[1] !~ m/^\d+$/ ) {
3707  ***      0                                  0         die "spec array's second element must be an integer\n";
3708                                                     }
3709                                                  }
3710                                                  
3711                                                  sub set_callback {
3712  ***      0                    0             0      my ( $self, $callback ) = @_;
3713  ***      0                                  0      $self->{callback} = $callback;
3714                                                  }
3715                                                  
3716                                                  sub start {
3717  ***      0                    0             0      my ( $self, $start ) = @_;
3718  ***      0             0                    0      $self->{start} = $self->{last_reported} = $start || time();
3719                                                  }
3720                                                  
3721                                                  sub update {
3722           7                    7            44      my ( $self, $callback, $now ) = @_;
3723           7                                 36      my $jobsize   = $self->{jobsize};
3724  ***      7            33                   44      $now        ||= time();
3725           7                                 30      $self->{iterations}++; # How many updates have happened;
3726                                                  
3727  ***      7     50     33                  138      if ( $self->{report} eq 'time'
      ***             0      0                        
3728                                                           && $self->{interval} > $now - $self->{last_reported}
3729                                                     ) {
3730           7                                 25         return;
3731                                                     }
3732                                                     elsif ( $self->{report} eq 'iterations'
3733                                                           && ($self->{iterations} - 1) % $self->{interval} > 0
3734                                                     ) {
3735  ***      0                                  0         return;
3736                                                     }
3737  ***      0                                  0      $self->{last_reported} = $now;
3738                                                  
3739  ***      0                                  0      my $completed = $callback->();
3740  ***      0                                  0      $self->{updates}++; # How many times we have run the update callback
3741                                                  
3742  ***      0      0                           0      return if $completed > $jobsize;
3743                                                  
3744  ***      0      0                           0      my $fraction = $completed > 0 ? $completed / $jobsize : 0;
3745                                                  
3746  ***      0      0      0                    0      if ( $self->{report} eq 'percentage'
3747                                                           && $self->fraction_modulo($self->{fraction})
3748                                                              >= $self->fraction_modulo($fraction)
3749                                                     ) {
3750  ***      0                                  0         $self->{fraction} = $fraction;
3751  ***      0                                  0         return;
3752                                                     }
3753  ***      0                                  0      $self->{fraction} = $fraction;
3754                                                  
3755  ***      0                                  0      my $elapsed   = $now - $self->{start};
3756  ***      0                                  0      my $remaining = 0;
3757  ***      0                                  0      my $eta       = $now;
3758  ***      0      0      0                    0      if ( $completed > 0 && $completed <= $jobsize && $elapsed > 0 ) {
      ***                    0                        
3759  ***      0                                  0         my $rate = $completed / $elapsed;
3760  ***      0      0                           0         if ( $rate > 0 ) {
3761  ***      0                                  0            $remaining = ($jobsize - $completed) / $rate;
3762  ***      0                                  0            $eta       = $now + int($remaining);
3763                                                        }
3764                                                     }
3765  ***      0                                  0      $self->{callback}->($fraction, $elapsed, $remaining, $eta, $completed);
3766                                                  }
3767                                                  
3768                                                  sub fraction_modulo {
3769  ***      0                    0             0      my ( $self, $num ) = @_;
3770  ***      0                                  0      $num *= 100; # Convert from fraction to percentage
3771  ***      0                                  0      return sprintf('%d',
3772                                                        sprintf('%d', $num / $self->{interval}) * $self->{interval});
3773                                                  }
3774                                                  
3775                                                  sub _d {
3776  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3777  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3778  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3779                                                          @_;
3780  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3781                                                  }
3782                                                  
3783                                                  1;
3784                                                  
3785                                                  # ###########################################################################
3786                                                  # End Progress package
3787                                                  # ###########################################################################
3788                                                  
3789                                                  # ###########################################################################
3790                                                  # OSCCaptureSync package 7463
3791                                                  # This package is a copy without comments from the original.  The original
3792                                                  # with comments and its test file can be found in the SVN repository at,
3793                                                  #   trunk/common/OSCCaptureSync.pm
3794                                                  #   trunk/common/t/OSCCaptureSync.t
3795                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
3796                                                  # ###########################################################################
3797                                                  
3798                                                  package OSCCaptureSync;
3799                                                  
3800           3                    3            34   use strict;
               3                                  9   
               3                                 18   
3801           3                    3            19   use warnings FATAL => 'all';
               3                                  6   
               3                                 17   
3802           3                    3            20   use English qw(-no_match_vars);
               3                                  6   
               3                                 20   
3803  ***      3            50      3            21   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                 15   
               3                                 40   
3804                                                  
3805                                                  sub new {
3806           7                    7            37      my ( $class, %args ) = @_;
3807           7                                 29      my @required_args = qw();
3808           7                                 42      foreach my $arg ( @required_args ) {
3809  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3810                                                     }
3811                                                  
3812           7                                 34      my $self = {
3813                                                        %args,
3814                                                     };
3815                                                  
3816           7                                 76      return bless $self, $class;
3817                                                  }
3818                                                  
3819                                                  sub capture {
3820           3                    3            91      my ( $self, %args ) = @_;
3821           3                                 25      my @required_args = qw(msg dbh db tbl tmp_tbl columns chunk_column);
3822           3                                 21      foreach my $arg ( @required_args ) {
3823  ***     21     50                          97         die "I need a $arg argument" unless $args{$arg};
3824                                                     }
3825           3                                 17      my ($msg, $dbh) = @args{@required_args};
3826                                                  
3827           3                                 33      my @triggers = $self->_make_triggers(%args);
3828           3                                 16      foreach my $sql ( @triggers ) {
3829           9                                 82         $msg->($sql);
3830  ***      9     50                      730907         $dbh->do($sql) unless $args{print};
3831                                                     }
3832                                                  
3833           3                                105      return;
3834                                                  }
3835                                                  
3836                                                  sub _make_triggers {
3837           3                    3            44      my ( $self, %args ) = @_;
3838           3                                 23      my @required_args = qw(db tbl tmp_tbl chunk_column columns);
3839           3                                 16      foreach my $arg ( @required_args ) {
3840  ***     15     50                          68         die "I need a $arg argument" unless $args{$arg};
3841                                                     }
3842           3                                 23      my ($db, $tbl, $tmp_tbl, $chunk_column) = @args{@required_args};
3843                                                  
3844           3                                 19      my $old_table  = "`$db`.`$tbl`";
3845           3                                 15      my $new_table  = "`$db`.`$tmp_tbl`";
3846           3                                 11      my $new_values = join(', ', map { "NEW.$_" } @{$args{columns}});
               9                                 37   
               3                                 14   
3847           3                                 10      my $columns    = join(', ', @{$args{columns}});
               3                                 14   
3848                                                  
3849           3                                 38      my $delete_trigger = "CREATE TRIGGER mk_osc_del AFTER DELETE ON $old_table "
3850                                                                        . "FOR EACH ROW "
3851                                                                        . "DELETE IGNORE FROM $new_table "
3852                                                                        . "WHERE $new_table.$chunk_column = OLD.$chunk_column";
3853                                                  
3854           3                                 31      my $insert_trigger = "CREATE TRIGGER mk_osc_ins AFTER INSERT ON $old_table "
3855                                                                        . "FOR EACH ROW "
3856                                                                        . "REPLACE INTO $new_table ($columns) "
3857                                                                        . "VALUES($new_values)";
3858                                                  
3859           3                                 25      my $update_trigger = "CREATE TRIGGER mk_osc_upd AFTER UPDATE ON $old_table "
3860                                                                        . "FOR EACH ROW "
3861                                                                        . "REPLACE INTO $new_table ($columns) "
3862                                                                        . "VALUES ($new_values)";
3863                                                  
3864           3                                 28      return $delete_trigger, $update_trigger, $insert_trigger;
3865                                                  }
3866                                                  
3867                                                  sub sync {
3868           3                    3            51      my ( $self, %args ) = @_;
3869           3                                 18      my @required_args = qw();
3870           3                                 20      foreach my $arg ( @required_args ) {
3871  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
3872                                                     }
3873           3                                 16      return;
3874                                                  }
3875                                                  
3876                                                  sub cleanup {
3877           4                    4            46      my ( $self, %args ) = @_;
3878           4                                 32      my @required_args = qw(dbh db msg);
3879           4                                 22      foreach my $arg ( @required_args ) {
3880  ***     12     50                          63         die "I need a $arg argument" unless $args{$arg};
3881                                                     }
3882           4                                 22      my ($dbh, $db, $msg) = @args{@required_args};
3883                                                  
3884           4                                 18      foreach my $trigger ( qw(del ins upd) ) {
3885          12                                105         my $sql = "DROP TRIGGER IF EXISTS `$db`.`mk_osc_$trigger`";
3886          12                                 76         $msg->($sql);
3887  ***     12     50                      295897         $dbh->do($sql) unless $args{print};
3888                                                     }
3889                                                  
3890           4                                 56      return;
3891                                                  }
3892                                                  
3893                                                  sub _d {
3894  ***      0                    0             0      my ($package, undef, $line) = caller 0;
3895  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
3896  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
3897                                                          @_;
3898  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
3899                                                  }
3900                                                  
3901                                                  1;
3902                                                  
3903                                                  # ###########################################################################
3904                                                  # End OSCCaptureSync package
3905                                                  # ###########################################################################
3906                                                  
3907                                                  # ###########################################################################
3908                                                  # CopyRowsInsertSelect package 7464
3909                                                  # This package is a copy without comments from the original.  The original
3910                                                  # with comments and its test file can be found in the SVN repository at,
3911                                                  #   trunk/common/CopyRowsInsertSelect.pm
3912                                                  #   trunk/common/t/CopyRowsInsertSelect.t
3913                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
3914                                                  # ###########################################################################
3915                                                  
3916                                                  package CopyRowsInsertSelect;
3917                                                  
3918           3                    3            25   use strict;
               3                                  8   
               3                                 15   
3919           3                    3            18   use warnings FATAL => 'all';
               3                                  6   
               3                                 17   
3920           3                    3            19   use English qw(-no_match_vars);
               3                                  8   
               3                                 32   
3921  ***      3            50      3            23   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  6   
               3                                 91   
3922                                                  
3923                                                  sub new {
3924           7                    7            50      my ( $class, %args ) = @_;
3925           7                                 29      my @required_args = qw(Retry);
3926           7                                 33      foreach my $arg ( @required_args ) {
3927  ***      7     50                          48         die "I need a $arg argument" unless $args{$arg};
3928                                                     }
3929                                                  
3930           7                                 34      my $self = {
3931                                                        %args,
3932                                                     };
3933                                                  
3934           7                                 84      return bless $self, $class;
3935                                                  }
3936                                                  
3937                                                  sub copy {
3938           3                    3            99      my ( $self, %args ) = @_;
3939           3                                 31      my @required_args = qw(dbh msg from_table to_table chunks columns);
3940           3                                 21      foreach my $arg ( @required_args ) {
3941  ***     18     50                          85         die "I need a $arg argument" unless $args{$arg};
3942                                                     }
3943           3                                 21      my ($dbh, $msg, $from_table, $to_table, $chunks) = @args{@required_args};
3944           3                                 12      my $pr       = $args{Progress};
3945           3                                 12      my $sleep    = $args{sleep};
3946           3                                 11      my $columns  = join(', ', @{$args{columns}});
               3                                 17   
3947           3                                 16      my $n_chunks = @$chunks - 1;
3948                                                  
3949           3                                 15      for my $chunkno ( 0..$n_chunks ) {
3950  ***      7     50                          49         if ( !$chunks->[$chunkno] ) {
3951  ***      0                                  0            warn "Chunk number ", ($chunkno + 1), "is undefined";
3952  ***      0                                  0            next;
3953                                                        }
3954                                                  
3955  ***      7     50                         120         my $sql = "INSERT IGNORE INTO $to_table ($columns) "
      ***            50                               
3956                                                                . "SELECT $columns FROM $from_table "
3957                                                                . "WHERE ($chunks->[$chunkno])"
3958                                                                . ($args{where}        ? " AND ($args{where})"  : "")
3959                                                                . ($args{engine_flags} ? " $args{engine_flags}" : "");
3960                                                  
3961  ***      7     50                          40         if ( $args{print} ) {
3962  ***      0                                  0            $msg->($sql);
3963                                                        }
3964                                                        else {
3965           7                                 25            MKDEBUG && _d($dbh, $sql);
3966           7                                 21            my $error;
3967                                                           $self->{Retry}->retry(
3968           1                    1        1000147               wait  => sub { sleep 1; },
3969                                                              tries => 3,
3970                                                              try   => sub {
3971           8                    8            51                  my ( %args ) = @_;
3972           8                                 28                     eval {
3973           8                             712738                        $dbh->do($sql);
3974                                                                    };
3975           8    100                          84                     if ( $EVAL_ERROR ) {
3976           1                                  4                        MKDEBUG && _d($EVAL_ERROR);
3977  ***      1     50                          21                        if ( $EVAL_ERROR =~ m/Lock wait timeout exceeded/ ) {
3978           1                                  5                           $error = $EVAL_ERROR;
3979  ***      1     50                           8                           if ( $args{tryno} > 1 ) {
3980  ***      0                                  0                              $msg->("Lock wait timeout exceeded; retrying $sql");
3981                                                                          }
3982           1                                 12                           return;
3983                                                                       }
3984  ***      0                                  0                        die $EVAL_ERROR;
3985                                                                    }
3986           7                                 99                     return 1;
3987                                                              },
3988  ***      0                    0             0               on_failure => sub { die $error; },
3989           7                                150            );
3990                                                        }
3991                                                  
3992  ***      7     50             0           237         $pr->update(sub { return $chunkno + 1; }) if $pr;
      ***      0                                  0   
3993                                                  
3994  ***      7     50     33                   62         $sleep->($chunkno + 1) if $sleep && $chunkno < $n_chunks;
3995                                                     }
3996                                                  
3997           3                                 43      return;
3998                                                  }
3999                                                  
4000                                                  sub cleanup {
4001           4                    4            96      my ( $self, %args ) = @_;
4002           4                                 32      return;
4003                                                  }
4004                                                  
4005                                                  sub _d {
4006  ***      0                    0             0      my ($package, undef, $line) = caller 0;
4007  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
4008  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
4009                                                          @_;
4010  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4011                                                  }
4012                                                  
4013                                                  1;
4014                                                  
4015                                                  # ###########################################################################
4016                                                  # End CopyRowsInsertSelect package
4017                                                  # ###########################################################################
4018                                                  
4019                                                  # ###########################################################################
4020                                                  # Retry package 7465
4021                                                  # This package is a copy without comments from the original.  The original
4022                                                  # with comments and its test file can be found in the SVN repository at,
4023                                                  #   trunk/common/Retry.pm
4024                                                  #   trunk/common/t/Retry.t
4025                                                  # See http://code.google.com/p/maatkit/wiki/Developers for more information.
4026                                                  # ###########################################################################
4027                                                  
4028                                                  package Retry;
4029                                                  
4030           3                    3            25   use strict;
               3                                 13   
               3                                 14   
4031           3                    3            18   use warnings FATAL => 'all';
               3                                  6   
               3                                 15   
4032           3                    3            22   use English qw(-no_match_vars);
               3                                  9   
               3                                 15   
4033  ***      3            50      3            24   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  8   
               3                                 40   
4034                                                  
4035                                                  sub new {
4036           7                    7            34      my ( $class, %args ) = @_;
4037           7                                 30      my $self = {
4038                                                        %args,
4039                                                     };
4040           7                                124      return bless $self, $class;
4041                                                  }
4042                                                  
4043                                                  sub retry {
4044           7                    7            76      my ( $self, %args ) = @_;
4045           7                                 40      my @required_args = qw(try wait);
4046           7                                 33      foreach my $arg ( @required_args ) {
4047  ***     14     50                          75         die "I need a $arg argument" unless $args{$arg};
4048                                                     };
4049           7                                 33      my ($try, $wait) = @args{@required_args};
4050  ***      7            50                   32      my $tries = $args{tries} || 3;
4051                                                  
4052           7                                 24      my $tryno = 0;
4053           7                                 42      while ( ++$tryno <= $tries ) {
4054           8                                 28         MKDEBUG && _d("Retry", $tryno, "of", $tries);
4055           8                                 27         my $result;
4056           8                                 32         eval {
4057           8                                 43            $result = $try->(tryno=>$tryno);
4058                                                        };
4059                                                  
4060           8    100                          49         if ( defined $result ) {
4061           7                                 16            MKDEBUG && _d("Try code succeeded");
4062  ***      7     50                          43            if ( my $on_success = $args{on_success} ) {
4063  ***      0                                  0               MKDEBUG && _d("Calling on_success code");
4064  ***      0                                  0               $on_success->(tryno=>$tryno, result=>$result);
4065                                                           }
4066           7                                 67            return $result;
4067                                                        }
4068                                                  
4069  ***      1     50                           5         if ( $EVAL_ERROR ) {
4070  ***      0                                  0            MKDEBUG && _d("Try code died:", $EVAL_ERROR);
4071  ***      0      0                           0            die $EVAL_ERROR unless $args{retry_on_die};
4072                                                        }
4073                                                  
4074  ***      1     50                           5         if ( $tryno < $tries ) {
4075           1                                  3            MKDEBUG && _d("Try code failed, calling wait code");
4076           1                                  7            $wait->(tryno=>$tryno);
4077                                                        }
4078                                                     }
4079                                                  
4080  ***      0                                  0      MKDEBUG && _d("Try code did not succeed");
4081  ***      0      0                           0      if ( my $on_failure = $args{on_failure} ) {
4082  ***      0                                  0         MKDEBUG && _d("Calling on_failure code");
4083  ***      0                                  0         $on_failure->();
4084                                                     }
4085                                                  
4086  ***      0                                  0      return;
4087                                                  }
4088                                                  
4089                                                  sub _d {
4090  ***      0                    0             0      my ($package, undef, $line) = caller 0;
4091  ***      0      0                           0      @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                  0   
      ***      0                                  0   
4092  ***      0                                  0           map { defined $_ ? $_ : 'undef' }
4093                                                          @_;
4094  ***      0                                  0      print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4095                                                  }
4096                                                  
4097                                                  1;
4098                                                  
4099                                                  # ###########################################################################
4100                                                  # End Retry package
4101                                                  # ###########################################################################
4102                                                  
4103                                                  # ###########################################################################
4104                                                  # This is a combination of modules and programs in one -- a runnable module.
4105                                                  # http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
4106                                                  # Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
4107                                                  #
4108                                                  # Check at the end of this package for the call to main() which actually runs
4109                                                  # the program.
4110                                                  # ###########################################################################
4111                                                  package mk_online_schema_change;
4112                                                  
4113           3                    3            22   use English qw(-no_match_vars);
               3                                  8   
               3                                 16   
4114           3                    3            19   use Time::HiRes qw(sleep);
               3                                  7   
               3                                 26   
4115           3                    3            20   use Data::Dumper;
               3                                  7   
               3                                 16   
4116                                                  $Data::Dumper::Indent    = 1;
4117                                                  $Data::Dumper::Sortkeys  = 1;
4118                                                  $Data::Dumper::Quotekeys = 0;
4119                                                  
4120                                                  Transformers->import qw(ts);
4121                                                  
4122  ***      3            50      3            19   use constant MKDEBUG => $ENV{MKDEBUG} || 0;
               3                                  7   
               3                                 38   
4123                                                  
4124                                                  my $quiet = 0;  # for msg()
4125                                                  
4126                                                  sub main {
4127           7                    7        216277      @ARGV       = @_;  # set global ARGV for this package
4128           7                                153      my $vp      = new VersionParser();
4129           7                                106      my $q       = new Quoter();
4130           7                                120      my $tp      = new TableParser(Quoter => $q);
4131           7                                110      my $du      = new MySQLDump();
4132           7                                107      my $chunker = new TableChunker(Quoter => $q, MySQLDump => $du);
4133                                                  
4134                                                     # ########################################################################
4135                                                     # Get configuration information.
4136                                                     # ########################################################################
4137           7                                115      my $o = new OptionParser();
4138           7                                 49      $o->get_specs();
4139           7                                113      $o->get_opts();
4140                                                  
4141           7                                 38      my $dp = $o->DSNParser();
4142           7                                 34      $dp->prop('set-vars', $o->get('set-vars'));
4143                                                  
4144           7                                 27      $quiet = $o->get('quiet');  # for msg()
4145                                                  
4146           7                                 25      my ($dsn, $db, $tbl);
4147           7                                 25      $dsn = shift @ARGV;
4148  ***      7     50                          31      if ( !$dsn ) {
4149  ***      0                                  0         $o->save_error('A DSN with a t part must be specified');
4150                                                     }
4151                                                     else {
4152           7                                 61         $dsn = $dp->parse($dsn, $dp->parse_options($o));
4153  ***      7     50                          40         if ( !$dsn->{t} ) {
4154  ***      0                                  0            $o->save_error('The DSN must specify a t (table) part');
4155                                                        }
4156                                                        else {
4157  ***      7            50                  100            ($db, $tbl) = $q->split_unquote($dsn->{t} || "", $dsn->{D} || "");
      ***                   50                        
4158                                                        }
4159                                                     }
4160                                                  
4161           7                                 35      my $rename_fk_method = lc $o->get('update-foreign-keys-method');
4162           7    100    100                  160      if ( ($rename_fk_method || '') eq 'drop_old_table' ) {
4163           1                                 13         $o->set('rename-tables',  0);
4164           1                                  5         $o->set('drop-old-table', 0),
4165                                                     }
4166                                                  
4167  ***      7     50                          28      if ( !$o->get('help') ) {
4168  ***      7     50                          30         if ( @ARGV ) {
4169  ***      0                                  0            $o->save_error('Specify only one DSN on the command line');
4170                                                        }
4171                                                  
4172  ***      7     50                          27         if ( !$db ) {
4173  ***      0                                  0            $o->save_error("No database was specified in the DSN or by "
4174                                                              . "--database (-D)");
4175                                                        }
4176                                                  
4177  ***      7     50     50                   61         if ( $tbl && $tbl eq ($o->get('tmp-table') || "") ) {
      ***                   33                        
4178  ***      0                                  0            $o->save_error("--tmp-table cannot be the same as the table");
4179                                                        }
4180                                                  
4181  ***      7     50                          28         if ( $o->get('progress') ) {
4182           7                                 22            eval { Progress->validate_spec($o->get('progress')) };
               7                                 29   
4183  ***      7     50                          28            if ( $EVAL_ERROR ) {
4184  ***      0                                  0               chomp $EVAL_ERROR;
4185  ***      0                                  0               $o->save_error("--progress $EVAL_ERROR");
4186                                                           }
4187                                                        }
4188                                                  
4189  ***      7     50     66                   35         if ( $o->get('child-tables') && !$o->get('update-foreign-keys-method') ) {
4190  ***      0                                  0            $o->save_error("--child-tables requires --update-foreign-keys-method");
4191                                                        }
4192                                                  
4193  ***      7     50    100                   64         if ( $rename_fk_method
      ***                   66                        
4194                                                             && $rename_fk_method ne 'rebuild_constraints'
4195                                                             && $rename_fk_method ne 'drop_old_table' ) {
4196  ***      0                                  0            $o->save_error("Invalid --update-foreign-keys-method value");
4197                                                        }
4198                                                     }
4199                                                  
4200           7                                 51      $o->usage_or_errors();
4201                                                  
4202           7                                 83      msg("$PROGRAM_NAME started");
4203           7                                 31      my $exit_status = 0;
4204                                                  
4205                                                     # ########################################################################
4206                                                     # Connect to MySQL.
4207                                                     # ########################################################################
4208           7                                 48      my $dbh = get_cxn(
4209                                                        dsn          => $dsn,
4210                                                        DSNParser    => $dp,
4211                                                        OptionParser => $o,
4212                                                        AutoCommit   => 1,
4213                                                     );
4214           7                                 50      msg("USE `$db`");
4215           7                               1294      $dbh->do("USE `$db`");
4216                                                  
4217                                                     # ########################################################################
4218                                                     # Daemonize only after (potentially) asking for passwords for --ask-pass.
4219                                                     # ########################################################################
4220           7                                 27      my $daemon;
4221  ***      7     50                          45      if ( $o->get('pid') ) {
4222                                                        # We're not daemoninzing, it just handles PID stuff.
4223  ***      0                                  0         $daemon = new Daemon(o=>$o);
4224  ***      0                                  0         $daemon->make_PID_file();
4225                                                     }
4226                                                  
4227                                                     # ########################################################################
4228                                                     # Setup/init some vars.
4229                                                     # ########################################################################
4230  ***      7            33                   30      my $tmp_tbl = $o->get('tmp-table') || "__tmp_$tbl";
4231           7                                 29      my $old_tbl = "__old_$tbl"; # what tbl becomes after swapped with tmp tbl
4232           7                                 76      my %tables  = (
4233                                                        db      => $db,
4234                                                        tbl     => $tbl,
4235                                                        tmp_tbl => $tmp_tbl,
4236                                                        old_tbl => $old_tbl,
4237                                                     );
4238           7                                 44      msg("Alter table $tbl using temporary table $tmp_tbl");
4239                                                  
4240           7                                 72      my %common_modules = (
4241                                                        OptionParser  => $o,
4242                                                        DSNParser     => $dp,
4243                                                        Quoter        => $q,
4244                                                        TableParser   => $tp,
4245                                                        TableChunker  => $chunker,
4246                                                        MySQLDump     => $du,
4247                                                        VersionParser => $vp,
4248                                                     );
4249                                                  
4250                                                     # ########################################################################
4251                                                     # Create the capture-sync and copy-rows plugins.  Currently, we just have
4252                                                     # one method for each.
4253                                                     # ########################################################################
4254           7                                114      my $capture_sync = new OSCCaptureSync();
4255           7                                100      my $copy_rows    = new CopyRowsInsertSelect(Retry => new Retry());
4256                                                  
4257                                                     # More values are added later.  These are the minimum need to do --cleanup.
4258           7                                 49      my %plugin_args = (
4259                                                        dbh   => $dbh,
4260                                                        msg   => \&msg,  # so plugin can talk back to user
4261                                                        print => $o->get('print'),
4262                                                        %tables,
4263                                                        %common_modules,
4264                                                     );
4265                                                  
4266  ***      7     50                          46      if ( my $sleep_time = $o->get('sleep') ) {
4267  ***      0                                  0         MKDEBUG && _d("Sleep time:", $sleep_time);
4268                                                        $plugin_args{sleep} = sub {
4269  ***      0                    0             0            my ( $chunkno ) = @_;
4270  ***      0                                  0            MKDEBUG && _d("Sleeping after chunk", $chunkno);
4271  ***      0                                  0            sleep($sleep_time);
4272  ***      0                                  0         };
4273                                                     }
4274                                                  
4275                                                     # ########################################################################
4276                                                     # Just cleanup and exit.
4277                                                     # ########################################################################
4278           7    100                          32      if ( $o->get('cleanup-and-exit') ) {
4279           1                                  7         msg("Calling " . (ref $copy_rows). "::cleanup()");
4280           1                                 13         $copy_rows->cleanup(%plugin_args);
4281                                                  
4282           1                                  7         msg("Calling " . (ref $capture_sync) . "::cleanup()");
4283           1                                 11         $capture_sync->cleanup(%plugin_args);
4284                                                  
4285           1                                  9         msg("$PROGRAM_NAME ending for --cleanup-and-exit");
4286           1                                286         return 0;
4287                                                     }
4288                                                  
4289                                                     # ########################################################################
4290                                                     # Check that table can be altered.
4291                                                     # ########################################################################
4292           6                                 18      my %tbl_info;
4293           6                                 19      eval {
4294           6                                 62         %tbl_info = check_tables(%plugin_args);
4295                                                     };
4296  ***      6     50                          39      if ( $EVAL_ERROR ) {
4297  ***      0                                  0         chomp $EVAL_ERROR;
4298  ***      0                                  0         msg("Table $tbl cannot be altered: $EVAL_ERROR");
4299  ***      0                                  0         return 1;
4300                                                     }
4301                                                  
4302           6                                 43      @plugin_args{keys %tbl_info} = values %tbl_info;
4303           6                                 43      msg("Table $tbl can be altered");
4304           6                                 40      msg("Chunk column $plugin_args{chunk_column}, index $plugin_args{chunk_index}");
4305                                                  
4306           6    100                          40      if ( $o->get('check-tables-and-exit') ) {
4307           1                                  6         msg("$PROGRAM_NAME ending for --check-tables-and-exit");
4308           1                                209         return 0;
4309                                                     }
4310                                                  
4311                                                     # #####################################################################
4312                                                     # Chunk the table.  If the checks pass, then this shouldn't fail.
4313                                                     # #####################################################################
4314           5                                 80      my %range_stats = $chunker->get_range_statistics(
4315                                                        dbh        => $dbh,
4316                                                        db         => $db,
4317                                                        tbl        => $tbl,
4318                                                        chunk_col  => $plugin_args{chunk_column},
4319                                                        tbl_struct => $plugin_args{tbl_struct},
4320                                                     );
4321           5                                 53      my @chunks = $chunker->calculate_chunks(
4322                                                        dbh        => $dbh,
4323                                                        db         => $db,
4324                                                        tbl        => $tbl,
4325                                                        chunk_col  => $plugin_args{chunk_column},
4326                                                        tbl_struct => $plugin_args{tbl_struct},
4327                                                        chunk_size => $o->get('chunk-size'),
4328                                                        %range_stats,
4329                                                     );
4330           5                                 28      $plugin_args{chunks}   = \@chunks;
4331           5                                 27      $plugin_args{Progress} = new Progress(
4332                                                        jobsize => scalar @chunks,
4333                                                        spec    => $o->get('progress'),
4334                                                        name    => "Copying rows",
4335                                                     );
4336           5                                 39      msg("Chunked table $tbl into " . scalar @chunks . " chunks");
4337                                                  
4338                                                     # #####################################################################
4339                                                     # Get child tables if necessary.
4340                                                     # #####################################################################
4341           5                                 17      my @child_tables;
4342           5    100                          22      if ( my $child_tables = $o->get('child-tables') ) {
4343  ***      2     50                          17         if ( lc $child_tables eq 'auto_detect' ) {
4344           2                                 16            msg("Auto-detecting child tables of $tbl");
4345           2                                 24            @child_tables = get_child_tables(%plugin_args);
4346  ***      2      0                          11            msg("Child tables of $tables{old_table}: "
4347                                                              .  (@child_tables ? join(', ', @child_tables) : "(none)"));
4348                                                        }
4349                                                        else {
4350  ***      0                                  0            @child_tables = split(',', $child_tables);
4351  ***      0                                  0            msg("User-specified child tables: " . join(', ', @child_tables));
4352                                                        }
4353                                                     }
4354                                                  
4355                                                     # #####################################################################
4356                                                     # Do the online alter.
4357                                                     # #####################################################################
4358           3                                 18      msg("Beginning online schema change");
4359           3                                 10      eval {
4360           3                                 13         my $sql = "";
4361                                                        
4362                                                        # #####################################################################
4363                                                        # Create and alter the new table.
4364                                                        # #####################################################################
4365  ***      3     50                          13         if ( $o->get('create-tmp-table') ) {
4366           3                                 20            $sql = "CREATE TABLE `$db`.`$tmp_tbl` LIKE `$db`.`$tbl`";
4367           3                                 10            msg($sql);
4368  ***      3     50                          13            $dbh->do($sql) unless $o->get('print');
4369                                                        }
4370                                                  
4371           3    100                          52         if ( my $alter = $o->get('alter') ) {
4372           2                                  6            my @stmts;
4373  ***      2     50     33                   35            if ( -f $alter && -r $alter ) {
4374  ***      0                                  0               msg("Reading ALTER TABLE statements from file $alter");
4375  ***      0      0                           0               open my $fh, '<', $alter or die "Cannot open $alter: $OS_ERROR";
4376  ***      0                                  0               @stmts = <$fh>;
4377  ***      0                                  0               close $fh;
4378                                                           }
4379                                                           else {
4380           2                                 26               @stmts = split(';', $alter);
4381                                                           }
4382                                                  
4383           2                                 16            foreach my $stmt ( @stmts ) {
4384           2                                 19               $sql = "ALTER TABLE `$db`.`$tmp_tbl` $stmt";
4385           2                                 11               msg($sql);
4386  ***      2     50                          11               $dbh->do($sql) unless $o->get('print');
4387                                                           } 
4388                                                        }
4389                                                  
4390                                                        # #####################################################################
4391                                                        # Determine what columns the two tables have in common.
4392                                                        # #####################################################################
4393           3                                 26         my @columns;
4394                                                        # If --print is in effect, then chances are the new table wasn't
4395                                                        # created above, so we can't get it's struct.
4396                                                        # TODO: check if the new table exists because user might have created
4397                                                        # it manually.
4398  ***      3     50                          40         if ( !$o->get('print') ) {
4399           3                                 25            my $tmp_tbl_struct = $tp->parse(
4400                                                                 $du->get_create_table($dbh, $q, $db, $tmp_tbl));
4401                                                  
4402           3                                 36            @columns = intersection([
4403                                                              $plugin_args{tbl_struct}->{is_col},
4404                                                              $tmp_tbl_struct->{is_col},
4405                                                           ]);
4406                                                  
4407                                                           # Order columns according to new table because people like/expect
4408                                                           # to see things in a certain order (this has been an issue before).
4409                                                           # This just matters to us; does't make a difference to MySQL.
4410           3                                 17            my $col_posn = $plugin_args{tbl_struct}->{col_posn};
4411           3                                  7            @columns = sort { $col_posn->{$a} <=> $col_posn->{$b} } @columns;
               6                                 22   
4412           3                                 30            msg("Shared columns: " . join(', ', @columns));
4413                                                        }
4414           3                                 19         $plugin_args{columns} = \@columns;
4415                                                  
4416                                                        # #####################################################################
4417                                                        # Start capturing changes to the new table.
4418                                                        # #####################################################################
4419           3                                 27         msg("Calling " . (ref $capture_sync) . "::capture()");
4420           3                                 43         $capture_sync->capture(%plugin_args);
4421                                                  
4422                                                        # #####################################################################
4423                                                        # Copy rows from new table to old table.
4424                                                        # #####################################################################
4425           3                                 72         msg("Calling " . (ref $copy_rows) . "::copy()");
4426           3                                 32         $copy_rows->copy(
4427                                                           from_table => $q->quote($db, $tbl),
4428                                                           to_table   => $q->quote($db, $tmp_tbl),
4429                                                           %plugin_args
4430                                                        );
4431                                                  
4432                                                        # #####################################################################
4433                                                        # Sync tables.
4434                                                        # #####################################################################
4435           3                                 55         msg("Calling " . (ref $capture_sync) . "::sync()");
4436           3                                 39         $capture_sync->sync(%plugin_args);
4437                                                  
4438                                                        # #####################################################################
4439                                                        # Rename tables.
4440                                                        # #####################################################################
4441  ***      3     50                          23         if ( $o->get('rename-tables') ) {
4442           3                                 13            msg("Renaming tables");
4443           3                                 32            $sql = "RENAME TABLE `$db`.`$tbl` TO `$db`.`$old_tbl`,"
4444                                                                . " `$db`.`$tmp_tbl` TO `$db`.`$tbl`";
4445           3                                 11            msg($sql);
4446  ***      3     50                          14            $dbh->do($sql) unless $o->get('print');
4447           3                                 77            msg("Original table $tbl renamed to $old_tbl");
4448                                                        }
4449                                                  
4450                                                        # #####################################################################
4451                                                        # Update foreign key constraints if there are child tables.
4452                                                        # #####################################################################
4453  ***      3     50                          24         if ( @child_tables ) {
4454  ***      0                                  0            msg("Renaming foreign key constraints in child table");
4455  ***      0      0                           0            if ( $rename_fk_method eq 'rebuild_constraints' ) { 
      ***             0                               
4456  ***      0                                  0               update_foreign_key_constraints(
4457                                                                 child_tables => \@child_tables,
4458                                                                 %plugin_args,
4459                                                              );
4460                                                           }
4461                                                           elsif ( $rename_fk_method eq 'drop_old_table' ) {
4462  ***      0                                  0               $sql = "SET foreign_key_checks=0";
4463  ***      0                                  0               msg($sql);
4464  ***      0      0                           0               $dbh->do($sql) unless $o->get('print');
4465                                                              
4466  ***      0                                  0               $sql = "DROP TABLE `$db`.`$tbl`";
4467  ***      0                                  0               msg($sql);
4468  ***      0      0                           0               $dbh->do($sql) unless $o->get('print');
4469                                                  
4470  ***      0                                  0               $sql = "RENAME TABLE `$db`.`$tmp_tbl` TO `$db`.`$tbl`";
4471  ***      0                                  0               msg($sql);
4472  ***      0      0                           0               $dbh->do($sql) unless $o->get('print');
4473                                                           }
4474                                                           else {
4475  ***      0                                  0               die "Invalid --update-foreign-keys-method value: $rename_fk_method";
4476                                                           }
4477                                                        }
4478                                                  
4479                                                        # #####################################################################
4480                                                        # Cleanup.
4481                                                        # #####################################################################
4482           3                                 33         msg("Calling " . (ref $copy_rows). "::cleanup()");
4483           3                                 51         $copy_rows->cleanup(%plugin_args);
4484                                                  
4485           3                                 27         msg("Calling " . (ref $capture_sync) . "::cleanup()");
4486           3                                 32         $capture_sync->cleanup(%plugin_args);
4487                                                  
4488  ***      3    100     66                   39         if ( $o->get('rename-tables') &&  $o->get('drop-old-table') ) {
4489           2                                 28            $sql = "DROP TABLE `$db`.`$old_tbl`";
4490           2                                 15            msg($sql);
4491  ***      2     50                          16            $dbh->do($sql) unless $o->get('print');
4492                                                        }
4493                                                     };
4494  ***      3     50                          21      if ( $EVAL_ERROR ) {
4495  ***      0                                  0         warn "An error occurred:\n\n$EVAL_ERROR\n"
4496                                                           . "Some triggers, temp tables, etc. may not have been removed. "
4497                                                           . "Run with --cleanup-and-exit to remove these items.\n";
4498  ***      0                                  0         $exit_status = 1;
4499                                                     }
4500                                                  
4501           3                                134      msg("$PROGRAM_NAME ended, exit status $exit_status");
4502           3                                782      return $exit_status;
4503                                                  }
4504                                                  
4505                                                  # ############################################################################
4506                                                  # Subroutines.
4507                                                  # ############################################################################
4508                                                  sub check_tables {
4509          12                   12        119326      my ( %args ) = @_;
4510          12                                123      my @required_args = qw(dbh db tbl tmp_tbl old_tbl VersionParser Quoter TableParser OptionParser TableChunker MySQLDump);
4511          12                                 63      foreach my $arg ( @required_args ) {
4512  ***    132     50                         655         die "I need a $arg argument" unless $args{$arg};
4513                                                     }
4514          12                                101      my ($dbh, $db, $tbl, $tmp_tbl, $old_tbl, $o, $tp)
4515                                                        = @args{qw(dbh db tbl tmp_tbl old_tbl OptionParser TableParser)};
4516                                                  
4517          12                                 70      msg("Checking if table $tbl can be altered");
4518          12                                 35      my %tbl_info;
4519          12                                 39      my $sql = "";
4520                                                  
4521                                                     # ########################################################################
4522                                                     # Check MySQL.
4523                                                     # ########################################################################   
4524                                                     # Although triggers were introduced in 5.0.2, "Prior to MySQL 5.0.10,
4525                                                     # triggers cannot contain direct references to tables by name."
4526  ***     12     50                          99      if ( !$args{VersionParser}->version_ge($dbh, '5.0.10') ) {
4527  ***      0                                  0         die "This tool requires MySQL 5.0.10 or newer\n";
4528                                                     }
4529                                                  
4530                                                     # ########################################################################
4531                                                     # Check the (original) table.
4532                                                     # ########################################################################
4533                                                     # The table must exist of course.
4534          12    100                         109      if ( !$tp->check_table(dbh=>$dbh, db=>$db, tbl=>$tbl) ) {
4535           1                                  3         die "Table $db.$tbl does not exist\n";
4536                                                     }
4537                                                  
4538                                                     # There cannot be any triggers on the table.
4539          11                                 62      $sql = "SHOW TRIGGERS FROM `$db` LIKE '$tbl'";
4540          11                                 46      msg($sql);
4541          11                                 27      my $triggers = $dbh->selectall_arrayref($sql);
4542  ***     11    100     66                 6042      if ( $triggers && @$triggers ) {
4543           1                                  3         die "Table $db.$tbl has triggers.  This tool needs to create "
4544                                                           . "its own triggers, so the table cannot already have triggers.\n";
4545                                                     }
4546                                                  
4547                                                     # If we're going to rename the tables, which we do by default, then
4548                                                     # the old table cannot already exist.
4549          10    100                          78      if ( $o->get('rename-tables') ) {
4550           9    100                          54         if ( $tp->check_table(dbh=>$dbh, db=>$db, tbl=>$old_tbl) ) {
4551           1                                  3            die "Table $db.$old_tbl exists which will prevent $db.$tbl "
4552                                                              . "from being renamed to it.  Table $db.$old_tbl could be from "
4553                                                              . "a previous run that failed.  See --drop-old-table for more "
4554                                                              . "information.\n";
4555                                                        }
4556                                                     }
4557                                                  
4558                                                     # For now, we require that the old table has an exact-chunkable
4559                                                     # column (i.e. unique single-column).
4560           9                                103      $tbl_info{tbl_struct} = $tp->parse(
4561                                                        $args{MySQLDump}->get_create_table($dbh, $args{Quoter}, $db, $tbl));
4562           9                                129      my ($exact, @chunkable_cols) = $args{TableChunker}->find_chunk_columns(
4563                                                        tbl_struct => $tbl_info{tbl_struct},
4564                                                        exact      => 1,
4565                                                     );
4566  ***      9    100     66                   99      if ( !$exact || !@chunkable_cols ) {
4567           1                                  4         die "Table $db.$tbl cannot be chunked because it does not have "
4568                                                           . "a unique, single-column index\n";
4569                                                     }
4570           8                                 44      $tbl_info{chunk_column} = $chunkable_cols[0]->{column};
4571           8                                 45      $tbl_info{chunk_index}  = $chunkable_cols[0]->{index};
4572                                                  
4573                                                     # ########################################################################
4574                                                     # Check the tmp table.
4575                                                     # ########################################################################   
4576                                                     # The tmp table should not exist if we're supposed to create it.
4577                                                     # Else, if user specifies --no-create-tmp-table, they should ensure
4578                                                     # that it exists.
4579  ***      8    100     66                   46      if ( $o->get('create-tmp-table')
4580                                                          && $tp->check_table(dbh=>$dbh, db=>$db, tbl=>$tmp_tbl) ) {
4581           1                                  3         die "Temporary table $db.$tmp_tbl exists.  Drop it and try again.\n";
4582                                                     }
4583                                                  
4584           7                                115      return %tbl_info;
4585                                                  }
4586                                                  
4587                                                  sub get_child_tables {
4588           2                    2            30      my ( %args ) = @_;
4589           2                                 14      my @required_args = qw(dbh db tbl Quoter);
4590           2                                 16      foreach my $arg ( @required_args ) {
4591  ***      8     50                          38         die "I need a $arg argument" unless $args{$arg};
4592                                                     }
4593           2                                 12      my ($dbh, $db, $tbl, $q) = @args{@required_args};
4594                                                  
4595           2                                 15      my $sql = "SELECT table_name "
4596                                                             . "FROM information_schema.key_column_usage "
4597                                                             . "WHERE constraint_schema='$db' AND referenced_table_name='$tbl'";
4598           2                                  4      MKDEBUG && _d($dbh, $sql);
4599           2                                  8      my $child_tables;
4600           2                                  7      eval {
4601           2                                  5         $child_tables = $dbh->selectall_arrayref($sql);
4602                                                     };
4603  ***      2     50                       39787      if ( $EVAL_ERROR ) {
4604  ***      0                                  0         die "Error executing query to check $tbl for child tables.\n\n"
4605                                                           . "Query: $sql\n\n"
4606                                                           . "Error: $EVAL_ERROR"
4607                                                     }
4608                                                  
4609           2                                  6      MKDEBUG && _d("Child tables:", join(', ', map { $_->[0] } @$child_tables));
4610           2                                 12      return map { $_->[0] } @$child_tables;
               2                                 45   
4611                                                  }
4612                                                  
4613                                                  sub update_foreign_key_constraints {
4614  ***      0                    0             0      my ( %args ) = @_;
4615  ***      0                                  0      my @required_args = qw(msg dbh db tbl old_tbl child_tables Quoter);
4616  ***      0                                  0      foreach my $arg ( @required_args ) {
4617  ***      0      0                           0         die "I need a $arg argument" unless $args{$arg};
4618                                                     }
4619  ***      0                                  0      my ($msg, $dbh, $db, $tbl, $old_tbl, $child_tables, $q)
4620                                                        = @args{@required_args};
4621                                                  
4622  ***      0                                  0      my $constraint = qr/^\s+(CONSTRAINT.+?REFERENCES `$old_tbl`.+)$/mo;
4623                                                  
4624                                                     CHILD_TABLE:
4625  ***      0                                  0      foreach my $child_table ( @$child_tables ) {
4626  ***      0                                  0         my $sql = "SHOW CREATE TABLE `$db`.`$child_table`";
4627  ***      0                                  0         MKDEBUG && _d($dbh, $sql);
4628  ***      0                                  0         $msg->($sql);
4629  ***      0                                  0         my $table_def;
4630  ***      0                                  0         eval {
4631  ***      0                                  0            $table_def = $dbh->selectrow_arrayref($sql)->[1];
4632                                                        };
4633  ***      0      0                           0         if ( $EVAL_ERROR ) {
4634  ***      0                                  0            warn "Skipping child table $child_table: $EVAL_ERROR";
4635  ***      0                                  0            next CHILD_TABLE;
4636                                                        }
4637                                                  
4638  ***      0                                  0         my @constraints = $table_def =~ m/$constraint/g;
4639  ***      0      0                           0         if ( !@constraints ) {
4640  ***      0                                  0            warn "Child table `$child_table` does not have any foreign key "
4641                                                              . "constraints referencing $old_tbl";
4642  ***      0                                  0            next CHILD_TABLE;
4643                                                        }
4644                                                  
4645  ***      0                                  0         foreach my $constraint ( @constraints ) {
4646  ***      0                                  0            my ($fk_symbol) = $constraint =~ m/CONSTRAINT\s+(\S+)/;
4647  ***      0                                  0            $sql = "ALTER TABLE `$db`.`$child_table` DROP FOREIGN KEY $fk_symbol";
4648  ***      0                                  0            $msg->($sql);
4649  ***      0      0                           0            $dbh->do($sql) unless $args{print};
4650                                                  
4651  ***      0                                  0            $constraint =~ s/REFERENCES `$old_tbl`/REFERENCES `$tbl`/o;
4652  ***      0                                  0            $sql = "ALTER TABLE `$db`.`$child_table` ADD $constraint"; 
4653  ***      0                                  0            $msg->($sql);
4654  ***      0      0                           0            $dbh->do($sql) unless $args{print};
4655                                                        }
4656                                                     }
4657                                                  
4658  ***      0                                  0      return;
4659                                                  }
4660                                                  
4661                                                  sub intersection {
4662           3                    3            15      my ( $hashes ) = @_;
4663           3                                 11      my %keys     = map { $_ => 1 } keys %{$hashes->[0]};
               9                                 37   
               3                                 18   
4664           3                                 16      my $n_hashes = (scalar @$hashes) - 1;
4665           3                                 15      my @isect    = grep { $keys{$_} } map { keys %{$hashes->[$_]} } 1..$n_hashes;
               9                                 35   
               3                                  7   
               3                                 18   
4666           3                                 22      return @isect;
4667                                                  }
4668                                                  
4669                                                  sub get_cxn {
4670           7                    7            72      my ( %args ) = @_;
4671           7                                 69      my ($dsn, $ac, $dp, $o) = @args{qw(dsn AutoCommit DSNParser OptionParser)};
4672                                                  
4673  ***      7     50                          37      if ( $o->get('ask-pass') ) {
4674  ***      0                                  0         $dsn->{p} = OptionParser::prompt_noecho("Enter password: "); 
4675                                                     }
4676           7                                 65      my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), {AutoCommit => $ac});
4677                                                  
4678  ***      7     50                          57      $dbh->do('SET SQL_LOG_BIN=0') unless $o->get('bin-log');
4679  ***      7     50                          32      $dbh->do('SET FOREIGN_KEY_CHECKS=0') unless $o->get('foreign-key-checks');
4680                                                  
4681           7                                 44      return $dbh;
4682                                                  }
4683                                                  
4684                                                  sub msg {
4685         128                  128           662      my ( $msg ) = @_;
4686         128                                461      chomp $msg;
4687         128    100                         928      print '# ', ts(time), " $msg\n" unless $quiet;
4688         128                                331      MKDEBUG && _d($msg);
4689         128                                377      return;
4690                                                  }
4691                                                  
4692                                                  # Only for tests which may not call main().
4693                                                  sub __set_quiet {
4694           1                    1            10      $quiet = $_[0];
4695                                                  }
4696                                                  
4697                                                  sub _d {
4698  ***      0                    0                    my ($package, undef, $line) = caller 0;
4699  ***      0      0                                  @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
      ***      0                                      
      ***      0                                      
4700  ***      0                                              map { defined $_ ? $_ : 'undef' }
4701                                                          @_;
4702  ***      0                                         print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
4703                                                  }
4704                                                  
4705                                                  # ############################################################################
4706                                                  # Run the program.
4707                                                  # ############################################################################
4708                                                  if ( !caller ) { exit main(@ARGV); }
4709                                                  
4710                                                  1; # Because this is a module as well as a script.
4711                                                  
4712                                                  # ############################################################################
4713                                                  # Documentation
4714                                                  # ############################################################################
4715                                                  =pod
4716                                                  
4717                                                  =head1 NAME
4718                                                  
4719                                                  mk-online-schema-change - Perform online, non-blocking table schema changes.
4720                                                  
4721                                                  =head1 SYNOPSIS
4722                                                  
4723                                                  Usage: mk-online-schema-change [OPTION...] DSN
4724                                                  
4725                                                  mk-online-schema-change performs online, non-blocking schema changes to a table.
4726                                                  The table to change must be specified in the DSN C<t> part, like C<t=my_table>.
4727                                                  The table can be database-qualified, or the database can be specified with the
4728                                                  L<"--database"> option.
4729                                                  
4730                                                  Change the table's engine to InnoDB:
4731                                                  
4732                                                    mk-online-schema-change                            \
4733                                                      h=127.1,t=db.tbl                                 \
4734                                                      --alter-table "ALTER TABLE db.tbl ENGINE=InnoDB" \
4735                                                      --drop-tmp-table
4736                                                  
4737                                                  Rebuild but do not alter the table, and keep the temporary table:
4738                                                  
4739                                                    mk-online-schema-change h=127.1,t=tbl --database db
4740                                                  
4741                                                  Add column to parent table, update child table foreign key constraints:
4742                                                  
4743                                                    mk-online-schema-change                                   \
4744                                                      h=127.1,D=db,t=parent                                   \
4745                                                      --alter-table 'ALTER TABLE parent ADD COLUMN (foo INT)' \
4746                                                      --child-tables child1,child2                            \
4747                                                      --update-foreign-keys-method drop_tmp_table
4748                                                  
4749                                                  =head1 RISKS
4750                                                  
4751                                                  The following section is included to inform users about the potential risks,
4752                                                  whether known or unknown, of using this tool.  The two main categories of risks
4753                                                  are those created by the nature of the tool (e.g. read-only tools vs. read-write
4754                                                  tools) and those created by bugs.
4755                                                  
4756                                                  mk-online-schema-change reads, writes, alters and drops tables.  Although
4757                                                  it is tested, do not use it in production until you have thoroughly tested it
4758                                                  in your environment!
4759                                                  
4760                                                  This tool has not been tested with replication; it may break replication.
4761                                                  
4762                                                  At the time of this release there are no known bugs that pose a serious risk.
4763                                                  
4764                                                  The authoritative source for updated information is always the online issue
4765                                                  tracking system.  Issues that affect this tool will be marked as such.  You can
4766                                                  see a list of such issues at the following URL:
4767                                                  L<http://www.maatkit.org/bugs/mk-online-schema-change>.
4768                                                  
4769                                                  See also L<"BUGS"> for more information on filing bugs and getting help.
4770                                                  
4771                                                  =head1 DESCRIPTION
4772                                                  
4773                                                  mk-online-schema-change performs online, non-blocking schema changes to tables.
4774                                                  Only one table can be altered at a time because triggers are used to capture
4775                                                  and synchronize changes between the table and the temporary table that
4776                                                  will take its place once it has been altered.  Since triggers are used, this
4777                                                  tool only works with MySQL 5.0.2 and newer.
4778                                                  
4779                                                  The table to alter is specified by the DSN C<t> part on the command line,
4780                                                  as shown in the L<"SYNOPSIS"> examples.  A databse must also be specified
4781                                                  either by the DSN C<D> part or by the L<"--database"> option.
4782                                                  
4783                                                  In brief, this tool works by creating a temporary table which is a copy of
4784                                                  the original table (the one being altered).  (The temporary table is not
4785                                                  created like C<CREATE TEMPORARY TABLE>; we call it temporary because it
4786                                                  ultimately replaces the original table.)  The temporary table is altered,
4787                                                  then triggers are defined on the original table to capture changes made on
4788                                                  it and apply them to the temporary table.  This keeps the two tables in
4789                                                  sync.  Then all rows are copied from the original table to the temporary
4790                                                  table; this part can take awhile.  When done copying rows, the two tables
4791                                                  are swapped by using C<RENAME TABLE>.  At this point there are two copies
4792                                                  of the table: the old table which used to be the original table, and the
4793                                                  new table which used to be the temporary table but now has the same name
4794                                                  as the original table.  If L<"--drop-old-table"> is specified, the table
4795                                                  with the old schema is dropped.
4796                                                  
4797                                                  For example, if you alter table C<foo>, the tool will create table
4798                                                  C<__tmp_foo>, alter it, define triggers on C<foo>, and then copy rows
4799                                                  from C<foo> to C<__tmp_foo>.  Once all rows are copied, C<foo> is renamed
4800                                                  to C<__old_foo> and C<__tmp_foo> is renamed to C<foo>.
4801                                                  If L<"--drop-old-table"> is specified, then C<__old_foo> is dropped.
4802                                                  
4803                                                  The tool preforms the following steps:
4804                                                  
4805                                                    1. Sanity checks
4806                                                    2. Chunking
4807                                                    3. Online schema change
4808                                                  
4809                                                  The first two steps cannot be skipped.  The sanity checks help ensure that
4810                                                  running the tool will work and not encounter problems half way through the
4811                                                  whole process.  Chunk is required during the third step when rows from the
4812                                                  old table are copied to the new table.  Currently, only table with a
4813                                                  single-column unique index can be chunked.  If there is any problem in these
4814                                                  two steps, the tool will die.
4815                                                  
4816                                                  Most of the tool's work is done in the third step which has 6 phases:
4817                                                  
4818                                                    1. Create and alter temporary table
4819                                                    2. Capture changes from the table to the temporary table
4820                                                    3. Copy rows from the table to the temporary table
4821                                                    4. Synchronize the table and the temporary table
4822                                                    5. Swap/rename the table and the temporary table
4823                                                    6. Cleanup
4824                                                  
4825                                                  There are several ways to accomplish an online schema change which differ
4826                                                  in how changes are captured and synced (phases 2 and 4), how rows are copied
4827                                                  (phase 3), and how the tables are swapped (phase 5).  Currently, this tool
4828                                                  employs synchronous triggers (Shlomi's method), C<INSERT-SELECT>, and
4829                                                  C<RENAME TABLE> respectively for these phases.
4830                                                  
4831                                                  Here are options related to each phase:
4832                                                  
4833                                                    1. --[no]create-tmp-table, --alter, --tmp-table
4834                                                    2. (none)
4835                                                    3. --chunk-size, --sleep
4836                                                    4. (none)
4837                                                    5. --[no]rename-tables
4838                                                    6. --drop-old-table
4839                                                  
4840                                                  Options L<"--check-tables-and-exit"> and L<"--print"> are helpful to see what
4841                                                  the tool might do before actually doing it.
4842                                                  
4843                                                  =head1 OUTPUT
4844                                                  
4845                                                  Output to STDOUT is very verbose and should tell you everything that the
4846                                                  tool is doing.  Warnings, errors, and L<"--progress"> are printed to STDERR.
4847                                                  
4848                                                  =head1 OPTIONS
4849                                                  
4850                                                  This tool accepts additional command-line arguments.  Refer to the
4851                                                  L<"SYNOPSIS"> and usage information for details.
4852                                                  
4853                                                  =over
4854                                                  
4855                                                  =item --alter
4856                                                  
4857                                                  type: string
4858                                                  
4859                                                  Semicolon-separated list of C<ALTER TABLE> statements to apply to the new table.
4860                                                  The statements should not contain C<ALTER TABLE>, just what would follow that
4861                                                  clause.  For example, if you want to C<ALTER TABLE ENGINE=InnoDB>, the value
4862                                                  would be C<ENGINE=InnoDB>.
4863                                                  
4864                                                  The value can also be a filename which contains statements, one per line
4865                                                  with no blank lines.  Each statement will be applied in the order it appears
4866                                                  in the file.
4867                                                  
4868                                                  =item --ask-pass
4869                                                  
4870                                                  Prompt for a password when connecting to MySQL.
4871                                                  
4872                                                  =item --[no]bin-log
4873                                                  
4874                                                  default: yes
4875                                                  
4876                                                  Allow binary logging (C<SET SQL_LOG_BIN=1>).  Specifying C<--no-bin-log>
4877                                                  will C<SET SQL_LOG_BIN=0> and prevent queries executed by this tool from
4878                                                  being replicated.
4879                                                  
4880                                                  =item --charset
4881                                                  
4882                                                  short form: -A; type: string
4883                                                  
4884                                                  Default character set.  If the value is utf8, sets Perl's binmode on
4885                                                  STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and runs SET
4886                                                  NAMES UTF8 after connecting to MySQL.  Any other value sets binmode on STDOUT
4887                                                  without the utf8 layer, and runs SET NAMES after connecting to MySQL.
4888                                                  
4889                                                  =item --check-tables-and-exit
4890                                                  
4891                                                  Check that the table can be altered then exit; do not alter the table.
4892                                                  If you just want to see that the tool can/will work for the given table,
4893                                                  specify this option.  Even if all checks pass, the tool may still encounter
4894                                                  problems if, for example, one of the L<"--alter"> statements uses
4895                                                  incorrect syntax.
4896                                                  
4897                                                  =item --child-tables
4898                                                  
4899                                                  type: string
4900                                                  
4901                                                  Foreign key constraints in these (child) tables reference the old table.
4902                                                  If the old table being altered is a parent to tables which reference it with
4903                                                  foreign key constraints, you must specify those child tables with this option
4904                                                  so that the tool will update the foreign key constraints after renaming
4905                                                  tables.  The list of child tables is comma-separated, not quoted, and not
4906                                                  database-qualified (the database is assumed to be the same as the old table)
4907                                                  If you specify a table that doesn't exist, it is ignored.
4908                                                  
4909                                                  Or you can specify just C<auto_detect> and the tool will query the
4910                                                  C<INFORMATION_SCHEMA> to auto-detect any foreign key constraints on the
4911                                                  old table.
4912                                                  
4913                                                  When specifying this option, you must also specify
4914                                                  L<"--update-foreign-keys-method">.
4915                                                  
4916                                                  =item --chunk-size
4917                                                  
4918                                                  type: string; default: 1000
4919                                                  
4920                                                  Number of rows or data size per chunk.  Data sizes are specified with a
4921                                                  suffix of k=kibibytes, M=mebibytes, G=gibibytes.  Data sizes are converted
4922                                                  to a number of rows by dividing by the average row length.
4923                                                  
4924                                                  =item --cleanup-and-exit
4925                                                  
4926                                                  Cleanup and exit; do not alter the table.  If a previous run fails, you
4927                                                  may need to use this option to remove any temp tables, triggers,
4928                                                  outfiles, etc. that where left behind before another run will succeed.
4929                                                  
4930                                                  =item --config
4931                                                  
4932                                                  type: Array
4933                                                  
4934                                                  Read this comma-separated list of config files; if specified, this must be the
4935                                                  first option on the command line.
4936                                                  
4937                                                  =item --[no]create-tmp-table
4938                                                  
4939                                                  default: yes
4940                                                  
4941                                                  Create the new table with C<CREATE TABLE LIKE>.  The new table to which
4942                                                  the L<"--alter"> statements are applied is automatically created
4943                                                  by default.  If you want to create it manually before running this tool,
4944                                                  then you need to specify C<--no-create-tmp-table> B<and> L<"--tmp-table">
4945                                                  so the tool will use your new table.
4946                                                  
4947                                                  =item --daemonize
4948                                                  
4949                                                  Fork to the background and detach from the shell.  POSIX operating systems
4950                                                  only.
4951                                                  
4952                                                  =item --database
4953                                                  
4954                                                  short form: -D; type: string
4955                                                  
4956                                                  Database for the old and new table.  The new table can only be created
4957                                                  inside the same database as the old (original) table.  You can also specify
4958                                                  the database with the C<D> part of the DSN given on the command line.
4959                                                  
4960                                                  =item --defaults-file
4961                                                  
4962                                                  short form: -F; type: string
4963                                                  
4964                                                  Only read mysql options from the given file.  You must give an absolute
4965                                                  pathname.
4966                                                  
4967                                                  =item --drop-old-table
4968                                                  
4969                                                  Drop the old (original) table.  By default, the old table is not dropped
4970                                                  after the new table has taken its place.  In case of problems, the old
4971                                                  table may be needed.  When this option is specified, the old table is dropped
4972                                                  after (if) everything finishes successfully.  If there is a problem,
4973                                                  both table (old/original and new/altered) will probably be left.
4974                                                  
4975                                                  If altering a table with foreign key constraints, you may need to specify
4976                                                  this option depending on which L<"--update-foreign-keys-method"> you choose.
4977                                                  
4978                                                  =item --[no]foreign-key-checks
4979                                                  
4980                                                  default: yes
4981                                                  
4982                                                  Enforce foreign key checks (FOREIGN_KEY_CHECKS=1).
4983                                                  
4984                                                  =item --help
4985                                                  
4986                                                  Show help and exit.
4987                                                  
4988                                                  =item --host
4989                                                  
4990                                                  short form: -h; type: string
4991                                                  
4992                                                  Connect to host.
4993                                                  
4994                                                  =item --log
4995                                                  
4996                                                  type: string
4997                                                  
4998                                                  Print all output to this file when daemonized.
4999                                                  
5000                                                  =item --tmp-table
5001                                                  
5002                                                  type: string
5003                                                  
5004                                                  Table name for new table until renamed to old (original) table name.
5005                                                  If you specify C<--no-create-tmp-table>, then you must also use this option
5006                                                  to specify the name of the new table.  By default, when the tool automatically
5007                                                  creates the new table, the new table name is C<__new_OLD_TABLE_NAME> where
5008                                                  C<OLD_TABLE_NAME> is the old (original) table named specified by the DSN's
5009                                                  C<t> part.  The new and old tables are eventually swapped, if
5010                                                  C<"--[no]rename-tables"> is specified (it is by default).
5011                                                  
5012                                                  =item --password
5013                                                  
5014                                                  short form: -p; type: string
5015                                                  
5016                                                  Password to use when connecting.
5017                                                  
5018                                                  =item --pid
5019                                                  
5020                                                  type: string
5021                                                  
5022                                                  Create the given PID file when daemonized.  The file contains the process ID of
5023                                                  the daemonized instance.  The PID file is removed when the daemonized instance
5024                                                  exits.  The program checks for the existence of the PID file when starting; if
5025                                                  it exists and the process with the matching PID exists, the program exits.
5026                                                  
5027                                                  =item --port
5028                                                  
5029                                                  short form: -P; type: int
5030                                                  
5031                                                  Port number to use for connection.
5032                                                  
5033                                                  =item --print
5034                                                  
5035                                                  Print SQL statements to STDOUT instead of executing them.  Specifying this
5036                                                  option allows you to see most of the statements that the tool would execute.
5037                                                  
5038                                                  =item --progress
5039                                                  
5040                                                  type: array; default: time,30
5041                                                  
5042                                                  Print progress reports to STDERR while copying rows.
5043                                                  
5044                                                  The value is a comma-separated list with two parts.  The first part can be
5045                                                  percentage, time, or iterations; the second part specifies how often an update
5046                                                  should be printed, in percentage, seconds, or number of iterations.
5047                                                  
5048                                                  =item --quiet
5049                                                  
5050                                                  short form: -q
5051                                                  
5052                                                  Do not print messages to STDOUT.  Errors and warnings are still printed to
5053                                                  STDERR.
5054                                                  
5055                                                  =item --update-foreign-keys-method
5056                                                  
5057                                                  type: string
5058                                                  
5059                                                  Method for updating foreign key constraints in L<"--child-tables">.  If
5060                                                  L<"--child-tables"> is specified, the tool will need to ensure that foreign
5061                                                  key constraints in those tables that reference the old (parent) table still
5062                                                  reference the table table after the old table is dropped and the new table
5063                                                  takes its place (if L<"--[no]rename-tables"> is enabled).
5064                                                  
5065                                                  When a parent table is renamed, MySQL automatically updates all child table
5066                                                  foreign key constraints that reference the renamed table so that the rename
5067                                                  does not break foreign key constraints.  This poses a problem for this tool.
5068                                                  For example: if the old table being altered is called C<foo>, then
5069                                                  L<"--[no]rename-tables"> renames C<foo> to C<__old_foo> so that the altered
5070                                                  copy, C<__new_foo>, can be renamed to C<foo>.  Any foreign key references to
5071                                                  the old C<foo> are renamed by MySQL to C<__old_foo> which is not what
5072                                                  we want; we want those reference to remain C<foo>.
5073                                                  
5074                                                  There are currently two methods to solve this problem:
5075                                                  
5076                                                  =over
5077                                                  
5078                                                  =item rebuild_constraints
5079                                                  
5080                                                  Drop and re-add child table foreign key constraints to reference the new table.
5081                                                  This method parses foreign key constraints referencing the old table from
5082                                                  all child tables, drops them, then re-adds them referencing the new table.
5083                                                  
5084                                                  This method uses C<ALTER TABLE> which can by slow and blocking, but it is
5085                                                  safer because the old table does not need to be dropped.  So if there's a
5086                                                  problem with the new table and L<"--drop-old-table"> was not specified,
5087                                                  then the old table can be restored.
5088                                                  
5089                                                  =item drop_old_table
5090                                                  
5091                                                  Disable foreign key checks (FOREIGN_KEY_CHECKS=0) then drop the old table.
5092                                                  This method bypasses MySQL's auto-renaming feature by disabling foreign key
5093                                                  checks, dropping the old table, then renaming the new table with the same
5094                                                  name.  Foreign key checks must be disabled to drop table because it is
5095                                                  referenced by foreign key constraints.  Since the old table is not renamed,
5096                                                  MySQL does not auto-rename references to it.  Then the new table is renamed
5097                                                  to the same name, so child table references are maintained.  So this method
5098                                                  requires L<"--drop-old-table">.
5099                                                  
5100                                                  This method is faster and does not block, but it is less safe for two reasons.
5101                                                  One, for a very short time (between dropping the old table and renaming the
5102                                                  new table) the child tables reference a non-existent table.  Two, more
5103                                                  importantly, if for some reason the new table was not copied correctly, didn't
5104                                                  capture all changes, etc., the old table cannot be recovered because it
5105                                                  was dropped. 
5106                                                  
5107                                                  =back
5108                                                  
5109                                                  =item --[no]rename-tables
5110                                                  
5111                                                  default: yes
5112                                                  
5113                                                  Rename new table to old table.
5114                                                  
5115                                                  =item --set-vars
5116                                                  
5117                                                  type: string; default: wait_timeout=10000
5118                                                  
5119                                                  Set these MySQL variables.  Immediately after connecting to MySQL, this string
5120                                                  will be appended to SET and executed.
5121                                                  
5122                                                  =item --sleep
5123                                                  
5124                                                  type: float; default: 0
5125                                                  
5126                                                  How long to sleep between chunks while copying rows.  The time has micro-second
5127                                                  precision, so you can specify fractions of seconds like C<0.1>.
5128                                                  
5129                                                  =item --socket
5130                                                  
5131                                                  short form: -S; type: string
5132                                                  
5133                                                  Socket file to use for connection.
5134                                                  
5135                                                  =item --user
5136                                                  
5137                                                  short form: -u; type: string
5138                                                  
5139                                                  User for login if not current user.
5140                                                  
5141                                                  =item --version
5142                                                  
5143                                                  Show version and exit.
5144                                                  
5145                                                  =back
5146                                                  
5147                                                  =head1 DSN OPTIONS
5148                                                  
5149                                                  These DSN options are used to create a DSN.  Each option is given like
5150                                                  C<option=value>.  The options are case-sensitive, so P and p are not the
5151                                                  same option.  There cannot be whitespace before or after the C<=> and
5152                                                  if the value contains whitespace it must be quoted.  DSN options are
5153                                                  comma-separated.  See the L<maatkit> manpage for full details.
5154                                                  
5155                                                  =over
5156                                                  
5157                                                  =item * A
5158                                                  
5159                                                  dsn: charset; copy: yes
5160                                                  
5161                                                  Default character set.
5162                                                  
5163                                                  =item * D
5164                                                  
5165                                                  dsn: database; copy: yes
5166                                                  
5167                                                  Database for the old and new table.
5168                                                  
5169                                                  =item * F
5170                                                  
5171                                                  dsn: mysql_read_default_file; copy: yes
5172                                                  
5173                                                  Only read default options from the given file
5174                                                  
5175                                                  =item * h
5176                                                  
5177                                                  dsn: host; copy: yes
5178                                                  
5179                                                  Connect to host.
5180                                                  
5181                                                  =item * p
5182                                                  
5183                                                  dsn: password; copy: yes
5184                                                  
5185                                                  Password to use when connecting.
5186                                                  
5187                                                  =item * P
5188                                                  
5189                                                  dsn: port; copy: yes
5190                                                  
5191                                                  Port number to use for connection.
5192                                                  
5193                                                  =item * S
5194                                                  
5195                                                  dsn: mysql_socket; copy: yes
5196                                                  
5197                                                  Socket file to use for connection.
5198                                                  
5199                                                  =item * t
5200                                                  
5201                                                  dsn: table; copy: no
5202                                                  
5203                                                  Table to alter.
5204                                                  
5205                                                  =item * u
5206                                                  
5207                                                  dsn: user; copy: yes
5208                                                  
5209                                                  User for login if not current user.
5210                                                  
5211                                                  =back
5212                                                  
5213                                                  =head1 DOWNLOADING
5214                                                  
5215                                                  You can download Maatkit from Google Code at
5216                                                  L<http://code.google.com/p/maatkit/>, or you can get any of the tools
5217                                                  easily with a command like the following:
5218                                                  
5219                                                     wget http://www.maatkit.org/get/toolname
5220                                                     or
5221                                                     wget http://www.maatkit.org/trunk/toolname
5222                                                  
5223                                                  Where C<toolname> can be replaced with the name (or fragment of a name) of any
5224                                                  of the Maatkit tools.  Once downloaded, they're ready to run; no installation is
5225                                                  needed.  The first URL gets the latest released version of the tool, and the
5226                                                  second gets the latest trunk code from Subversion.
5227                                                  
5228                                                  =head1 ENVIRONMENT
5229                                                  
5230                                                  The environment variable C<MKDEBUG> enables verbose debugging output in all of
5231                                                  the Maatkit tools:
5232                                                  
5233                                                     MKDEBUG=1 mk-....
5234                                                  
5235                                                  =head1 SYSTEM REQUIREMENTS
5236                                                  
5237                                                  You need Perl, DBI, DBD::mysql, and some core packages that ought to be
5238                                                  installed in any reasonably new version of Perl.
5239                                                  
5240                                                  =head1 BUGS
5241                                                  
5242                                                  For list of known bugs see L<http://www.maatkit.org/bugs/mk-online-schema-change>.
5243                                                  
5244                                                  Please use Google Code Issues and Groups to report bugs or request support:
5245                                                  L<http://code.google.com/p/maatkit/>.  You can also join #maatkit on Freenode to
5246                                                  discuss Maatkit.
5247                                                  
5248                                                  Please include the complete command-line used to reproduce the problem you are
5249                                                  seeing, the version of all MySQL servers involved, the complete output of the
5250                                                  tool when run with L<"--version">, and if possible, debugging output produced by
5251                                                  running with the C<MKDEBUG=1> environment variable.
5252                                                  
5253                                                  =head1 COPYRIGHT, LICENSE AND WARRANTY
5254                                                  
5255                                                  This program is copyright 2011-@CURRENTYEAR@ Percona Inc.
5256                                                  Feedback and improvements are welcome.
5257                                                  
5258                                                  THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
5259                                                  WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
5260                                                  MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
5261                                                  
5262                                                  This program is free software; you can redistribute it and/or modify it under
5263                                                  the terms of the GNU General Public License as published by the Free Software
5264                                                  Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
5265                                                  systems, you can issue `man perlgpl' or `man perlartistic' to read these
5266                                                  licenses.
5267                                                  
5268                                                  You should have received a copy of the GNU General Public License along with
5269                                                  this program; if not, write to the Free Software Foundation, Inc., 59 Temple
5270                                                  Place, Suite 330, Boston, MA  02111-1307  USA.
5271                                                  
5272                                                  =head1 AUTHOR
5273                                                  
5274                                                  Daniel Nichter
5275                                                  
5276                                                  =head1 HISTORY AND ACKNOWLEDGEMENTS
5277                                                  
5278                                                  The "online schema change" concept was first implemented by Shlomi Noach
5279                                                  in his tool C<oak-online-alter-table>, part of
5280                                                  L<http://code.google.com/p/openarkkit/>.  Then, engineers at Facebook built
5281                                                  their version called C<OnlineSchemaChange.php>; see
5282                                                  L<http://www.facebook.com/notes/mysql-at-facebook/online-schema-change-for-mysql/430801045932>.  Searching for "online schema change" will return other
5283                                                  relevant pages about this concept.
5284                                                  
5285                                                  This implementation, C<mk-online-schema-change>, is a hybrid of Shlomi's
5286                                                  and Facebook's approach.  Shlomi's code is a full-featured tool with command
5287                                                  line options, documentation, etc., but its continued development/support is
5288                                                  not assured.  Facebook's tool has certain technical advantages, but it's not
5289                                                  a full-featured tool; it's more a custom job by Facebook for Facebook.  And
5290                                                  neither of those tools is tested.  C<mk-online-schema-change> is a
5291                                                  full-featured, tested tool with stable development and support.
5292                                                  
5293                                                  This tool was made possible by a generous client of Percona Inc.
5294                                                  
5295                                                  =head1 ABOUT MAATKIT
5296                                                  
5297                                                  This tool is part of Maatkit, a toolkit for power users of MySQL.  Maatkit
5298                                                  was created by Baron Schwartz; Baron and Daniel Nichter are the primary
5299                                                  code contributors.  Both are employed by Percona.  Financial support for
5300                                                  Maatkit development is primarily provided by Percona and its clients. 
5301                                                  
5302                                                  =head1 VERSION
5303                                                  
5304                                                  This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 7461 $.
5305                                                  
5306                                                  =cut


Branches
--------

line  err      %   true  false   branch
----- --- ------ ------ ------   ------
51    ***      0      0      0   unless $args{$arg}
120   ***     50      0      8   unless open my $fh, '<', $file
123   ***     50      8      0   if ($contents =~ /^=head1 DSN OPTIONS/m)
133   ***     50    144      0   if ($val)
134          100      8     72   $val eq 'no' ? :
             100     64     80   $val eq 'yes' ? :
182   ***     50      0     16   unless open my $fh, '<', $file
190          100  11160     16   unless $para =~ /^=head1 $$self{'head1'}/
195          100     16     16   if $para =~ /^=over/
196          100      8      8   if $$self{'skip_rules'}
204   ***     50      0     16   unless $para
207          100    328     32   if (my($option) = $para =~ /^=item $$self{'item'}/)
214          100    264     64   if ($para =~ /: /) { }
218   ***     50      0    432   unless $$self{'attributes'}{$attrib}
222          100     72    192   if ($attribs{'short form'})
238   ***     50      0    328   if $para =~ /^=item/
240          100     32    296   if (my($base_option) = $option =~ /^\[no\](.*)/)
245          100     64    264   defined $attribs{'default'} ? :
      ***     50      0    328   $attribs{'group'} ? :
253   ***     50      0    480   unless $para
254          100     16    464   if ($para =~ /^=head1/)
258          100    344    120   if $para =~ /^=item /
262   ***     50      0     16   unless @specs
273          100    256      8   if (ref $opt) { }
278   ***     50      0    256   if (not $long)
283   ***     50      0    256   if exists $$self{'opts'}{$long}
286   ***     50      0    256   if (length $long == 1)
291          100     72    184   if ($short) { }
292   ***     50      0     72   if exists $$self{'short_opts'}{$short}
301          100     32    224   $$opt{'spec'} =~ /!/ ? :
302   ***     50      0    256   $$opt{'spec'} =~ /\+/ ? :
303   ***     50      0    256   $$opt{'desc'} =~ /required/ ? :
316          100     16    240   if $type and $type =~ /[HhAadzm]/
318          100     64    192   if (my($def) = $$opt{'desc'} =~ /default\b(?: ([^)]+))?/)
319   ***     50     64      0   defined $def ? :
323          100      8    248   if ($long eq 'config')
327   ***     50      0    256   if (my($dis) = $$opt{'desc'} =~ /(disables .*)/)
340   ***     50      0      8   if ($opt =~ /mutually exclusive|one and only one/)
345   ***     50      0      8   if ($opt =~ /at least one|one and only one/)
350   ***     50      0      8   if ($opt =~ /default to/)
355   ***     50      0      8   if ($opt =~ /restricted to option groups/)
364   ***     50      8      0   if ($opt =~ /accepts additional command-line arguments/)
370   ***     50      0      8   unless $rule_ok
387   ***      0      0      0   unless exists $$self{'opts'}{$long}
411   ***      0      0      0   unless exists $$self{'opts'}{$long}
431   ***      0      0      0   exists $$self{'short_opts'}{$opt} ? :
      ***     50     22      0   exists $$self{'opts'}{$opt} ? :
436   ***     50      0     22   if ($$opt{'is_cumulative'}) { }
451   ***     50      0    207   $$self{'opts'}{$long}{'is_cumulative'} ? :
             100     81    207   exists $$self{'defaults'}{$long} ? :
460   ***     50      0      9   if (@ARGV and $ARGV[0] eq '--config')
464   ***     50      9      0   if ($self->has('config'))
470   ***     50     36      0   if ($EVAL_ERROR)
471   ***     50      0     36   $self->got('config') ? :
486   ***     50      0      9   unless GetOptions map({$$_{'spec'}, sub {
	$self->_set_option(@_);
}
;} grep({$$_{'long'} ne 'config';} values %{$$self{'opts'};}))
489   ***     50      0      9   if (exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'})
490   ***      0      0      0   unless printf "%s  Ver %s Distrib %s Changeset %s\n", $$self{'program_name'}, $main::VERSION, $main::DISTRIB, $main::SVN_REV
496   ***     50      0      9   if (@ARGV and $$self{'strict'})
502   ***      0      0      0   if (@set > 1)
513   ***      0      0      0   if (@set == 0)
532   ***     50      0    288   unless $long
534          100     22    266   if ($$opt{'got'}) { }
      ***     50      0    266   elsif ($$opt{'is_required'}) { }
535   ***     50      0     22   if (exists $$self{'disables'}{$long})
542   ***     50      0     22   if (exists $$self{'allowed_groups'}{$long})
554   ***      0      0      0   if $restricted_opt eq $long
555   ***      0      0      0   if $$self{'opts'}{$restricted_opt}{'got'}
560   ***      0      0      0   if (@restricted_opts)
562   ***      0      0      0   if (@restricted_opts == 1) { }
583   ***     50    288      0   if ($$opt{'parsed'}) { }
591   ***     50      0      9   if @long == $long_last
601   ***     50      0    288   unless $opt
603          100    117    171   if (not $$opt{'type'})
610   ***     50      0    171   if ($val and $$opt{'type'} eq 'm') { }
      ***     50      0    171   elsif ($val and $$opt{'type'} eq 'd') { }
      ***     50      0    171   elsif ($val and $$opt{'type'} eq 'z') { }
      ***     50      0    171   elsif ($$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h') { }
             100     18    153   elsif ($$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a') { }
613   ***      0      0      0   if (not $suffix)
619   ***      0      0      0   if ($suffix =~ /[smhd]/) { }
620   ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
635   ***      0      0      0   if ($from_key)
637   ***      0      0      0   if ($$self{'opts'}{$from_key}{'parsed'}) { }
670          100     63    190   length $opt == 1 ? :
671   ***     50      0    253   unless $long and exists $$self{'opts'}{$long}
678   ***     50      0     36   length $opt == 1 ? :
679   ***     50      0     36   unless $long and exists $$self{'opts'}{$long}
686          100     63      9   length $opt == 1 ? :
687          100     65      7   defined $long ? :
692   ***     50      0      2   length $opt == 1 ? :
693   ***     50      0      2   unless $long and exists $$self{'opts'}{$long}
712   ***      0      0      0   unless $$self{'usage'}
718   ***      0      0      0   unless $$self{'description'}
723   ***      0      0      0   unless $ENV{'DONT_BREAK_LINES'}
733   ***     50      7      0   if (not $$self{'description'} or not $$self{'usage'})
742   ***     50      0      7   if ($$self{'opts'}{'help'}{'got'}) { }
      ***     50      0      7   elsif (scalar @{$$self{'errors'};}) { }
743   ***      0      0      0   unless print $self->print_usage
744   ***      0      0      0   unless $return
747   ***      0      0      0   unless print $self->print_errors
748   ***      0      0      0   unless $return
757   ***      0      0      0   if (my(@errors) = @{$$self{'errors'};})
766   ***      0      0      0   unless $$self{'got_opts'}
769   ***      0      0      0   $$_{'is_negatable'} ? :
      ***      0      0      0   $$_{'type'} ? :
777   ***      0      0      0   $$self{'opts'}{$_}{'is_negatable'} ? :
      ***      0      0      0   $$self{'opts'}{$_}{'type'} ? :
797   ***      0      0      0   $group eq 'default' ? :
803   ***      0      0      0   $$opt{'is_negatable'} ? :
807   ***      0      0      0   $$opt{'type'} ? :
809   ***      0      0      0   if ($$opt{'type'} and $$opt{'type'} eq 'm')
818   ***      0      0      0   if ($short) { }
829   ***      0      0      0   if (my(@rules) = @{$$self{'rules'};})
833   ***      0      0      0   if ($$self{'DSNParser'})
841   ***      0      0      0   $val ? :
      ***      0      0      0   $type =~ /A|a/ ? :
      ***      0      0      0   $type =~ /H|h/ ? :
      ***      0      0      0   $type eq 'd' ? :
      ***      0      0      0   !defined($val) ? :
      ***      0      0      0   $bool ? :
853   ***      0      0      0   if ref $_[0] eq 'OptionParser'
856   ***      0      0      0   unless print $prompt
864   ***      0      0      0   unless print "\n"
867   ***      0      0      0   if ($EVAL_ERROR)
889   ***     50     36      0   unless open my $fh, '<', $filename
897   ***      0      0      0   if $line =~ /^\s*(?:\#|\;|$)/
900   ***      0      0      0   if ($line eq '--')
905   ***      0      0      0   if ($parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/) { }
      ***      0      0      0   elsif ($line =~ /./) { }
923   ***      0      0      0   unless open my $fh, '<', $file
927   ***      0      0      0   unless $para =~ /^=pod$/m
931   ***      0      0      0   unless $para =~ /$regex/
936   ***      0      0      0   unless close $fh
950   ***      0      0      0   $ref eq 'ARRAY' ? :
      ***      0      0      0   $ref eq 'HASH' ? :
      ***      0      0      0   !$ref ? :
966   ***      0      0      0   if (lc($val || '') eq 'null')
974   ***      0      0      0   if (defined $num) { }
975   ***      0      0      0   if ($factor)
991          100     72    184   $$attribs{'short form'} ? :
             100     32    224   $$attribs{'negatable'} ? :
      ***     50      0    256   $$attribs{'cumulative'} ? :
             100    152    104   $$attribs{'type'} ? :
1004  ***     50      0      7   unless open my $fh, '<', $file
1007  ***     50      0      7   unless $para
1016  ***     50      0      7   unless $usage and $desc
1035  ***      0      0      0   defined $_ ? :
1078         100      7      5   if (not $$self{$dbh})
1082  ***     50     12      0   $$self{$dbh} ge $self->parse($target) ? :
1089  ***      0      0      0   unless $dbh
1100  ***      0      0      0   if ($innodb)
1102  ***      0      0      0   if ($$innodb{'support'} =~ /YES|DEFAULT/i) { }
1105  ***      0      0      0   !$vars ? :
1119  ***      0      0      0   defined $_ ? :
1160  ***     50      0     11   unless $args{$arg}
1166  ***     50      0     99   if (not $$opt{'key'} or not $$opt{'desc'})
1186         100      7     44   if (@_ > 2)
1195  ***     50      0     17   if (not $dsn)
1207  ***     50     33      0   if (my($prop_key, $prop_val) = $dsn_part =~ /^(.)=(.*)$/) { }
1219         100      7    146   if (not defined $final_props{$key} and defined $$prev{$key} and $$opts{$key}{'copy'})
1225         100    113     40   if (not defined $final_props{$key})
1232  ***     50      0     33   unless exists $$opts{$key}
1237  ***     50      0     17   if (my $required = $self->prop('required'))
1239  ***      0      0      0   unless $final_props{$key}
1251  ***     50      0      7   unless ref $o eq 'OptionParser'
1254         100     56      7   if $o->has($_)
1264  ***      0      0      0   unless ref $dsn
1265  ***      0      0      0   $props ? :
1266  ***      0      0      0   $_ eq 'p' ? :
1267  ***      0      0      0   if defined $$dsn{$_}
1268  ***      0      0      0   unless not $props
1281  ***      0      0      0   $opts{$key}{'copy'} ? :
1295  ***     50      0     10   if ($driver eq 'Pg') { }
1327  ***     50      0     10   $cxn_string =~ /charset=utf8/i ? :
1336  ***     50      0     10   if ($$opts{'mysql_use_result'})
1340  ***     50      0     10   if (not $have_dbi)
1359  ***     50     10      0   if ($cxn_string =~ /mysql/i)
1366  ***     50      0     10   $sql_mode ? :
1373  ***     50      0     10   if (my($charset) = $cxn_string =~ /charset=(\w+)/)
1378  ***      0      0      0   if ($charset eq 'utf8') { }
1379  ***      0      0      0   unless binmode STDOUT, ':utf8'
1383  ***      0      0      0   unless binmode STDOUT
1387         100      7      3   if ($self->prop('set-vars'))
1394  ***     50      0     10   if (not $dbh and $EVAL_ERROR)
1396  ***      0      0      0   if ($EVAL_ERROR =~ /not a compiled character set|character set utf8/) { }
      ***      0      0      0   elsif ($EVAL_ERROR =~ m[locate DBD/mysql]i) { }
1409  ***      0      0      0   if (not $tries)
1431  ***      0      0      0   if (my($host) = ($$dbh{'mysql_hostinfo'} || '') =~ /^(\w+) via/)
1448  ***      0      0      0   ($$thing{'Type'} || '') eq 'st' ? :
      ***      0      0      0   unless printf "# Active %sh: %s %s %s\n", $$thing{'Type'} || 'undef', "\t" x $level, $thing, ($$thing{'Type'} || '') eq 'st' ? $$thing{'Statement'} || '' : ''
1458  ***      0      0      0   unless $dsn_1
1459  ***      0      0      0   unless $dsn_2
1463  ***      0      0      0   if ($args{'overwrite'}) { }
1464  ***      0      0      0   defined $$dsn_1{$key} ? :
1467  ***      0      0      0   defined $$dsn_2{$key} ? :
1476  ***      0      0      0   defined $_ ? :
1510  ***      0      0      0   unless $args{$arg}
1513  ***      0      0      0   $o->has('log') ? :
      ***      0      0      0   $o->has('pid') ? :
1529  ***      0      0      0   unless defined(my $pid = fork)
1530  ***      0      0      0   if ($pid)
1538  ***      0      0      0   unless POSIX::setsid()
1539  ***      0      0      0   unless chdir '/'
1545  ***      0      0      0   if (-t STDIN)
1547  ***      0      0      0   unless open STDIN, '/dev/null'
1551  ***      0      0      0   if ($$self{'log_file'}) { }
1553  ***      0      0      0   unless open STDOUT, '>>', $$self{'log_file'}
1557  ***      0      0      0   unless open STDERR, '>&STDOUT'
1561  ***      0      0      0   if (-t STDOUT)
1563  ***      0      0      0   unless open STDOUT, '>', '/dev/null'
1566  ***      0      0      0   if (-t STDERR)
1568  ***      0      0      0   unless open STDERR, '>', '/dev/null'
1579  ***      0      0      0   $self ? :
1581  ***      0      0      0   if ($PID_file and -f $PID_file) { }
1584  ***      0      0      0   if $EVAL_ERROR
1586  ***      0      0      0   if ($pid) { }
1588  ***      0      0      0   if ($pid_is_alive) { }
1610  ***      0      0      0   if (exists $$self{'child'})
1622  ***      0      0      0   if (not $PID_file)
1629  ***      0      0      0   unless open my $PID_FH, '>', $PID_file
1631  ***      0      0      0   unless print $PID_FH $PID
1633  ***      0      0      0   unless close $PID_FH
1642  ***      0      0      0   if ($$self{'PID_file'} and -f $$self{'PID_file'}) { }
1643  ***      0      0      0   unless unlink $$self{'PID_file'}
1656  ***      0      0      0   if ($$self{'PID_owner'} || 0) == $PID
1663  ***      0      0      0   defined $_ ? :
1708  ***     50      0     10   unless defined $val
1709  ***     50      0     10   if $val eq ''
1710  ***     50      0     10   if $val =~ /^0x[0-9a-fA-F]+$/
1720  ***     50     21      0   if (not $tbl)
1729  ***     50      0     29   unless $like
1736  ***      0      0      0   unless $db_tbl
1738  ***      0      0      0   if (not $tbl)
1742  ***      0      0      0   if $db and not $db =~ /^`/
1743  ***      0      0      0   if $tbl and not $tbl =~ /^`/
1744  ***      0      0      0   $db ? :
1796  ***      0      0      0   defined $args{'p_ms'} ? :
1797  ***      0      0      0   defined $args{'p_s'} ? :
1800  ***      0      0      0   if $t < 0
1802  ***      0      0      0   if $t =~ /e/
1806  ***      0      0      0   if ($t > 0 and $t <= 0.000999) { }
      ***      0      0      0   elsif ($t >= 0.001 and $t <= 0.999999) { }
      ***      0      0      0   elsif ($t >= 1) { }
1827  ***      0      0      0   $p ? :
1834  ***      0      0      0   unless $secs
1836  ***      0      0      0   $secs >= 3600 ? :
      ***      0      0      0   $secs >= 86400 ? :
1841  ***      0      0      0   $fmt eq 'h' ? :
      ***      0      0      0   $fmt eq 'd' ? :
1860  ***      0      0      0   unless defined $val
1864  ***      0      0      0   if ($suffix =~ /[smhd]/) { }
1865  ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1870  ***      0      0      0   if $prefix and $prefix eq '-'
1880  ***      0      0      0   defined $args{'p'} ? :
1881  ***      0      0      0   defined $args{'d'} ? :
1888  ***      0      0      0   $num =~ /\./ || $n ? :
1897  ***     50      0    100   $gmt ? :
1903  ***     50      0    100   if (my($us) = $time =~ /(\.\d+)$/)
1913  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $f) = $val =~ /^$mysql_ts$/)
1916  ***      0      0      0   defined $f ? :
      ***      0      0      0   defined $f ? :
1925  ***      0      0      0   if (my($y, $m, $d, $h, $i, $s, $us) = $val =~ /^$proper_ts$/)
1926  ***      0      0      0   $gmt ? :
1929  ***      0      0      0   if (defined $us)
1941  ***      0      0      0   if (my($n, $suffix) = $val =~ /^$n_ts$/) { }
      ***      0      0      0   elsif ($val =~ /^\d{9,}/) { }
      ***      0      0      0   elsif (my($ymd, $hms) = $val =~ /^(\d{6})(?:\s+(\d+:\d+:\d+))?/) { }
      ***      0      0      0   elsif (($ymd, $hms) = $val =~ /^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) { }
1942  ***      0      0      0   $suffix eq 'd' ? :
      ***      0      0      0   $suffix eq 'h' ? :
      ***      0      0      0   $suffix eq 'm' ? :
      ***      0      0      0   $suffix eq 's' ? :
1956  ***      0      0      0   unless $hms
1961  ***      0      0      0   unless $hms
1966  ***      0      0      0   if $callback and ref $callback eq 'CODE'
1982  ***      0      0      0   unless $string
1988  ***      0      0      0   $comp & 1 ? :
1997  ***      0      0      0   defined $_ ? :
2034  ***     50      0      8   unless $args{$arg}
2042  ***     50      0     14   unless $ddl
2043  ***     50     14      0   if (ref $ddl eq 'ARRAY')
2044  ***     50     14      0   if (lc $$ddl[0] eq 'table') { }
2054  ***     50      0     14   if (not $ddl =~ /CREATE (?:TEMPORARY )?TABLE `/)
2060  ***     50     14      0   if $name
2078  ***     50      0     40   unless $type
2080         100     12     28   if ($type =~ /(?:(?:tiny|big|medium|small)?int|float|double|decimal|year)/)
2084         100     24     16   if (not $def =~ /NOT NULL/)
2088         100     12     28   $def =~ /AUTO_INCREMENT/i ? :
2122  ***      0      0      0   unless ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
2136  ***      0      0      0   if ($index)
2139  ***      0      0      0   if (not $best)
2140  ***      0      0      0   if ($index) { }
2153  ***      0      0      0   unless $where
2159  ***      0      0      0   if ($$expl{'possible_keys'}) { }
2163  ***      0      0      0   if ($$expl{'key'})
2183  ***     50      0     87   unless $args{$arg}
2197  ***     50      0     29   if ($EVAL_ERROR)
2201         100     16     13   if (not $$row[0] or $$row[0] ne $tbl)
2207  ***     50     13      0   unless $args{'all_privs'}
2214  ***      0      0      0   if ($EVAL_ERROR)
2218  ***      0      0      0   if (not scalar keys %$row)
2229  ***      0      0      0   $EVAL_ERROR ? :
2234  ***      0      0      0   if (not $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete)
2260  ***     50      0     12   if $key =~ /FOREIGN/
2265  ***     50     12      0   if (not $engine =~ /MEMORY|HEAP/)
2272  ***     50      0     12   if ($$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i)
2279  ***     50     12      0   $key =~ /PRIMARY|UNIQUE/ ? :
2303         100      4      8   if ($engine =~ /InnoDB/i and not $clustered_key)
2305  ***     50      4      0   if ($$this_key{'name'} eq 'PRIMARY') { }
      ***      0      0      0   elsif ($$this_key{'is_unique'} and not $$this_key{'is_nullable'}) { }
2329  ***      0      0      0   if (not $parent =~ /\./ and $$opts{'database'})
2358  ***      0      0      0   if (($$tbl_struct{'engine'} || '') =~ /InnoDB/i) { }
2368  ***      0      0      0   unless $key_ddl =~ /,$/
2375  ***      0      0      0   if (@sec_indexes)
2392  ***      0      0      0   defined $_ ? :
2456  ***      0      0      0   if ($what eq 'table') { }
      ***      0      0      0   elsif ($what eq 'triggers') { }
      ***      0      0      0   elsif ($what eq 'view') { }
2458  ***      0      0      0   unless $ddl
2459  ***      0      0      0   if ($$ddl[0] eq 'table') { }
2473  ***      0      0      0   if ($trgs and @$trgs) { }
2476  ***      0      0      0   if ($$trg{'sql_mode'})
2480  ***      0      0      0   if ($$trg{'definer'})
2512  ***     50      0     14   if (not $new)
2524  ***     50     14      0   if (not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl})
2537  ***     50      0     14   if ($EVAL_ERROR)
2547  ***     50     14      0   if ($key) { }
2563  ***      0      0      0   if (not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl})
2593  ***      0      0      0   if (not $$self{'cache'} or not $$self{'triggers'}{$db})
2606  ***      0      0      0   if ($sth->rows)
2619  ***      0      0      0   if ($tbl)
2627  ***      0      0      0   if (not $$self{'cache'} or not $$self{'databases'} or $like)
2630  ***      0      0      0   if ($like)
2638  ***      0      0      0   unless $like
2646  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_status'}{$db} or $like)
2649  ***      0      0      0   if ($like)
2664  ***      0      0      0   unless $like
2672  ***      0      0      0   if (not $$self{'cache'} or not $$self{'table_list'}{$db} or $like)
2675  ***      0      0      0   if ($like)
2683  ***      0      0      0   ($$_[1] || '') eq 'VIEW' ? :
2690  ***      0      0      0   unless $like
2698  ***      0      0      0   defined $_ ? :
2736  ***     50      0     16   unless $args{$arg}
2755  ***     50      0      9   unless $args{$arg}
2762  ***     50      0      8   unless $$index{'type'} eq 'BTREE'
2764  ***     50      0      8   if grep {defined $_;} @{$$index{'col_prefixes'};}
2766  ***     50      8      0   if ($args{'exact'})
2767  ***     50      0      8   unless $$index{'is_unique'} and @{$$index{'cols'};} == 1
2781  ***     50      0      8   unless $$self{'int_types'}{$col_type} or $$self{'real_types'}{$col_type} or $col_type =~ /char/
2788         100      8      1   if $args{'exact'} and scalar @candidate_cols
2798         100      8      1   if ($$tbl_struct{'keys'}{'PRIMARY'})
2821  ***     50      0     35   unless defined $args{$arg}
2828  ***     50      0      5   if (not $args{'rows_in_range'})
2833         100      4      1   if ($args{'rows_in_range'} < $args{'chunk_size'})
2846  ***     50      1      0   if ($$tbl_struct{'is_numeric'}{$chunk_col} or $col_type =~ /date|time/) { }
      ***      0      0      0   elsif ($col_type =~ /char/) { }
2860  ***     50      1      0   if ($start_point < $end_point) { }
2862  ***     50      0      1   if $chunker{'have_zero_chunk'}
2869         100      1      4   if ($iter++ == 0) { }
2870  ***     50      0      1   $chunker{'have_zero_chunk'} ? :
2882  ***     50      1      0   if (@chunks) { }
2883  ***     50      0      1   $chunk_range eq 'openclosed' ? :
2888  ***      0      0      0   $nullable ? :
2890  ***     50      0      1   if ($nullable)
2906  ***     50      0      7   unless defined $args{$arg}
2913  ***     50      1      0   if ($col_type =~ /(?:int|year|float|double|decimal)$/) { }
      ***      0      0      0   elsif ($col_type =~ /^(?:timestamp|date|time)$/) { }
      ***      0      0      0   elsif ($col_type eq 'datetime') { }
2936  ***     50      0      1   if ($EVAL_ERROR)
2937  ***      0      0      0   if ($EVAL_ERROR =~ /don't know how to chunk/) { }
2941  ***      0      0      0   defined $args{$_} ? :
2954  ***     50      0      1   if (not defined $start_point)
2958  ***     50      0      1   if (not defined $end_point or $end_point < $start_point)
2965  ***     50      0      1   if ($args{'zero_chunk'})
2966  ***      0      0      0   if ($start_point != $end_point and $start_point >= 0) { }
2991  ***     50      1      0   if ($$self{'int_types'}{$col_type})
2995  ***     50      0      1   if ($args{'exact'})
3014  ***      0      0      0   unless defined $args{$arg}
3040  ***      0      0      0   if (($args{'tbl_struct'}{'charset'} || '') eq 'latin1') { }
3053  ***      0      0      0   if $sorted_latin1_chars[$i] >= $min_col_ord
3056  ***      0      0      0   if $sorted_latin1_chars[$i] >= $max_col_ord
3107  ***      0      0      0   if ($n_values >= $args{'chunk_size'})
3144  ***      0      0      0   unless $args{$arg}
3155  ***      0      0      0   if ($wanted_col and $wanted_idx) { }
      ***      0      0      0   elsif ($wanted_col) { }
      ***      0      0      0   elsif ($wanted_idx) { }
3157  ***      0      0      0   if ($wanted_col eq $$chunkable_col{'column'} and $wanted_idx eq $$chunkable_col{'index'})
3167  ***      0      0      0   if ($wanted_col eq $$chunkable_col{'column'})
3176  ***      0      0      0   if ($wanted_idx eq $$chunkable_col{'index'})
3192  ***      0      0      0   unless $args{$arg}
3201  ***      0      0      0   if ($suffix) { }
      ***      0      0      0   elsif ($num) { }
3202  ***      0      0      0   $suffix eq 'M' ? :
      ***      0      0      0   $suffix eq 'k' ? :
3214  ***      0      0      0   if ($suffix or $args{'avg_row_length'})
3217  ***      0      0      0   if (not defined $n_rows)
3218  ***      0      0      0   $avg_row_length ? :
3229  ***     50      0     25   unless $args{$arg}
3243  ***     50      0      5   $args{'index_hint'} ? :
      ***     50      0      5   $where ? :
3261  ***     50      0      5   if ($EVAL_ERROR)
3266  ***     50      0      5   $args{'index_hint'} ? :
      ***     50      0      5   $where ? :
3282  ***      0      0      0   unless defined $args{$arg}
3291  ***      0      0      0   if ($args{'where'} and grep {$_;} @{$args{'where'};})
3314  ***     50      0      4   unless defined $args{$arg}
3320  ***     50      0      2   unless defined $val
3330  ***     50      2      0   if ($col_type =~ /(?:int|year|float|double|decimal)$/) { }
      ***      0      0      0   elsif ($col_type =~ /^(?:timestamp|date|time)$/) { }
      ***      0      0      0   elsif ($col_type eq 'datetime') { }
3356  ***     50      0      5   if $start =~ /e/
3357  ***     50      0      5   if $end =~ /e/
3362  ***     50      5      0   if ($end > $start) { }
3408  ***      0      0      0   unless $check eq $time
3425  ***     50      0     20   unless $args{$arg}
3430  ***     50      0      5   $args{'where'} ? :
3437         100      3      2   if (defined $valid_min)
3444  ***      0      0      0   defined $real_min ? :
      ***     50      0      3   unless defined $valid_min
3450         100      3      2   if (defined $valid_max)
3457  ***      0      0      0   defined $real_max ? :
      ***     50      0      3   unless defined $valid_max
3469  ***     50      0     24   unless $args{$arg}
3474  ***     50      0      6   unless defined $val
3476  ***     50      0      6   $col_type =~ /time|date/ ? :
3479  ***     50      6      0   if (not $validate)
3484  ***      0      0      0   if defined &$validate($dbh, $val)
3500  ***      0      0      0   unless $args{$arg}
3503  ***      0      0      0   defined $args{'tries'} ? :
3506  ***      0      0      0   unless defined $val
3508  ***      0      0      0   $endpoint =~ /max/i ? :
      ***      0      0      0   $endpoint =~ /min/i ? :
3511  ***      0      0      0   $args{'index_hint'} ? :
      ***      0      0      0   $args{'where'} ? :
3524  ***      0      0      0   if (not defined $next_val)
3528  ***      0      0      0   if (defined &$validate($dbh, $next_val))
3552  ***      0      0      0   if ($EVAL_ERROR)
3562  ***      0      0      0   unless $args{$arg}
3565  ***      0      0      0   defined $args{'tries'} ? :
3569  ***      0      0      0   $col_type =~ /time|date/ ? :
3571  ***      0      0      0   if (not &$is_nonzero($dbh, $val))
3573  ***      0      0      0   $args{'index_hint'} ? :
      ***      0      0      0   $args{'where'} ? :
3585  ***      0      0      0   if (&$is_nonzero($dbh, $next_val))
3603  ***      0      0      0   unless defined $args{$arg}
3607  ***      0      0      0   if $n == 0
3610  ***      0      0      0   if ($highest_power == 0)
3631  ***      0      0      0   defined $_ ? :
3667  ***     50      0      5   unless defined $args{$arg}
3669  ***     50      5      0   if (not $args{'report'} or not $args{'interval'})
3670  ***     50      5      0   if ($args{'spec'} and @{$args{'spec'};} == 2) { }
3697  ***     50      7      0   if $_[0] eq 'Progress'
3699  ***     50      0      7   if (@$spec != 2)
3702  ***     50      0      7   if (not $$spec[0] =~ /^(?:percentage|time|iterations)$/)
3706  ***     50      0      7   if (not $$spec[1] =~ /^\d+$/)
3727  ***     50      7      0   if ($$self{'report'} eq 'time' and $$self{'interval'} > $now - $$self{'last_reported'}) { }
      ***      0      0      0   elsif ($$self{'report'} eq 'iterations' and ($$self{'iterations'} - 1) % $$self{'interval'} > 0) { }
3742  ***      0      0      0   if $completed > $jobsize
3744  ***      0      0      0   $completed > 0 ? :
3746  ***      0      0      0   if ($$self{'report'} eq 'percentage' and $self->fraction_modulo($$self{'fraction'}) >= $self->fraction_modulo($fraction))
3758  ***      0      0      0   if ($completed > 0 and $completed <= $jobsize and $elapsed > 0)
3760  ***      0      0      0   if ($rate > 0)
3777  ***      0      0      0   defined $_ ? :
3809  ***      0      0      0   unless $args{$arg}
3823  ***     50      0     21   unless $args{$arg}
3830  ***     50      9      0   unless $args{'print'}
3840  ***     50      0     15   unless $args{$arg}
3871  ***      0      0      0   unless $args{$arg}
3880  ***     50      0     12   unless $args{$arg}
3887  ***     50     12      0   unless $args{'print'}
3895  ***      0      0      0   defined $_ ? :
3927  ***     50      0      7   unless $args{$arg}
3941  ***     50      0     18   unless $args{$arg}
3950  ***     50      0      7   if (not $$chunks[$chunkno])
3955  ***     50      0      7   $args{'where'} ? :
      ***     50      0      7   $args{'engine_flags'} ? :
3961  ***     50      0      7   if ($args{'print'}) { }
3975         100      1      7   if ($EVAL_ERROR)
3977  ***     50      1      0   if ($EVAL_ERROR =~ /Lock wait timeout exceeded/)
3979  ***     50      0      1   if ($args{'tryno'} > 1)
3992  ***     50      7      0   if $pr
3994  ***     50      0      7   if $sleep and $chunkno < $n_chunks
4007  ***      0      0      0   defined $_ ? :
4047  ***     50      0     14   unless $args{$arg}
4060         100      7      1   if (defined $result)
4062  ***     50      0      7   if (my $on_success = $args{'on_success'})
4069  ***     50      0      1   if ($EVAL_ERROR)
4071  ***      0      0      0   unless $args{'retry_on_die'}
4074  ***     50      1      0   if ($tryno < $tries)
4081  ***      0      0      0   if (my $on_failure = $args{'on_failure'})
4091  ***      0      0      0   defined $_ ? :
4148  ***     50      0      7   if (not $dsn) { }
4153  ***     50      0      7   if (not $$dsn{'t'}) { }
4162         100      1      6   if (($rename_fk_method || '') eq 'drop_old_table')
4167  ***     50      7      0   if (not $o->get('help'))
4168  ***     50      0      7   if (@ARGV)
4172  ***     50      0      7   if (not $db)
4177  ***     50      0      7   if ($tbl and $tbl eq ($o->get('tmp-table') || ''))
4181  ***     50      7      0   if ($o->get('progress'))
4183  ***     50      0      7   if ($EVAL_ERROR)
4189  ***     50      0      7   if ($o->get('child-tables') and not $o->get('update-foreign-keys-method'))
4193  ***     50      0      7   if ($rename_fk_method and $rename_fk_method ne 'rebuild_constraints' and $rename_fk_method ne 'drop_old_table')
4221  ***     50      0      7   if ($o->get('pid'))
4266  ***     50      0      7   if (my $sleep_time = $o->get('sleep'))
4278         100      1      6   if ($o->get('cleanup-and-exit'))
4296  ***     50      0      6   if ($EVAL_ERROR)
4306         100      1      5   if ($o->get('check-tables-and-exit'))
4342         100      2      3   if (my $child_tables = $o->get('child-tables'))
4343  ***     50      2      0   if (lc $child_tables eq 'auto_detect') { }
4346  ***      0      0      0   @child_tables ? :
4365  ***     50      3      0   if ($o->get('create-tmp-table'))
4368  ***     50      3      0   unless $o->get('print')
4371         100      2      1   if (my $alter = $o->get('alter'))
4373  ***     50      0      2   if (-f $alter and -r $alter) { }
4375  ***      0      0      0   unless open my $fh, '<', $alter
4386  ***     50      2      0   unless $o->get('print')
4398  ***     50      3      0   if (not $o->get('print'))
4441  ***     50      3      0   if ($o->get('rename-tables'))
4446  ***     50      3      0   unless $o->get('print')
4453  ***     50      0      3   if (@child_tables)
4455  ***      0      0      0   if ($rename_fk_method eq 'rebuild_constraints') { }
      ***      0      0      0   elsif ($rename_fk_method eq 'drop_old_table') { }
4464  ***      0      0      0   unless $o->get('print')
4468  ***      0      0      0   unless $o->get('print')
4472  ***      0      0      0   unless $o->get('print')
4488         100      2      1   if ($o->get('rename-tables') and $o->get('drop-old-table'))
4491  ***     50      2      0   unless $o->get('print')
4494  ***     50      0      3   if ($EVAL_ERROR)
4512  ***     50      0    132   unless $args{$arg}
4526  ***     50      0     12   if (not $args{'VersionParser'}->version_ge($dbh, '5.0.10'))
4534         100      1     11   if (not $tp->check_table('dbh', $dbh, 'db', $db, 'tbl', $tbl))
4542         100      1     10   if ($triggers and @$triggers)
4549         100      9      1   if ($o->get('rename-tables'))
4550         100      1      8   if ($tp->check_table('dbh', $dbh, 'db', $db, 'tbl', $old_tbl))
4566         100      1      8   if (not $exact or not @chunkable_cols)
4579         100      1      7   if ($o->get('create-tmp-table') and $tp->check_table('dbh', $dbh, 'db', $db, 'tbl', $tmp_tbl))
4591  ***     50      0      8   unless $args{$arg}
4603  ***     50      0      2   if ($EVAL_ERROR)
4617  ***      0      0      0   unless $args{$arg}
4633  ***      0      0      0   if ($EVAL_ERROR)
4639  ***      0      0      0   if (not @constraints)
4649  ***      0      0      0   unless $args{'print'}
4654  ***      0      0      0   unless $args{'print'}
4673  ***     50      0      7   if ($o->get('ask-pass'))
4678  ***     50      0      7   unless $o->get('bin-log')
4679  ***     50      0      7   unless $o->get('foreign-key-checks')
4687         100    100     28   unless $quiet
4699  ***      0      0      0   defined $_ ? :


Conditions
----------

and 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
2788  ***     50      0      9   $args{'exact'} and scalar @candidate_cols

and 3 conditions

line  err      %     !l  l&&!r   l&&r   expr
----- --- ------ ------ ------ ------   ----
316          100    104    136     16   $type and $type =~ /[HhAadzm]/
460   ***     66      1      8      0   @ARGV and $ARGV[0] eq '--config'
489   ***     33      0      9      0   exists $$self{'opts'}{'version'} and $$self{'opts'}{'version'}{'got'}
496   ***     66      2      7      0   @ARGV and $$self{'strict'}
610   ***     66    122     49      0   $val and $$opt{'type'} eq 'm'
      ***     66    122     49      0   $val and $$opt{'type'} eq 'd'
      ***     66    122     49      0   $val and $$opt{'type'} eq 'z'
      ***     66    113     58      0   defined $val and $$opt{'type'} eq 'h'
             100    113     40      9   defined $val and $$opt{'type'} eq 'a'
671   ***     33      0      0    253   $long and exists $$self{'opts'}{$long}
679   ***     33      0      0     36   $long and exists $$self{'opts'}{$long}
693   ***     33      0      0      2   $long and exists $$self{'opts'}{$long}
809   ***      0      0      0      0   $$opt{'type'} and $$opt{'type'} eq 'm'
905   ***      0      0      0      0   $parse and my($opt, $arg) = $line =~ /^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/
1006  ***     66      0      7   4284   defined($para = <$fh>) and not $para =~ /^=head1 SYNOPSIS/
1016  ***     33      0      0      7   $usage and $desc
1219         100     33    113      7   not defined $final_props{$key} and defined $$prev{$key}
      ***     66    146      0      7   not defined $final_props{$key} and defined $$prev{$key} and $$opts{$key}{'copy'}
1352  ***     66     10      0     10   not $dbh and $tries--
1394  ***     33     10      0      0   not $dbh and $EVAL_ERROR
1581  ***      0      0      0      0   $PID_file and -f $PID_file
1642  ***      0      0      0      0   $$self{'PID_file'} and -f $$self{'PID_file'}
1742  ***      0      0      0      0   $db and not $db =~ /^`/
1743  ***      0      0      0      0   $tbl and not $tbl =~ /^`/
1806  ***      0      0      0      0   $t > 0 and $t <= 0.000999
      ***      0      0      0      0   $t >= 0.001 and $t <= 0.999999
1870  ***      0      0      0      0   $prefix and $prefix eq '-'
1884  ***      0      0      0      0   $num >= $d and $n < @units - 1
1966  ***      0      0      0      0   $callback and ref $callback eq 'CODE'
2234  ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/
      ***      0      0      0      0   $privs =~ /select/ && $privs =~ /insert/ && $privs =~ /update/ && $can_delete
2272  ***     33     12      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000'
      ***     33     12      0      0   $$opts{'mysql_version'} and $$opts{'mysql_version'} lt '004001000' and $engine =~ /HEAP|MEMORY/i
2303  ***     66      8      0      4   $engine =~ /InnoDB/i and not $clustered_key
2305  ***      0      0      0      0   $$this_key{'is_unique'} and not $$this_key{'is_nullable'}
2329  ***      0      0      0      0   not $parent =~ /\./ and $$opts{'database'}
2473  ***      0      0      0      0   $trgs and @$trgs
2767  ***     33      0      0      8   $$index{'is_unique'} and @{$$index{'cols'};} == 1
2966  ***      0      0      0      0   $start_point != $end_point and $start_point >= 0
3053  ***      0      0      0      0   $first_char = $i and last
3056  ***      0      0      0      0   $last_char = $i and last
3155  ***      0      0      0      0   $wanted_col and $wanted_idx
3157  ***      0      0      0      0   $wanted_col eq $$chunkable_col{'column'} and $wanted_idx eq $$chunkable_col{'index'}
3291  ***      0      0      0      0   $args{'where'} and grep {$_;} @{$args{'where'};}
3670  ***     33      0      0      5   $args{'spec'} and @{$args{'spec'};} == 2
3727  ***     33      0      0      7   $$self{'report'} eq 'time' and $$self{'interval'} > $now - $$self{'last_reported'}
      ***      0      0      0      0   $$self{'report'} eq 'iterations' and ($$self{'iterations'} - 1) % $$self{'interval'} > 0
3746  ***      0      0      0      0   $$self{'report'} eq 'percentage' and $self->fraction_modulo($$self{'fraction'}) >= $self->fraction_modulo($fraction)
3758  ***      0      0      0      0   $completed > 0 and $completed <= $jobsize
      ***      0      0      0      0   $completed > 0 and $completed <= $jobsize and $elapsed > 0
3994  ***     33      7      0      0   $sleep and $chunkno < $n_chunks
4177  ***     33      0      7      0   $tbl and $tbl eq ($o->get('tmp-table') || '')
4189  ***     66      5      2      0   $o->get('child-tables') and not $o->get('update-foreign-keys-method')
4193         100      5      1      1   $rename_fk_method and $rename_fk_method ne 'rebuild_constraints'
      ***     66      6      1      0   $rename_fk_method and $rename_fk_method ne 'rebuild_constraints' and $rename_fk_method ne 'drop_old_table'
4373  ***     33      2      0      0   -f $alter and -r $alter
4488  ***     66      0      1      2   $o->get('rename-tables') and $o->get('drop-old-table')
4542  ***     66      0     10      1   $triggers and @$triggers
4579  ***     66      0      7      1   $o->get('create-tmp-table') and $tp->check_table('dbh', $dbh, 'db', $db, 'tbl', $tmp_tbl)

or 2 conditions

line  err      %      l     !l   expr
----- --- ------ ------ ------   ----
41    ***     50      0      3   $ENV{'MKDEBUG'} || 0
55    ***     50     16      0   $program_name ||= $PROGRAM_NAME
56    ***     50     16      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'} || '.'
116   ***     50      0      7   $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change'
             100      1      7   $file ||= $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change'
181   ***      0      0      0   $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change'
      ***     50     16      0   $file ||= $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change'
305   ***     50    256      0   $$opt{'group'} ||= 'default'
615   ***      0      0      0   $s || 's'
624   ***      0      0      0   $prefix || ''
654   ***      0      0      0   $val || ''
657   ***     50     18      0   $val || ''
713   ***      0      0      0   $$self{'usage'} || ''
719   ***      0      0      0   $$self{'description'} || $$self{'program_name'} || ''
731   ***     50      0      7   $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change'
811   ***      0      0      0   $s ||= 's'
839   ***      0      0      0   $$opt{'type'} || ''
966   ***      0      0      0   $val || ''
980   ***      0      0      0   $pre || ''
1000  ***      0      0      0   $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change'
1062  ***     50      0      3   $ENV{'MKDEBUG'} || 0
1145  ***     50      0      3   $ENV{'MKDEBUG'} || 0
1175         100     91      8   $$opt{'copy'} || 0
1200         100      7     10   $prev ||= {}
1201  ***     50      0     17   $defaults ||= {}
1281  ***      0      0      0   $opts{$key}{'desc'} || '[No description]'
1294  ***     50      0     10   $self->prop('dbidriver') || ''
1298  ***      0      0      0   $$info{'D'} || ''
1304         100      7      3   $$info{'D'} || ''
1326  ***     50     10      0   $opts ||= {}
1431  ***      0      0      0   $$dbh{'mysql_hostinfo'} || ''
1447  ***      0      0      0   $level ||= 0
1448  ***      0      0      0   $$thing{'Type'} || 'undef'
      ***      0      0      0   $$thing{'Type'} || ''
      ***      0      0      0   $$thing{'Statement'} || ''
1505  ***     50      0      3   $ENV{'MKDEBUG'} || 0
1656  ***      0      0      0   $$self{'PID_owner'} || 0
1690  ***     50      0      3   $ENV{'MKDEBUG'} || 0
1770  ***     50      0      3   $ENV{'MKDEBUG'} || 0
1826  ***      0      0      0   $args{'p'} || 0
1828  ***      0      0      0   $of ||= 1
1833  ***      0      0      0   $secs ||= 0
1863  ***      0      0      0   $suffix || $default_suffix || 's'
2028  ***     50      0      3   $ENV{'MKDEBUG'} || 0
2248  ***     50     28      0   $engine || undef
2271  ***     50      0     12   $type || $special || 'BTREE'
2358  ***      0      0      0   $$tbl_struct{'engine'} || ''
2360  ***      0      0      0   $clustered_key ||= ''
2419  ***     50      0      3   $ENV{'MKDEBUG'} || 0
2683  ***      0      0      0   $$_[1] || ''
2724  ***     50      0      3   $ENV{'MKDEBUG'} || 0
2879  ***     50      0      1   lc $args{'chunk_range'} || 'open'
3040  ***      0      0      0   $args{'tbl_struct'}{'charset'} || ''
3115  ***      0      0      0   floor($n_values / $n_chunks) || 1
3297  ***      0      0      0   $args{'index_hint'} || ''
3616  ***      0      0      0   $base ** $power || 1
3662  ***     50      0      3   $ENV{'MKDEBUG'} || 0
3678  ***     50      5      0   $args{'name'} || 'Progress'
3803  ***     50      0      3   $ENV{'MKDEBUG'} || 0
3921  ***     50      0      3   $ENV{'MKDEBUG'} || 0
4033  ***     50      0      3   $ENV{'MKDEBUG'} || 0
4050  ***     50      7      0   $args{'tries'} || 3
4122  ***     50      0      3   $ENV{'MKDEBUG'} || 0
4157  ***     50      7      0   $$dsn{'t'} || ''
      ***     50      7      0   $$dsn{'D'} || ''
4162         100      2      5   $rename_fk_method || ''
4177  ***     50      0      7   $o->get('tmp-table') || ''

or 3 conditions

line  err      %      l  !l&&r !l&&!r   expr
----- --- ------ ------ ------ ------   ----
56    ***     33     16      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'}
      ***     33     16      0      0   $ENV{'HOME'} || $ENV{'HOMEPATH'} || $ENV{'USERPROFILE'}
610   ***     33      0      0    171   $$opt{'type'} eq 'H' or defined $val and $$opt{'type'} eq 'h'
             100      9      9    153   $$opt{'type'} eq 'A' or defined $val and $$opt{'type'} eq 'a'
719   ***      0      0      0      0   $$self{'description'} || $$self{'program_name'}
731   ***     33      0      7      0   $file ||= $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change'
733   ***     33      7      0      0   not $$self{'description'} or not $$self{'usage'}
736   ***     33      0      7      0   $$self{'description'} ||= $synop{'description'}
737   ***     33      0      7      0   $$self{'usage'} ||= $synop{'usage'}
1000  ***     33      7      0      0   $file ||= $$self{'file'} || '/home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change'
1105  ***      0      0      0      0   $$vars{'Value'} || $$vars{'value'}
1166  ***     33      0      0     99   not $$opt{'key'} or not $$opt{'desc'}
1317  ***      0      0      0      0   $$dsn{'h'} ||= $$vars{'hostname'}{'Value'}
1318  ***      0      0      0      0   $$dsn{'S'} ||= $$vars{'socket'}{'Value'}
1319  ***      0      0      0      0   $$dsn{'P'} ||= $$vars{'port'}{'Value'}
1320  ***      0      0      0      0   $$dsn{'u'} ||= $user
1321  ***      0      0      0      0   $$dsn{'D'} ||= $db
1836  ***      0      0      0      0   $fmt ||= $secs >= 86400 ? 'd' : ($secs >= 3600 ? 'h' : 'm')
1863  ***      0      0      0      0   $suffix || $default_suffix
1888  ***      0      0      0      0   $num =~ /\./ || $n
2122  ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'}
      ***      0      0      0      0   ($a ne 'PRIMARY') <=> ($b ne 'PRIMARY') or !$$tbl{'keys'}{$a}{'is_unique'} <=> !$$tbl{'keys'}{$b}{'is_unique'} or $$tbl{'keys'}{$a}{'is_nullable'} <=> $$tbl{'keys'}{$b}{'is_nullable'}
2201  ***     66     16      0     13   not $$row[0] or $$row[0] ne $tbl
2222  ***      0      0      0      0   $$row{'privileges'} || $$row{'Privileges'}
2271  ***     33      0      0     12   $type || $special
2524  ***     33     14      0      0   not $$self{'cache'} or not $$self{'tables'}{$db}{$tbl}
2563  ***      0      0      0      0   not $$self{'cache'} or not $$self{'columns'}{$db}{$tbl}
2593  ***      0      0      0      0   not $$self{'cache'} or not $$self{'triggers'}{$db}
2627  ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'databases'} or $like
2646  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_status'}{$db} or $like
2660  ***      0      0      0      0   $tbl{'type'} || $tbl{'comment'}
      ***      0      0      0      0   $tbl{'engine'} ||= $tbl{'type'} || $tbl{'comment'}
2672  ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db}
      ***      0      0      0      0   not $$self{'cache'} or not $$self{'table_list'}{$db} or $like
2781  ***     33      8      0      0   $$self{'int_types'}{$col_type} or $$self{'real_types'}{$col_type}
      ***     33      8      0      0   $$self{'int_types'}{$col_type} or $$self{'real_types'}{$col_type} or $col_type =~ /char/
2846  ***     33      1      0      0   $$tbl_struct{'is_numeric'}{$chunk_col} or $col_type =~ /date|time/
2958  ***     33      0      0      1   not defined $end_point or $end_point < $start_point
2994  ***     33      1      0      0   $interval ||= $args{'chunk_size'}
3214  ***      0      0      0      0   $suffix or $args{'avg_row_length'}
3669  ***     33      5      0      0   not $args{'report'} or not $args{'interval'}
3679  ***     33      0      5      0   $args{'start'} ||= time
3718  ***      0      0      0      0   $start || time
3724  ***     33      0      7      0   $now ||= time
4230  ***     33      0      7      0   $o->get('tmp-table') || "__tmp_$tbl"
4566  ***     66      1      0      8   not $exact or not @chunkable_cols


Covered Subroutines
-------------------

Subroutine                     Count Location                                                                           
------------------------------ ----- -----------------------------------------------------------------------------------
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1057
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1058
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1060
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1062
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1142
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1143
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1144
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1145
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1147
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1499
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1500
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1502
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1503
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1505
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1686
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1687
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1688
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1690
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1764
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1765
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1766
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1767
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1768
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1770
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:19  
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:20  
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2020
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2021
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2022
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2023
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2028
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2414
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2415
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2417
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2419
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2721
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2722
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2723
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2724
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2726
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2727
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2728
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3653
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3654
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3656
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3657
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3662
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:37  
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:38  
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3800
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3801
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3802
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3803
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:39  
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3918
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3919
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3920
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3921
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:40  
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4030
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4031
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4032
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4033
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:41  
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4113
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4114
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4115
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4122
BEGIN                              3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:43  
DSNParser                          7 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:170 
__ANON__                          72 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:130 
__ANON__                           1 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3968
__ANON__                           8 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3971
__ANON__                          22 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:484 
__set_quiet                        1 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4694
_check_opts                        9 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:527 
_chunk_numeric                     1 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2903
_get_participants                  8 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:384 
_get_valid_end_point               6 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3466
_make_triggers                     3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3837
_parse_attribs                   256 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:989 
_parse_specs                       8 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:269 
_parse_synopsis                    7 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:999 
_pod_to_specs                     16 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:180 
_read_config_file                 36 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:888 
_set_option                       22 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:430 
_use_db                           14 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2511
_validate_type                   288 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:600 
calculate_chunks                   5 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2818
capture                            3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3820
check_table                       29 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2180
check_tables                      12 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4509
cleanup                            4 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3877
cleanup                            4 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4001
copy                               3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3938
find_chunk_columns                 9 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2753
get                              253 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:669 
get_child_tables                   2 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4588
get_create_table                  14 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2523
get_cxn                            7 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4670
get_cxn_params                    10 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1291
get_dbh                           10 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1325
get_defaults_files                 8 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:175 
get_engine                        28 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2245
get_keys                          14 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2252
get_opts                           9 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:447 
get_range_statistics               5 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3226
get_specs                          8 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:115 
get_valid_end_points               5 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3422
got                               36 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:677 
has                               72 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:685 
intersection                       3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4662
literal_like                      29 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1728
main                               7 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4127
msg                              128 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4685
new                                8 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1065
new                               11 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1158
new                                8 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1693
new                                8 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2031
new                                8 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2446
new                                8 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2734
new                                5 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3665
new                                7 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3806
new                                7 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3924
new                                7 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4036
new                               16 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:48  
parse                             19 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1070
parse                             17 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1194
parse                             14 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2041
parse_options                      7 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1250
prop                              51 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1185
quote                            104 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1698
quote_val                         10 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1706
range_num                          5 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3352
retry                              7 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4044
set                                2 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:691 
split_unquote                     21 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1717
sync                               3 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3868
ts                               100 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1896
update                             7 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3722
usage_or_errors                    7 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:730 
validate_spec                      7 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3697
value_to_number                    2 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3311
version_ge                        12 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1077

Uncovered Subroutines
---------------------

Subroutine                     Count Location                                                                           
------------------------------ ----- -----------------------------------------------------------------------------------
DESTROY                            0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1654
__ANON__                           0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3118
__ANON__                           0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3569
__ANON__                           0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3685
__ANON__                           0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3988
__ANON__                           0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3992
__ANON__                           0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4269
_chunk_char                        0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3011
_d                                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1034
_d                                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1118
_d                                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1475
_d                                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1662
_d                                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1996
_d                                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2391
_d                                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2697
_d                                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3630
_d                                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3776
_d                                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3894
_d                                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4006
_d                                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4090
_d                                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4698
_make_PID_file                     0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1619
_parse_size                        0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:964 
_remove_PID_file                   0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1641
_validate_temporal_value           0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3542
any_unix_timestamp                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1939
as_string                          0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1263
base_count                         0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3600
check_PID_file                     0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1578
clone                              0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:941 
copy                               0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1457
crc32                              0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1981
daemonize                          0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1526
descr                              0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:717 
disconnect                         0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1440
dump                               0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2454
errors                             0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:706 
fill_in_dsn                        0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1313
find_best_index                    0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2134
find_possible_keys                 0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2152
fraction_modulo                    0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3769
get_columns                        0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2561
get_databases                      0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2626
get_defaults                       0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:420 
get_first_chunkable_column         0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3142
get_first_valid_value              0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3497
get_fks                            0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2319
get_groups                         0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:425 
get_hostname                       0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1430
get_nonzero_value                  0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3559
get_table_list                     0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2671
get_table_status                   0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2645
get_tmp_table                      0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2581
get_triggers                       0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2592
inject_chunks                      0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3280
innodb_version                     0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1088
join_quote                         0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1735
make_PID_file                      0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1609
make_checksum                      0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1974
micro_t                            0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1795
new                                0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1508
opts                               0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:396 
parse_timestamp                    0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1912
percentage_of                      0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1825
print_active_handles               0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1446
print_errors                       0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:755 
print_usage                        0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:765 
prompt_noecho                      0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:853 
range_date                         0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3378
range_datetime                     0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3385
range_time                         0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3371
range_timestamp                    0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3393
read_para_after                    0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:922 
remove_auto_increment              0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2348
remove_secondary_indexes           0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2354
save_error                         0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:700 
secs_to_time                       0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1832
set_callback                       0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3712
set_defaults                       0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:408 
short_opts                         0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:402 
shorten                            0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1879
size_to_rows                       0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3189
sort_indexes                       0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:2115
start                              0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3717
time_to_secs                       0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1859
timestampdiff                      0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:3400
unix_timestamp                     0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1924
update_foreign_key_constraints     0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:4614
usage                              0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:1274
usage                              0 /home/daniel/dev/maatkit/trunk/mk-online-schema-change/mk-online-schema-change:711 


