#!/usr/bin/env perl

# This program is copyright 2010 Percona Inc.
# Feedback and improvements are welcome.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
# systems, you can issue `man perlgpl' or `man perlartistic' to read these
# licenses.
#
# You should have received a copy of the GNU General Public License along with
# this program; if not, write to the Free Software Foundation, Inc., 59 Temple
# Place, Suite 330, Boston, MA  02111-1307  USA.

use strict;
use warnings FATAL => 'all';

our $VERSION = '@VERSION@';
our $DISTRIB = '@DISTRIB@';
our $SVN_REV = sprintf("%d", (q$Revision: 6451 $ =~ m/(\d+)/g, 0));

# ###########################################################################
# OptionParser package 6322
# This package is a copy without comments from the original.  The original
# with comments and its test file can be found in the SVN repository at,
#   trunk/common/OptionParser.pm
#   trunk/common/t/OptionParser.t
# See http://code.google.com/p/maatkit/wiki/Developers for more information.
# ###########################################################################
package OptionParser;

use strict;
use warnings FATAL => 'all';

use Getopt::Long;
use List::Util qw(max);
use English qw(-no_match_vars);

use constant MKDEBUG => $ENV{MKDEBUG} || 0;

my $POD_link_re = '[LC]<"?([^">]+)"?>';

sub new {
   my ( $class, %args ) = @_;
   foreach my $arg ( qw(description) ) {
      die "I need a $arg argument" unless $args{$arg};
   }

   my ($program_name) = $PROGRAM_NAME =~ m/([.A-Za-z-]+)$/;
   $program_name ||= $PROGRAM_NAME;
   my $home = $ENV{HOME} || $ENV{HOMEPATH} || $ENV{USERPROFILE} || '.';

   my %attributes = (
      'type'       => 1,
      'short form' => 1,
      'group'      => 1,
      'default'    => 1,
      'cumulative' => 1,
      'negatable'  => 1,
   );

   my $self = {
      strict            => 1,
      prompt            => '<options>',
      head1             => 'OPTIONS',
      skip_rules        => 0,
      item              => '--(.*)',
      attributes        => \%attributes,
      parse_attributes  => \&_parse_attribs,

      %args,

      program_name      => $program_name,
      opts              => {},
      got_opts          => 0,
      short_opts        => {},
      defaults          => {},
      groups            => {},
      allowed_groups    => {},
      errors            => [],
      rules             => [],  # desc of rules for --help
      mutex             => [],  # rule: opts are mutually exclusive
      atleast1          => [],  # rule: at least one opt is required
      disables          => {},  # rule: opt disables other opts 
      defaults_to       => {},  # rule: opt defaults to value of other opt
      DSNParser         => undef,
      default_files     => [
         "/etc/maatkit/maatkit.conf",
         "/etc/maatkit/$program_name.conf",
         "$home/.maatkit.conf",
         "$home/.$program_name.conf",
      ],
      types             => {
         string => 's', # standard Getopt type
         int    => 'i', # standard Getopt type
         float  => 'f', # standard Getopt type
         Hash   => 'H', # hash, formed from a comma-separated list
         hash   => 'h', # hash as above, but only if a value is given
         Array  => 'A', # array, similar to Hash
         array  => 'a', # array, similar to hash
         DSN    => 'd', # DSN
         size   => 'z', # size with kMG suffix (powers of 2^10)
         time   => 'm', # time, with an optional suffix of s/h/m/d
      },
   };

   return bless $self, $class;
}

sub get_specs {
   my ( $self, $file ) = @_;
   $file ||= __FILE__;
   my @specs = $self->_pod_to_specs($file);
   $self->_parse_specs(@specs);

   open my $fh, "<", $file or die "Cannot open $file: $OS_ERROR";
   my $contents = do { local $/ = undef; <$fh> };
   close $file;
   if ( $contents =~ m/^=head1 DSN OPTIONS/m ) {
      MKDEBUG && _d('Parsing DSN OPTIONS');
      my $dsn_attribs = {
         dsn  => 1,
         copy => 1,
      };
      my $parse_dsn_attribs = sub {
         my ( $self, $option, $attribs ) = @_;
         map {
            my $val = $attribs->{$_};
            if ( $val ) {
               $val    = $val eq 'yes' ? 1
                       : $val eq 'no'  ? 0
                       :                 $val;
               $attribs->{$_} = $val;
            }
         } keys %$attribs;
         return {
            key => $option,
            %$attribs,
         };
      };
      my $dsn_o = new OptionParser(
         description       => 'DSN OPTIONS',
         head1             => 'DSN OPTIONS',
         dsn               => 0,         # XXX don't infinitely recurse!
         item              => '\* (.)',  # key opts are a single character
         skip_rules        => 1,         # no rules before opts
         attributes        => $dsn_attribs,
         parse_attributes  => $parse_dsn_attribs,
      );
      my @dsn_opts = map {
         my $opts = {
            key  => $_->{spec}->{key},
            dsn  => $_->{spec}->{dsn},
            copy => $_->{spec}->{copy},
            desc => $_->{desc},
         };
         $opts;
      } $dsn_o->_pod_to_specs($file);
      $self->{DSNParser} = DSNParser->new(opts => \@dsn_opts);
   }

   return;
}

sub DSNParser {
   my ( $self ) = @_;
   return $self->{DSNParser};
};

sub get_defaults_files {
   my ( $self ) = @_;
   return @{$self->{default_files}};
}

sub _pod_to_specs {
   my ( $self, $file ) = @_;
   $file ||= __FILE__;
   open my $fh, '<', $file or die "Cannot open $file: $OS_ERROR";

   my @specs = ();
   my @rules = ();
   my $para;

   local $INPUT_RECORD_SEPARATOR = '';
   while ( $para = <$fh> ) {
      next unless $para =~ m/^=head1 $self->{head1}/;
      last;
   }

   while ( $para = <$fh> ) {
      last if $para =~ m/^=over/;
      next if $self->{skip_rules};
      chomp $para;
      $para =~ s/\s+/ /g;
      $para =~ s/$POD_link_re/$1/go;
      MKDEBUG && _d('Option rule:', $para);
      push @rules, $para;
   }

   die "POD has no $self->{head1} section" unless $para;

   do {
      if ( my ($option) = $para =~ m/^=item $self->{item}/ ) {
         chomp $para;
         MKDEBUG && _d($para);
         my %attribs;

         $para = <$fh>; # read next paragraph, possibly attributes

         if ( $para =~ m/: / ) { # attributes
            $para =~ s/\s+\Z//g;
            %attribs = map {
                  my ( $attrib, $val) = split(/: /, $_);
                  die "Unrecognized attribute for --$option: $attrib"
                     unless $self->{attributes}->{$attrib};
                  ($attrib, $val);
               } split(/; /, $para);
            if ( $attribs{'short form'} ) {
               $attribs{'short form'} =~ s/-//;
            }
            $para = <$fh>; # read next paragraph, probably short help desc
         }
         else {
            MKDEBUG && _d('Option has no attributes');
         }

         $para =~ s/\s+\Z//g;
         $para =~ s/\s+/ /g;
         $para =~ s/$POD_link_re/$1/go;

         $para =~ s/\.(?:\n.*| [A-Z].*|\Z)//s;
         MKDEBUG && _d('Short help:', $para);

         die "No description after option spec $option" if $para =~ m/^=item/;

         if ( my ($base_option) =  $option =~ m/^\[no\](.*)/ ) {
            $option = $base_option;
            $attribs{'negatable'} = 1;
         }

         push @specs, {
            spec  => $self->{parse_attributes}->($self, $option, \%attribs), 
            desc  => $para
               . ($attribs{default} ? " (default $attribs{default})" : ''),
            group => ($attribs{'group'} ? $attribs{'group'} : 'default'),
         };
      }
      while ( $para = <$fh> ) {
         last unless $para;
         if ( $para =~ m/^=head1/ ) {
            $para = undef; # Can't 'last' out of a do {} block.
            last;
         }
         last if $para =~ m/^=item /;
      }
   } while ( $para );

   die "No valid specs in $self->{head1}" unless @specs;

   close $fh;
   return @specs, @rules;
}

sub _parse_specs {
   my ( $self, @specs ) = @_;
   my %disables; # special rule that requires deferred checking

   foreach my $opt ( @specs ) {
      if ( ref $opt ) { # It's an option spec, not a rule.
         MKDEBUG && _d('Parsing opt spec:',
            map { ($_, '=>', $opt->{$_}) } keys %$opt);

         my ( $long, $short ) = $opt->{spec} =~ m/^([\w-]+)(?:\|([^!+=]*))?/;
         if ( !$long ) {
            die "Cannot parse long option from spec $opt->{spec}";
         }
         $opt->{long} = $long;

         die "Duplicate long option --$long" if exists $self->{opts}->{$long};
         $self->{opts}->{$long} = $opt;

         if ( length $long == 1 ) {
            MKDEBUG && _d('Long opt', $long, 'looks like short opt');
            $self->{short_opts}->{$long} = $long;
         }

         if ( $short ) {
            die "Duplicate short option -$short"
               if exists $self->{short_opts}->{$short};
            $self->{short_opts}->{$short} = $long;
            $opt->{short} = $short;
         }
         else {
            $opt->{short} = undef;
         }

         $opt->{is_negatable}  = $opt->{spec} =~ m/!/        ? 1 : 0;
         $opt->{is_cumulative} = $opt->{spec} =~ m/\+/       ? 1 : 0;
         $opt->{is_required}   = $opt->{desc} =~ m/required/ ? 1 : 0;

         $opt->{group} ||= 'default';
         $self->{groups}->{ $opt->{group} }->{$long} = 1;

         $opt->{value} = undef;
         $opt->{got}   = 0;

         my ( $type ) = $opt->{spec} =~ m/=(.)/;
         $opt->{type} = $type;
         MKDEBUG && _d($long, 'type:', $type);


         $opt->{spec} =~ s/=./=s/ if ( $type && $type =~ m/[HhAadzm]/ );

         if ( (my ($def) = $opt->{desc} =~ m/default\b(?: ([^)]+))?/) ) {
            $self->{defaults}->{$long} = defined $def ? $def : 1;
            MKDEBUG && _d($long, 'default:', $def);
         }

         if ( $long eq 'config' ) {
            $self->{defaults}->{$long} = join(',', $self->get_defaults_files());
         }

         if ( (my ($dis) = $opt->{desc} =~ m/(disables .*)/) ) {
            $disables{$long} = $dis;
            MKDEBUG && _d('Deferring check of disables rule for', $opt, $dis);
         }

         $self->{opts}->{$long} = $opt;
      }
      else { # It's an option rule, not a spec.
         MKDEBUG && _d('Parsing rule:', $opt); 
         push @{$self->{rules}}, $opt;
         my @participants = $self->_get_participants($opt);
         my $rule_ok = 0;

         if ( $opt =~ m/mutually exclusive|one and only one/ ) {
            $rule_ok = 1;
            push @{$self->{mutex}}, \@participants;
            MKDEBUG && _d(@participants, 'are mutually exclusive');
         }
         if ( $opt =~ m/at least one|one and only one/ ) {
            $rule_ok = 1;
            push @{$self->{atleast1}}, \@participants;
            MKDEBUG && _d(@participants, 'require at least one');
         }
         if ( $opt =~ m/default to/ ) {
            $rule_ok = 1;
            $self->{defaults_to}->{$participants[0]} = $participants[1];
            MKDEBUG && _d($participants[0], 'defaults to', $participants[1]);
         }
         if ( $opt =~ m/restricted to option groups/ ) {
            $rule_ok = 1;
            my ($groups) = $opt =~ m/groups ([\w\s\,]+)/;
            my @groups = split(',', $groups);
            %{$self->{allowed_groups}->{$participants[0]}} = map {
               s/\s+//;
               $_ => 1;
            } @groups;
         }

         die "Unrecognized option rule: $opt" unless $rule_ok;
      }
   }

   foreach my $long ( keys %disables ) {
      my @participants = $self->_get_participants($disables{$long});
      $self->{disables}->{$long} = \@participants;
      MKDEBUG && _d('Option', $long, 'disables', @participants);
   }

   return; 
}

sub _get_participants {
   my ( $self, $str ) = @_;
   my @participants;
   foreach my $long ( $str =~ m/--(?:\[no\])?([\w-]+)/g ) {
      die "Option --$long does not exist while processing rule $str"
         unless exists $self->{opts}->{$long};
      push @participants, $long;
   }
   MKDEBUG && _d('Participants for', $str, ':', @participants);
   return @participants;
}

sub opts {
   my ( $self ) = @_;
   my %opts = %{$self->{opts}};
   return %opts;
}

sub short_opts {
   my ( $self ) = @_;
   my %short_opts = %{$self->{short_opts}};
   return %short_opts;
}

sub set_defaults {
   my ( $self, %defaults ) = @_;
   $self->{defaults} = {};
   foreach my $long ( keys %defaults ) {
      die "Cannot set default for nonexistent option $long"
         unless exists $self->{opts}->{$long};
      $self->{defaults}->{$long} = $defaults{$long};
      MKDEBUG && _d('Default val for', $long, ':', $defaults{$long});
   }
   return;
}

sub get_defaults {
   my ( $self ) = @_;
   return $self->{defaults};
}

sub get_groups {
   my ( $self ) = @_;
   return $self->{groups};
}

sub _set_option {
   my ( $self, $opt, $val ) = @_;
   my $long = exists $self->{opts}->{$opt}       ? $opt
            : exists $self->{short_opts}->{$opt} ? $self->{short_opts}->{$opt}
            : die "Getopt::Long gave a nonexistent option: $opt";

   $opt = $self->{opts}->{$long};
   if ( $opt->{is_cumulative} ) {
      $opt->{value}++;
   }
   else {
      $opt->{value} = $val;
   }
   $opt->{got} = 1;
   MKDEBUG && _d('Got option', $long, '=', $val);
}

sub get_opts {
   my ( $self ) = @_; 

   foreach my $long ( keys %{$self->{opts}} ) {
      $self->{opts}->{$long}->{got} = 0;
      $self->{opts}->{$long}->{value}
         = exists $self->{defaults}->{$long}       ? $self->{defaults}->{$long}
         : $self->{opts}->{$long}->{is_cumulative} ? 0
         : undef;
   }
   $self->{got_opts} = 0;

   $self->{errors} = [];

   if ( @ARGV && $ARGV[0] eq "--config" ) {
      shift @ARGV;
      $self->_set_option('config', shift @ARGV);
   }
   if ( $self->has('config') ) {
      my @extra_args;
      foreach my $filename ( split(',', $self->get('config')) ) {
         eval {
            push @extra_args, $self->_read_config_file($filename);
         };
         if ( $EVAL_ERROR ) {
            if ( $self->got('config') ) {
               die $EVAL_ERROR;
            }
            elsif ( MKDEBUG ) {
               _d($EVAL_ERROR);
            }
         }
      }
      unshift @ARGV, @extra_args;
   }

   Getopt::Long::Configure('no_ignore_case', 'bundling');
   GetOptions(
      map    { $_->{spec} => sub { $self->_set_option(@_); } }
      grep   { $_->{long} ne 'config' } # --config is handled specially above.
      values %{$self->{opts}}
   ) or $self->save_error('Error parsing options');

   if ( exists $self->{opts}->{version} && $self->{opts}->{version}->{got} ) {
      printf("%s  Ver %s Distrib %s Changeset %s\n",
         $self->{program_name}, $main::VERSION, $main::DISTRIB, $main::SVN_REV)
            or die "Cannot print: $OS_ERROR";
      exit 0;
   }

   if ( @ARGV && $self->{strict} ) {
      $self->save_error("Unrecognized command-line options @ARGV");
   }

   foreach my $mutex ( @{$self->{mutex}} ) {
      my @set = grep { $self->{opts}->{$_}->{got} } @$mutex;
      if ( @set > 1 ) {
         my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
                      @{$mutex}[ 0 .. scalar(@$mutex) - 2] )
                 . ' and --'.$self->{opts}->{$mutex->[-1]}->{long}
                 . ' are mutually exclusive.';
         $self->save_error($err);
      }
   }

   foreach my $required ( @{$self->{atleast1}} ) {
      my @set = grep { $self->{opts}->{$_}->{got} } @$required;
      if ( @set == 0 ) {
         my $err = join(', ', map { "--$self->{opts}->{$_}->{long}" }
                      @{$required}[ 0 .. scalar(@$required) - 2] )
                 .' or --'.$self->{opts}->{$required->[-1]}->{long};
         $self->save_error("Specify at least one of $err");
      }
   }

   $self->_check_opts( keys %{$self->{opts}} );
   $self->{got_opts} = 1;
   return;
}

sub _check_opts {
   my ( $self, @long ) = @_;
   my $long_last = scalar @long;
   while ( @long ) {
      foreach my $i ( 0..$#long ) {
         my $long = $long[$i];
         next unless $long;
         my $opt  = $self->{opts}->{$long};
         if ( $opt->{got} ) {
            if ( exists $self->{disables}->{$long} ) {
               my @disable_opts = @{$self->{disables}->{$long}};
               map { $self->{opts}->{$_}->{value} = undef; } @disable_opts;
               MKDEBUG && _d('Unset options', @disable_opts,
                  'because', $long,'disables them');
            }

            if ( exists $self->{allowed_groups}->{$long} ) {

               my @restricted_groups = grep {
                  !exists $self->{allowed_groups}->{$long}->{$_}
               } keys %{$self->{groups}};

               my @restricted_opts;
               foreach my $restricted_group ( @restricted_groups ) {
                  RESTRICTED_OPT:
                  foreach my $restricted_opt (
                     keys %{$self->{groups}->{$restricted_group}} )
                  {
                     next RESTRICTED_OPT if $restricted_opt eq $long;
                     push @restricted_opts, $restricted_opt
                        if $self->{opts}->{$restricted_opt}->{got};
                  }
               }

               if ( @restricted_opts ) {
                  my $err;
                  if ( @restricted_opts == 1 ) {
                     $err = "--$restricted_opts[0]";
                  }
                  else {
                     $err = join(', ',
                               map { "--$self->{opts}->{$_}->{long}" }
                               grep { $_ } 
                               @restricted_opts[0..scalar(@restricted_opts) - 2]
                            )
                          . ' or --'.$self->{opts}->{$restricted_opts[-1]}->{long};
                  }
                  $self->save_error("--$long is not allowed with $err");
               }
            }

         }
         elsif ( $opt->{is_required} ) { 
            $self->save_error("Required option --$long must be specified");
         }

         $self->_validate_type($opt);
         if ( $opt->{parsed} ) {
            delete $long[$i];
         }
         else {
            MKDEBUG && _d('Temporarily failed to parse', $long);
         }
      }

      die "Failed to parse options, possibly due to circular dependencies"
         if @long == $long_last;
      $long_last = @long;
   }

   return;
}

sub _validate_type {
   my ( $self, $opt ) = @_;
   return unless $opt;

   if ( !$opt->{type} ) {
      $opt->{parsed} = 1;
      return;
   }

   my $val = $opt->{value};

   if ( $val && $opt->{type} eq 'm' ) {  # type time
      MKDEBUG && _d('Parsing option', $opt->{long}, 'as a time value');
      my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
      if ( !$suffix ) {
         my ( $s ) = $opt->{desc} =~ m/\(suffix (.)\)/;
         $suffix = $s || 's';
         MKDEBUG && _d('No suffix given; using', $suffix, 'for',
            $opt->{long}, '(value:', $val, ')');
      }
      if ( $suffix =~ m/[smhd]/ ) {
         $val = $suffix eq 's' ? $num            # Seconds
              : $suffix eq 'm' ? $num * 60       # Minutes
              : $suffix eq 'h' ? $num * 3600     # Hours
              :                  $num * 86400;   # Days
         $opt->{value} = ($prefix || '') . $val;
         MKDEBUG && _d('Setting option', $opt->{long}, 'to', $val);
      }
      else {
         $self->save_error("Invalid time suffix for --$opt->{long}");
      }
   }
   elsif ( $val && $opt->{type} eq 'd' ) {  # type DSN
      MKDEBUG && _d('Parsing option', $opt->{long}, 'as a DSN');
      my $prev = {};
      my $from_key = $self->{defaults_to}->{ $opt->{long} };
      if ( $from_key ) {
         MKDEBUG && _d($opt->{long}, 'DSN copies from', $from_key, 'DSN');
         if ( $self->{opts}->{$from_key}->{parsed} ) {
            $prev = $self->{opts}->{$from_key}->{value};
         }
         else {
            MKDEBUG && _d('Cannot parse', $opt->{long}, 'until',
               $from_key, 'parsed');
            return;
         }
      }
      my $defaults = $self->{DSNParser}->parse_options($self);
      $opt->{value} = $self->{DSNParser}->parse($val, $prev, $defaults);
   }
   elsif ( $val && $opt->{type} eq 'z' ) {  # type size
      MKDEBUG && _d('Parsing option', $opt->{long}, 'as a size value');
      $self->_parse_size($opt, $val);
   }
   elsif ( $opt->{type} eq 'H' || (defined $val && $opt->{type} eq 'h') ) {
      $opt->{value} = { map { $_ => 1 } split(/(?<!\\),\s*/, ($val || '')) };
   }
   elsif ( $opt->{type} eq 'A' || (defined $val && $opt->{type} eq 'a') ) {
      $opt->{value} = [ split(/(?<!\\),\s*/, ($val || '')) ];
   }
   else {
      MKDEBUG && _d('Nothing to validate for option',
         $opt->{long}, 'type', $opt->{type}, 'value', $val);
   }

   $opt->{parsed} = 1;
   return;
}

sub get {
   my ( $self, $opt ) = @_;
   my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
   die "Option $opt does not exist"
      unless $long && exists $self->{opts}->{$long};
   return $self->{opts}->{$long}->{value};
}

sub got {
   my ( $self, $opt ) = @_;
   my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
   die "Option $opt does not exist"
      unless $long && exists $self->{opts}->{$long};
   return $self->{opts}->{$long}->{got};
}

sub has {
   my ( $self, $opt ) = @_;
   my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
   return defined $long ? exists $self->{opts}->{$long} : 0;
}

sub set {
   my ( $self, $opt, $val ) = @_;
   my $long = (length $opt == 1 ? $self->{short_opts}->{$opt} : $opt);
   die "Option $opt does not exist"
      unless $long && exists $self->{opts}->{$long};
   $self->{opts}->{$long}->{value} = $val;
   return;
}

sub save_error {
   my ( $self, $error ) = @_;
   push @{$self->{errors}}, $error;
}

sub errors {
   my ( $self ) = @_;
   return $self->{errors};
}

sub prompt {
   my ( $self ) = @_;
   return "Usage: $PROGRAM_NAME $self->{prompt}\n";
}

sub descr {
   my ( $self ) = @_;
   my $descr  = $self->{program_name} . ' ' . ($self->{description} || '')
              . "  For more details, please use the --help option, "
              . "or try 'perldoc $PROGRAM_NAME' "
              . "for complete documentation.";
   $descr = join("\n", $descr =~ m/(.{0,80})(?:\s+|$)/g)
      unless $ENV{DONT_BREAK_LINES};
   $descr =~ s/ +$//mg;
   return $descr;
}

sub usage_or_errors {
   my ( $self ) = @_;
   if ( $self->{opts}->{help}->{got} ) {
      print $self->print_usage() or die "Cannot print usage: $OS_ERROR";
      exit 0;
   }
   elsif ( scalar @{$self->{errors}} ) {
      print $self->print_errors() or die "Cannot print errors: $OS_ERROR";
      exit 0;
   }
   return;
}

sub print_errors {
   my ( $self ) = @_;
   my $usage = $self->prompt() . "\n";
   if ( (my @errors = @{$self->{errors}}) ) {
      $usage .= join("\n  * ", 'Errors in command-line arguments:', @errors)
              . "\n";
   }
   return $usage . "\n" . $self->descr();
}

sub print_usage {
   my ( $self ) = @_;
   die "Run get_opts() before print_usage()" unless $self->{got_opts};
   my @opts = values %{$self->{opts}};

   my $maxl = max(
      map { length($_->{long}) + ($_->{is_negatable} ? 4 : 0) }
      @opts);

   my $maxs = max(0,
      map { length($_) + ($self->{opts}->{$_}->{is_negatable} ? 4 : 0) }
      values %{$self->{short_opts}});

   my $lcol = max($maxl, ($maxs + 3));
   my $rcol = 80 - $lcol - 6;
   my $rpad = ' ' x ( 80 - $rcol );

   $maxs = max($lcol - 3, $maxs);

   my $usage = $self->descr() . "\n" . $self->prompt();

   my @groups = reverse sort grep { $_ ne 'default'; } keys %{$self->{groups}};
   push @groups, 'default';

   foreach my $group ( reverse @groups ) {
      $usage .= "\n".($group eq 'default' ? 'Options' : $group).":\n\n";
      foreach my $opt (
         sort { $a->{long} cmp $b->{long} }
         grep { $_->{group} eq $group }
         @opts )
      {
         my $long  = $opt->{is_negatable} ? "[no]$opt->{long}" : $opt->{long};
         my $short = $opt->{short};
         my $desc  = $opt->{desc};
         if ( $opt->{type} && $opt->{type} eq 'm' ) {
            my ($s) = $desc =~ m/\(suffix (.)\)/;
            $s    ||= 's';
            $desc =~ s/\s+\(suffix .\)//;
            $desc .= ".  Optional suffix s=seconds, m=minutes, h=hours, "
                   . "d=days; if no suffix, $s is used.";
         }
         $desc = join("\n$rpad", grep { $_ } $desc =~ m/(.{0,$rcol})(?:\s+|$)/g);
         $desc =~ s/ +$//mg;
         if ( $short ) {
            $usage .= sprintf("  --%-${maxs}s -%s  %s\n", $long, $short, $desc);
         }
         else {
            $usage .= sprintf("  --%-${lcol}s  %s\n", $long, $desc);
         }
      }
   }

   if ( (my @rules = @{$self->{rules}}) ) {
      $usage .= "\nRules:\n\n";
      $usage .= join("\n", map { "  $_" } @rules) . "\n";
   }
   if ( $self->{DSNParser} ) {
      $usage .= "\n" . $self->{DSNParser}->usage();
   }
   $usage .= "\nOptions and values after processing arguments:\n\n";
   foreach my $opt ( sort { $a->{long} cmp $b->{long} } @opts ) {
      my $val   = $opt->{value};
      my $type  = $opt->{type} || '';
      my $bool  = $opt->{spec} =~ m/^[\w-]+(?:\|[\w-])?!?$/;
      $val      = $bool              ? ( $val ? 'TRUE' : 'FALSE' )
                : !defined $val      ? '(No value)'
                : $type eq 'd'       ? $self->{DSNParser}->as_string($val)
                : $type =~ m/H|h/    ? join(',', sort keys %$val)
                : $type =~ m/A|a/    ? join(',', @$val)
                :                    $val;
      $usage .= sprintf("  --%-${lcol}s  %s\n", $opt->{long}, $val);
   }
   return $usage;
}

sub prompt_noecho {
   shift @_ if ref $_[0] eq __PACKAGE__;
   my ( $prompt ) = @_;
   local $OUTPUT_AUTOFLUSH = 1;
   print $prompt
      or die "Cannot print: $OS_ERROR";
   my $response;
   eval {
      require Term::ReadKey;
      Term::ReadKey::ReadMode('noecho');
      chomp($response = <STDIN>);
      Term::ReadKey::ReadMode('normal');
      print "\n"
         or die "Cannot print: $OS_ERROR";
   };
   if ( $EVAL_ERROR ) {
      die "Cannot read response; is Term::ReadKey installed? $EVAL_ERROR";
   }
   return $response;
}

if ( MKDEBUG ) {
   print '# ', $^X, ' ', $], "\n";
   my $uname = `uname -a`;
   if ( $uname ) {
      $uname =~ s/\s+/ /g;
      print "# $uname\n";
   }
   printf("# %s  Ver %s Distrib %s Changeset %s line %d\n",
      $PROGRAM_NAME, ($main::VERSION || ''), ($main::DISTRIB || ''),
      ($main::SVN_REV || ''), __LINE__);
   print('# Arguments: ',
      join(' ', map { my $a = "_[$_]_"; $a =~ s/\n/\n# /g; $a; } @ARGV), "\n");
}

sub _read_config_file {
   my ( $self, $filename ) = @_;
   open my $fh, "<", $filename or die "Cannot open $filename: $OS_ERROR\n";
   my @args;
   my $prefix = '--';
   my $parse  = 1;

   LINE:
   while ( my $line = <$fh> ) {
      chomp $line;
      next LINE if $line =~ m/^\s*(?:\#|\;|$)/;
      $line =~ s/\s+#.*$//g;
      $line =~ s/^\s+|\s+$//g;
      if ( $line eq '--' ) {
         $prefix = '';
         $parse  = 0;
         next LINE;
      }
      if ( $parse
         && (my($opt, $arg) = $line =~ m/^\s*([^=\s]+?)(?:\s*=\s*(.*?)\s*)?$/)
      ) {
         push @args, grep { defined $_ } ("$prefix$opt", $arg);
      }
      elsif ( $line =~ m/./ ) {
         push @args, $line;
      }
      else {
         die "Syntax error in file $filename at line $INPUT_LINE_NUMBER";
      }
   }
   close $fh;
   return @args;
}

sub read_para_after {
   my ( $self, $file, $regex ) = @_;
   open my $fh, "<", $file or die "Can't open $file: $OS_ERROR";
   local $INPUT_RECORD_SEPARATOR = '';
   my $para;
   while ( $para = <$fh> ) {
      next unless $para =~ m/^=pod$/m;
      last;
   }
   while ( $para = <$fh> ) {
      next unless $para =~ m/$regex/;
      last;
   }
   $para = <$fh>;
   chomp($para);
   close $fh or die "Can't close $file: $OS_ERROR";
   return $para;
}

sub clone {
   my ( $self ) = @_;

   my %clone = map {
      my $hashref  = $self->{$_};
      my $val_copy = {};
      foreach my $key ( keys %$hashref ) {
         my $ref = ref $hashref->{$key};
         $val_copy->{$key} = !$ref           ? $hashref->{$key}
                           : $ref eq 'HASH'  ? { %{$hashref->{$key}} }
                           : $ref eq 'ARRAY' ? [ @{$hashref->{$key}} ]
                           : $hashref->{$key};
      }
      $_ => $val_copy;
   } qw(opts short_opts defaults);

   foreach my $scalar ( qw(got_opts) ) {
      $clone{$scalar} = $self->{$scalar};
   }

   return bless \%clone;     
}

sub _parse_size {
   my ( $self, $opt, $val ) = @_;

   if ( lc($val || '') eq 'null' ) {
      MKDEBUG && _d('NULL size for', $opt->{long});
      $opt->{value} = 'null';
      return;
   }

   my %factor_for = (k => 1_024, M => 1_048_576, G => 1_073_741_824);
   my ($pre, $num, $factor) = $val =~ m/^([+-])?(\d+)([kMG])?$/;
   if ( defined $num ) {
      if ( $factor ) {
         $num *= $factor_for{$factor};
         MKDEBUG && _d('Setting option', $opt->{y},
            'to num', $num, '* factor', $factor);
      }
      $opt->{value} = ($pre || '') . $num;
   }
   else {
      $self->save_error("Invalid size for --$opt->{long}");
   }
   return;
}

sub _parse_attribs {
   my ( $self, $option, $attribs ) = @_;
   my $types = $self->{types};
   return $option
      . ($attribs->{'short form'} ? '|' . $attribs->{'short form'}   : '' )
      . ($attribs->{'negatable'}  ? '!'                              : '' )
      . ($attribs->{'cumulative'} ? '+'                              : '' )
      . ($attribs->{'type'}       ? '=' . $types->{$attribs->{type}} : '' );
}

sub _d {
   my ($package, undef, $line) = caller 0;
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
        map { defined $_ ? $_ : 'undef' }
        @_;
   print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
}

1;

# ###########################################################################
# End OptionParser package
# ###########################################################################

# ###########################################################################
# DSNParser package 6366
# This package is a copy without comments from the original.  The original
# with comments and its test file can be found in the SVN repository at,
#   trunk/common/DSNParser.pm
#   trunk/common/t/DSNParser.t
# See http://code.google.com/p/maatkit/wiki/Developers for more information.
# ###########################################################################
package DSNParser;

use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);
use Data::Dumper;
$Data::Dumper::Indent    = 0;
$Data::Dumper::Quotekeys = 0;

eval {
   require DBI;
};
my $have_dbi = $EVAL_ERROR ? 0 : 1;

use constant MKDEBUG => $ENV{MKDEBUG} || 0;

sub new {
   my ( $class, %args ) = @_;
   foreach my $arg ( qw(opts) ) {
      die "I need a $arg argument" unless $args{$arg};
   }
   my $self = {
      opts => {}  # h, P, u, etc.  Should come from DSN OPTIONS section in POD.
   };
   foreach my $opt ( @{$args{opts}} ) {
      if ( !$opt->{key} || !$opt->{desc} ) {
         die "Invalid DSN option: ", Dumper($opt);
      }
      MKDEBUG && _d('DSN option:',
         join(', ',
            map { "$_=" . (defined $opt->{$_} ? ($opt->{$_} || '') : 'undef') }
               keys %$opt
         )
      );
      $self->{opts}->{$opt->{key}} = {
         dsn  => $opt->{dsn},
         desc => $opt->{desc},
         copy => $opt->{copy} || 0,
      };
   }
   return bless $self, $class;
}

sub prop {
   my ( $self, $prop, $value ) = @_;
   if ( @_ > 2 ) {
      MKDEBUG && _d('Setting', $prop, 'property');
      $self->{$prop} = $value;
   }
   return $self->{$prop};
}

sub parse {
   my ( $self, $dsn, $prev, $defaults ) = @_;
   if ( !$dsn ) {
      MKDEBUG && _d('No DSN to parse');
      return;
   }
   MKDEBUG && _d('Parsing', $dsn);
   $prev     ||= {};
   $defaults ||= {};
   my %given_props;
   my %final_props;
   my $opts = $self->{opts};

   foreach my $dsn_part ( split(/,/, $dsn) ) {
      if ( my ($prop_key, $prop_val) = $dsn_part =~  m/^(.)=(.*)$/ ) {
         $given_props{$prop_key} = $prop_val;
      }
      else {
         MKDEBUG && _d('Interpreting', $dsn_part, 'as h=', $dsn_part);
         $given_props{h} = $dsn_part;
      }
   }

   foreach my $key ( keys %$opts ) {
      MKDEBUG && _d('Finding value for', $key);
      $final_props{$key} = $given_props{$key};
      if (   !defined $final_props{$key}
           && defined $prev->{$key} && $opts->{$key}->{copy} )
      {
         $final_props{$key} = $prev->{$key};
         MKDEBUG && _d('Copying value for', $key, 'from previous DSN');
      }
      if ( !defined $final_props{$key} ) {
         $final_props{$key} = $defaults->{$key};
         MKDEBUG && _d('Copying value for', $key, 'from defaults');
      }
   }

   foreach my $key ( keys %given_props ) {
      die "Unknown DSN option '$key' in '$dsn'.  For more details, "
            . "please use the --help option, or try 'perldoc $PROGRAM_NAME' "
            . "for complete documentation."
         unless exists $opts->{$key};
   }
   if ( (my $required = $self->prop('required')) ) {
      foreach my $key ( keys %$required ) {
         die "Missing required DSN option '$key' in '$dsn'.  For more details, "
               . "please use the --help option, or try 'perldoc $PROGRAM_NAME' "
               . "for complete documentation."
            unless $final_props{$key};
      }
   }

   return \%final_props;
}

sub parse_options {
   my ( $self, $o ) = @_;
   die 'I need an OptionParser object' unless ref $o eq 'OptionParser';
   my $dsn_string
      = join(',',
          map  { "$_=".$o->get($_); }
          grep { $o->has($_) && $o->get($_) }
          keys %{$self->{opts}}
        );
   MKDEBUG && _d('DSN string made from options:', $dsn_string);
   return $self->parse($dsn_string);
}

sub as_string {
   my ( $self, $dsn, $props ) = @_;
   return $dsn unless ref $dsn;
   my %allowed = $props ? map { $_=>1 } @$props : ();
   return join(',',
      map  { "$_=" . ($_ eq 'p' ? '...' : $dsn->{$_})  }
      grep { defined $dsn->{$_} && $self->{opts}->{$_} }
      grep { !$props || $allowed{$_}                   }
      sort keys %$dsn );
}

sub usage {
   my ( $self ) = @_;
   my $usage
      = "DSN syntax is key=value[,key=value...]  Allowable DSN keys:\n\n"
      . "  KEY  COPY  MEANING\n"
      . "  ===  ====  =============================================\n";
   my %opts = %{$self->{opts}};
   foreach my $key ( sort keys %opts ) {
      $usage .= "  $key    "
             .  ($opts{$key}->{copy} ? 'yes   ' : 'no    ')
             .  ($opts{$key}->{desc} || '[No description]')
             . "\n";
   }
   $usage .= "\n  If the DSN is a bareword, the word is treated as the 'h' key.\n";
   return $usage;
}

sub get_cxn_params {
   my ( $self, $info ) = @_;
   my $dsn;
   my %opts = %{$self->{opts}};
   my $driver = $self->prop('dbidriver') || '';
   if ( $driver eq 'Pg' ) {
      $dsn = 'DBI:Pg:dbname=' . ( $info->{D} || '' ) . ';'
         . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
                     grep { defined $info->{$_} }
                     qw(h P));
   }
   else {
      $dsn = 'DBI:mysql:' . ( $info->{D} || '' ) . ';'
         . join(';', map  { "$opts{$_}->{dsn}=$info->{$_}" }
                     grep { defined $info->{$_} }
                     qw(F h P S A))
         . ';mysql_read_default_group=client';
   }
   MKDEBUG && _d($dsn);
   return ($dsn, $info->{u}, $info->{p});
}

sub fill_in_dsn {
   my ( $self, $dbh, $dsn ) = @_;
   my $vars = $dbh->selectall_hashref('SHOW VARIABLES', 'Variable_name');
   my ($user, $db) = $dbh->selectrow_array('SELECT USER(), DATABASE()');
   $user =~ s/@.*//;
   $dsn->{h} ||= $vars->{hostname}->{Value};
   $dsn->{S} ||= $vars->{'socket'}->{Value};
   $dsn->{P} ||= $vars->{port}->{Value};
   $dsn->{u} ||= $user;
   $dsn->{D} ||= $db;
}

sub get_dbh {
   my ( $self, $cxn_string, $user, $pass, $opts ) = @_;
   $opts ||= {};
   my $defaults = {
      AutoCommit         => 0,
      RaiseError         => 1,
      PrintError         => 0,
      ShowErrorStatement => 1,
      mysql_enable_utf8 => ($cxn_string =~ m/charset=utf8/ ? 1 : 0),
   };
   @{$defaults}{ keys %$opts } = values %$opts;

   if ( $opts->{mysql_use_result} ) {
      $defaults->{mysql_use_result} = 1;
   }

   if ( !$have_dbi ) {
      die "Cannot connect to MySQL because the Perl DBI module is not "
         . "installed or not found.  Run 'perl -MDBI' to see the directories "
         . "that Perl searches for DBI.  If DBI is not installed, try:\n"
         . "  Debian/Ubuntu  apt-get install libdbi-perl\n"
         . "  RHEL/CentOS    yum install perl-DBI\n"
         . "  OpenSolaris    pgk install pkg:/SUNWpmdbi\n";

   }

   my $dbh;
   my $tries = 2;
   while ( !$dbh && $tries-- ) {
      MKDEBUG && _d($cxn_string, ' ', $user, ' ', $pass, ' {',
         join(', ', map { "$_=>$defaults->{$_}" } keys %$defaults ), '}');

      eval {
         $dbh = DBI->connect($cxn_string, $user, $pass, $defaults);

         if ( $cxn_string =~ m/mysql/i ) {
            my $sql;

            $sql = 'SELECT @@SQL_MODE';
            MKDEBUG && _d($dbh, $sql);
            my ($sql_mode) = $dbh->selectrow_array($sql);

            $sql = 'SET @@SQL_QUOTE_SHOW_CREATE = 1'
                 . '/*!40101, @@SQL_MODE=\'NO_AUTO_VALUE_ON_ZERO'
                 . ($sql_mode ? ",$sql_mode" : '')
                 . '\'*/';
            MKDEBUG && _d($dbh, $sql);
            $dbh->do($sql);

            if ( my ($charset) = $cxn_string =~ m/charset=(\w+)/ ) {
               $sql = "/*!40101 SET NAMES $charset*/";
               MKDEBUG && _d($dbh, ':', $sql);
               $dbh->do($sql);
               MKDEBUG && _d('Enabling charset for STDOUT');
               if ( $charset eq 'utf8' ) {
                  binmode(STDOUT, ':utf8')
                     or die "Can't binmode(STDOUT, ':utf8'): $OS_ERROR";
               }
               else {
                  binmode(STDOUT) or die "Can't binmode(STDOUT): $OS_ERROR";
               }
            }

            if ( $self->prop('set-vars') ) {
               $sql = "SET " . $self->prop('set-vars');
               MKDEBUG && _d($dbh, ':', $sql);
               $dbh->do($sql);
            }
         }
      };
      if ( !$dbh && $EVAL_ERROR ) {
         MKDEBUG && _d($EVAL_ERROR);
         if ( $EVAL_ERROR =~ m/not a compiled character set|character set utf8/ ) {
            MKDEBUG && _d('Going to try again without utf8 support');
            delete $defaults->{mysql_enable_utf8};
         }
         elsif ( $EVAL_ERROR =~ m/locate DBD\/mysql/i ) {
            die "Cannot connect to MySQL because the Perl DBD::mysql module is "
               . "not installed or not found.  Run 'perl -MDBD::mysql' to see "
               . "the directories that Perl searches for DBD::mysql.  If "
               . "DBD::mysql is not installed, try:\n"
               . "  Debian/Ubuntu  apt-get install libdbd-mysql-perl\n"
               . "  RHEL/CentOS    yum install perl-DBD-MySQL\n"
               . "  OpenSolaris    pgk install pkg:/SUNWapu13dbd-mysql\n";
         }
         if ( !$tries ) {
            die $EVAL_ERROR;
         }
      }
   }

   MKDEBUG && _d('DBH info: ',
      $dbh,
      Dumper($dbh->selectrow_hashref(
         'SELECT DATABASE(), CONNECTION_ID(), VERSION()/*!50038 , @@hostname*/')),
      'Connection info:',      $dbh->{mysql_hostinfo},
      'Character set info:',   Dumper($dbh->selectall_arrayref(
                     'SHOW VARIABLES LIKE "character_set%"', { Slice => {}})),
      '$DBD::mysql::VERSION:', $DBD::mysql::VERSION,
      '$DBI::VERSION:',        $DBI::VERSION,
   );

   return $dbh;
}

sub get_hostname {
   my ( $self, $dbh ) = @_;
   if ( my ($host) = ($dbh->{mysql_hostinfo} || '') =~ m/^(\w+) via/ ) {
      return $host;
   }
   my ( $hostname, $one ) = $dbh->selectrow_array(
      'SELECT /*!50038 @@hostname, */ 1');
   return $hostname;
}

sub disconnect {
   my ( $self, $dbh ) = @_;
   MKDEBUG && $self->print_active_handles($dbh);
   $dbh->disconnect;
}

sub print_active_handles {
   my ( $self, $thing, $level ) = @_;
   $level ||= 0;
   printf("# Active %sh: %s %s %s\n", ($thing->{Type} || 'undef'), "\t" x $level,
      $thing, (($thing->{Type} || '') eq 'st' ? $thing->{Statement} || '' : ''))
      or die "Cannot print: $OS_ERROR";
   foreach my $handle ( grep {defined} @{ $thing->{ChildHandles} } ) {
      $self->print_active_handles( $handle, $level + 1 );
   }
}

sub copy {
   my ( $self, $dsn_1, $dsn_2, %args ) = @_;
   die 'I need a dsn_1 argument' unless $dsn_1;
   die 'I need a dsn_2 argument' unless $dsn_2;
   my %new_dsn = map {
      my $key = $_;
      my $val;
      if ( $args{overwrite} ) {
         $val = defined $dsn_1->{$key} ? $dsn_1->{$key} : $dsn_2->{$key};
      }
      else {
         $val = defined $dsn_2->{$key} ? $dsn_2->{$key} : $dsn_1->{$key};
      }
      $key => $val;
   } keys %{$self->{opts}};
   return \%new_dsn;
}

sub _d {
   my ($package, undef, $line) = caller 0;
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
        map { defined $_ ? $_ : 'undef' }
        @_;
   print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
}

1;

# ###########################################################################
# End DSNParser package
# ###########################################################################

# ###########################################################################
# Quoter package 6240
# This package is a copy without comments from the original.  The original
# with comments and its test file can be found in the SVN repository at,
#   trunk/common/Quoter.pm
#   trunk/common/t/Quoter.t
# See http://code.google.com/p/maatkit/wiki/Developers for more information.
# ###########################################################################
package Quoter;

use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);

use constant MKDEBUG => $ENV{MKDEBUG} || 0;

sub new {
   my ( $class ) = @_;
   return bless {}, $class;
}

sub quote {
   my ( $self, @vals ) = @_;
   foreach my $val ( @vals ) {
      $val =~ s/`/``/g;
   }
   return join('.', map { '`' . $_ . '`' } @vals);
}

sub quote_val {
   my ( $self, $val ) = @_;

   return 'NULL' unless defined $val;         # undef = NULL
   return "''" if $val eq '';                 # blank string = ''
   return $val if $val =~ m/^0x[0-9a-fA-F]/;  # hex value like 0xe5f190

   $val =~ s/(['\\])/\\$1/g;
   return "'$val'";
}

sub split_unquote {
   my ( $self, $db_tbl, $default_db ) = @_;
   $db_tbl =~ s/`//g;
   my ( $db, $tbl ) = split(/[.]/, $db_tbl);
   if ( !$tbl ) {
      $tbl = $db;
      $db  = $default_db;
   }
   return ($db, $tbl);
}

sub literal_like {
   my ( $self, $like ) = @_;
   return unless $like;
   $like =~ s/([%_])/\\$1/g;
   return "'$like'";
}

sub join_quote {
   my ( $self, $default_db, $db_tbl ) = @_;
   return unless $db_tbl;
   my ($db, $tbl) = split(/[.]/, $db_tbl);
   if ( !$tbl ) {
      $tbl = $db;
      $db  = $default_db;
   }
   $db  = "`$db`"  if $db  && $db  !~ m/^`/;
   $tbl = "`$tbl`" if $tbl && $tbl !~ m/^`/;
   return $db ? "$db.$tbl" : $tbl;
}

1;

# ###########################################################################
# End Quoter package
# ###########################################################################

# ###########################################################################
# Daemon package 6255
# This package is a copy without comments from the original.  The original
# with comments and its test file can be found in the SVN repository at,
#   trunk/common/Daemon.pm
#   trunk/common/t/Daemon.t
# See http://code.google.com/p/maatkit/wiki/Developers for more information.
# ###########################################################################

package Daemon;

use strict;
use warnings FATAL => 'all';

use POSIX qw(setsid);
use English qw(-no_match_vars);

use constant MKDEBUG => $ENV{MKDEBUG} || 0;

sub new {
   my ( $class, %args ) = @_;
   foreach my $arg ( qw(o) ) {
      die "I need a $arg argument" unless $args{$arg};
   }
   my $o = $args{o};
   my $self = {
      o        => $o,
      log_file => $o->has('log') ? $o->get('log') : undef,
      PID_file => $o->has('pid') ? $o->get('pid') : undef,
   };

   check_PID_file(undef, $self->{PID_file});

   MKDEBUG && _d('Daemonized child will log to', $self->{log_file});
   return bless $self, $class;
}

sub daemonize {
   my ( $self ) = @_;

   MKDEBUG && _d('About to fork and daemonize');
   defined (my $pid = fork()) or die "Cannot fork: $OS_ERROR";
   if ( $pid ) {
      MKDEBUG && _d('I am the parent and now I die');
      exit;
   }

   $self->{PID_owner} = $PID;
   $self->{child}     = 1;

   POSIX::setsid() or die "Cannot start a new session: $OS_ERROR";
   chdir '/'       or die "Cannot chdir to /: $OS_ERROR";

   $self->_make_PID_file();

   $OUTPUT_AUTOFLUSH = 1;

   if ( -t STDIN ) {
      close STDIN;
      open  STDIN, '/dev/null'
         or die "Cannot reopen STDIN to /dev/null: $OS_ERROR";
   }

   if ( $self->{log_file} ) {
      close STDOUT;
      open  STDOUT, '>>', $self->{log_file}
         or die "Cannot open log file $self->{log_file}: $OS_ERROR";

      close STDERR;
      open  STDERR, ">&STDOUT"
         or die "Cannot dupe STDERR to STDOUT: $OS_ERROR"; 
   }
   else {
      if ( -t STDOUT ) {
         close STDOUT;
         open  STDOUT, '>', '/dev/null'
            or die "Cannot reopen STDOUT to /dev/null: $OS_ERROR";
      }
      if ( -t STDERR ) {
         close STDERR;
         open  STDERR, '>', '/dev/null'
            or die "Cannot reopen STDERR to /dev/null: $OS_ERROR";
      }
   }

   MKDEBUG && _d('I am the child and now I live daemonized');
   return;
}

sub check_PID_file {
   my ( $self, $file ) = @_;
   my $PID_file = $self ? $self->{PID_file} : $file;
   MKDEBUG && _d('Checking PID file', $PID_file);
   if ( $PID_file && -f $PID_file ) {
      my $pid;
      eval { chomp($pid = `cat $PID_file`); };
      die "Cannot cat $PID_file: $OS_ERROR" if $EVAL_ERROR;
      MKDEBUG && _d('PID file exists; it contains PID', $pid);
      if ( $pid ) {
         my $pid_is_alive = kill 0, $pid;
         if ( $pid_is_alive ) {
            die "The PID file $PID_file already exists "
               . " and the PID that it contains, $pid, is running";
         }
         else {
            warn "Overwriting PID file $PID_file because the PID that it "
               . "contains, $pid, is not running";
         }
      }
      else {
         die "The PID file $PID_file already exists but it does not "
            . "contain a PID";
      }
   }
   else {
      MKDEBUG && _d('No PID file');
   }
   return;
}

sub make_PID_file {
   my ( $self ) = @_;
   if ( exists $self->{child} ) {
      die "Do not call Daemon::make_PID_file() for daemonized scripts";
   }
   $self->_make_PID_file();
   $self->{PID_owner} = $PID;
   return;
}

sub _make_PID_file {
   my ( $self ) = @_;

   my $PID_file = $self->{PID_file};
   if ( !$PID_file ) {
      MKDEBUG && _d('No PID file to create');
      return;
   }

   $self->check_PID_file();

   open my $PID_FH, '>', $PID_file
      or die "Cannot open PID file $PID_file: $OS_ERROR";
   print $PID_FH $PID
      or die "Cannot print to PID file $PID_file: $OS_ERROR";
   close $PID_FH
      or die "Cannot close PID file $PID_file: $OS_ERROR";

   MKDEBUG && _d('Created PID file:', $self->{PID_file});
   return;
}

sub _remove_PID_file {
   my ( $self ) = @_;
   if ( $self->{PID_file} && -f $self->{PID_file} ) {
      unlink $self->{PID_file}
         or warn "Cannot remove PID file $self->{PID_file}: $OS_ERROR";
      MKDEBUG && _d('Removed PID file');
   }
   else {
      MKDEBUG && _d('No PID to remove');
   }
   return;
}

sub DESTROY {
   my ( $self ) = @_;

   $self->_remove_PID_file() if ($self->{PID_owner} || 0) == $PID;

   return;
}

sub _d {
   my ($package, undef, $line) = caller 0;
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
        map { defined $_ ? $_ : 'undef' }
        @_;
   print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
}

1;

# ###########################################################################
# End Daemon package
# ###########################################################################

# ###########################################################################
# Transformers package 6387
# This package is a copy without comments from the original.  The original
# with comments and its test file can be found in the SVN repository at,
#   trunk/common/Transformers.pm
#   trunk/common/t/Transformers.t
# See http://code.google.com/p/maatkit/wiki/Developers for more information.
# ###########################################################################

package Transformers;

use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);
use Time::Local qw(timegm timelocal);
use Digest::MD5 qw(md5_hex);

use constant MKDEBUG => $ENV{MKDEBUG} || 0;

require Exporter;
our @ISA         = qw(Exporter);
our %EXPORT_TAGS = ();
our @EXPORT      = ();
our @EXPORT_OK   = qw(
   micro_t
   percentage_of
   secs_to_time
   time_to_secs
   shorten
   ts
   parse_timestamp
   unix_timestamp
   any_unix_timestamp
   make_checksum
);

our $mysql_ts  = qr/(\d\d)(\d\d)(\d\d) +(\d+):(\d+):(\d+)(\.\d+)?/;
our $proper_ts = qr/(\d\d\d\d)-(\d\d)-(\d\d)[T ](\d\d):(\d\d):(\d\d)(\.\d+)?/;
our $n_ts      = qr/(\d{1,5})([shmd]?)/; # Limit \d{1,5} because \d{6} looks

sub micro_t {
   my ( $t, %args ) = @_;
   my $p_ms = defined $args{p_ms} ? $args{p_ms} : 0;  # precision for ms vals
   my $p_s  = defined $args{p_s}  ? $args{p_s}  : 0;  # precision for s vals
   my $f;

   $t = 0 if $t < 0;

   $t = sprintf('%.17f', $t) if $t =~ /e/;

   $t =~ s/\.(\d{1,6})\d*/\.$1/;

   if ($t > 0 && $t <= 0.000999) {
      $f = ($t * 1000000) . 'us';
   }
   elsif ($t >= 0.001000 && $t <= 0.999999) {
      $f = sprintf("%.${p_ms}f", $t * 1000);
      $f = ($f * 1) . 'ms'; # * 1 to remove insignificant zeros
   }
   elsif ($t >= 1) {
      $f = sprintf("%.${p_s}f", $t);
      $f = ($f * 1) . 's'; # * 1 to remove insignificant zeros
   }
   else {
      $f = 0;  # $t should = 0 at this point
   }

   return $f;
}

sub percentage_of {
   my ( $is, $of, %args ) = @_;
   my $p   = $args{p} || 0; # float precision
   my $fmt = $p ? "%.${p}f" : "%d";
   return sprintf $fmt, ($is * 100) / ($of ||= 1);
}

sub secs_to_time {
   my ( $secs, $fmt ) = @_;
   $secs ||= 0;
   return '00:00' unless $secs;

   $fmt ||= $secs >= 86_400 ? 'd'
          : $secs >= 3_600  ? 'h'
          :                   'm';

   return
      $fmt eq 'd' ? sprintf(
         "%d+%02d:%02d:%02d",
         int($secs / 86_400),
         int(($secs % 86_400) / 3_600),
         int(($secs % 3_600) / 60),
         $secs % 60)
      : $fmt eq 'h' ? sprintf(
         "%02d:%02d:%02d",
         int(($secs % 86_400) / 3_600),
         int(($secs % 3_600) / 60),
         $secs % 60)
      : sprintf(
         "%02d:%02d",
         int(($secs % 3_600) / 60),
         $secs % 60);
}

sub time_to_secs {
   my ( $val, $default_suffix ) = @_;
   die "I need a val argument" unless defined $val;
   my $t = 0;
   my ( $prefix, $num, $suffix ) = $val =~ m/([+-]?)(\d+)([a-z])?$/;
   $suffix = $suffix || $default_suffix || 's';
   if ( $suffix =~ m/[smhd]/ ) {
      $t = $suffix eq 's' ? $num * 1        # Seconds
         : $suffix eq 'm' ? $num * 60       # Minutes
         : $suffix eq 'h' ? $num * 3600     # Hours
         :                  $num * 86400;   # Days

      $t *= -1 if $prefix && $prefix eq '-';
   }
   else {
      die "Invalid suffix for $val: $suffix";
   }
   return $t;
}

sub shorten {
   my ( $num, %args ) = @_;
   my $p = defined $args{p} ? $args{p} : 2;     # float precision
   my $d = defined $args{d} ? $args{d} : 1_024; # divisor
   my $n = 0;
   my @units = ('', qw(k M G T P E Z Y));
   while ( $num >= $d && $n < @units - 1 ) {
      $num /= $d;
      ++$n;
   }
   return sprintf(
      $num =~ m/\./ || $n
         ? "%.${p}f%s"
         : '%d',
      $num, $units[$n]);
}

sub ts {
   my ( $time, $gmt ) = @_;
   my ( $sec, $min, $hour, $mday, $mon, $year )
      = $gmt ? gmtime($time) : localtime($time);
   $mon  += 1;
   $year += 1900;
   my $val = sprintf("%d-%02d-%02dT%02d:%02d:%02d",
      $year, $mon, $mday, $hour, $min, $sec);
   if ( my ($us) = $time =~ m/(\.\d+)$/ ) {
      $us = sprintf("%.6f", $us);
      $us =~ s/^0\././;
      $val .= $us;
   }
   return $val;
}

sub parse_timestamp {
   my ( $val ) = @_;
   if ( my($y, $m, $d, $h, $i, $s, $f)
         = $val =~ m/^$mysql_ts$/ )
   {
      return sprintf "%d-%02d-%02d %02d:%02d:"
                     . (defined $f ? '%09.6f' : '%02d'),
                     $y + 2000, $m, $d, $h, $i, (defined $f ? $s + $f : $s);
   }
   return $val;
}

sub unix_timestamp {
   my ( $val, $gmt ) = @_;
   if ( my($y, $m, $d, $h, $i, $s, $us) = $val =~ m/^$proper_ts$/ ) {
      $val = $gmt
         ? timegm($s, $i, $h, $d, $m - 1, $y)
         : timelocal($s, $i, $h, $d, $m - 1, $y);
      if ( defined $us ) {
         $us = sprintf('%.6f', $us);
         $us =~ s/^0\././;
         $val .= $us;
      }
   }
   return $val;
}

sub any_unix_timestamp {
   my ( $val, $callback ) = @_;

   if ( my ($n, $suffix) = $val =~ m/^$n_ts$/ ) {
      $n = $suffix eq 's' ? $n            # Seconds
         : $suffix eq 'm' ? $n * 60       # Minutes
         : $suffix eq 'h' ? $n * 3600     # Hours
         : $suffix eq 'd' ? $n * 86400    # Days
         :                  $n;           # default: Seconds
      MKDEBUG && _d('ts is now - N[shmd]:', $n);
      return time - $n;
   }
   elsif ( $val =~ m/^\d{9,}/ ) {
      MKDEBUG && _d('ts is already a unix timestamp');
      return $val;
   }
   elsif ( my ($ymd, $hms) = $val =~ m/^(\d{6})(?:\s+(\d+:\d+:\d+))?/ ) {
      MKDEBUG && _d('ts is MySQL slow log timestamp');
      $val .= ' 00:00:00' unless $hms;
      return unix_timestamp(parse_timestamp($val));
   }
   elsif ( ($ymd, $hms) = $val =~ m/^(\d{4}-\d\d-\d\d)(?:[T ](\d+:\d+:\d+))?/) {
      MKDEBUG && _d('ts is properly formatted timestamp');
      $val .= ' 00:00:00' unless $hms;
      return unix_timestamp($val);
   }
   else {
      MKDEBUG && _d('ts is MySQL expression');
      return $callback->($val) if $callback && ref $callback eq 'CODE';
   }

   MKDEBUG && _d('Unknown ts type:', $val);
   return;
}

sub make_checksum {
   my ( $val ) = @_;
   my $checksum = uc substr(md5_hex($val), -16);
   MKDEBUG && _d($checksum, 'checksum for', $val);
   return $checksum;
}

sub _d {
   my ($package, undef, $line) = caller 0;
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
        map { defined $_ ? $_ : 'undef' }
        @_;
   print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
}

1;

# ###########################################################################
# End Transformers package
# ###########################################################################

# ###########################################################################
# This is a modified copy of MMM::Agent::Helpers::Network from MMM v2.2.1.
# http://mysql-mmm.org/
# ###########################################################################
package virtual_ip;

use strict;
use warnings FATAL => 'all';
use English qw(OSNAME);

use Net::ARP;
use Time::HiRes qw(usleep);

sub check_ip {
   my ( %args ) = @_;
   my ($if, $ip, $ssh) = @args{qw(interface virtual_ip ssh)};

   my $cmd;
   if ($OSNAME eq 'linux') {
      $cmd = "/sbin/ip addr show dev $if";
   }
   elsif ($OSNAME eq 'solaris') {
      $cmd = "/usr/sbin/ifconfig -a | grep inet";
   }
   elsif ($OSNAME eq 'freebsd') {
      $cmd = "/sbin/ifconfig $if | grep inet";
   }
   else {
      die "ERROR: Unsupported platform!";
   }

   $cmd = "$ssh '$cmd'" if $ssh;
   mysql_failover::_log($cmd);
   return if $args{dry_run};

   my $output = `$cmd`;
   if ( $? >> 8 == 255 ) {
      die "Could not check if ip $ip is configured on $if: $output";
   };

   return ($output =~ /\D+$ip\D+/) ? 1 : 0;
}


sub add_ip {
   my ( %args ) = @_;
   my ($if, $ip, $ssh) = @args{qw(interface virtual_ip ssh)};

   my $cmd;
   if ($OSNAME eq 'linux') {
      $cmd = "/sbin/ip addr add $ip/32 dev $if";
   }
   elsif ($OSNAME eq 'solaris') {
      $cmd = "/usr/sbin/ifconfig $if addif $ip";
   }
   elsif ($OSNAME eq 'freebsd') {
      $cmd = "/sbin/ifconfig $if inet $ip netmask 255.255.255.255 alias";
   }
   else {
      die "ERROR: Unsupported platform!";
   }

   $cmd = "$ssh '$cmd'" if $ssh;
   mysql_failover::_log($cmd);
   return if $args{dry_run};

   my $output = `$cmd`;
   if ( $? >> 8 == 255 ) {
      die "Could not configure ip $ip on interface $if: $output";
   }

   if ( $OSNAME eq 'solaris' ) {
		my $logical_if = _solaris_find_logical_if($ip);
		if ( !$logical_if ) {
			die "ERROR: Can't find logical interface with IP = $ip";
		}
		$cmd    = "/usr/sbin/ifconfig $logical_if up";
      $output = $ssh ? `$ssh '$cmd'` : `$cmd`;
      if ( $? >> 8 == 255 ) {
   		die "Could not activate logical interface $logical_if with ip $ip "
            . "on interface: $output";
      }
   }

   return check_ip(interface=>$if, ip=>$ip);
}

sub remove_ip {
   my ( %args ) = @_;
   my ($if, $ip, $ssh) = @args{qw(interface virtual_ip ssh)};

   my $cmd;
   if ($OSNAME eq 'linux') {
      $cmd = "/sbin/ip addr del $ip/32 dev $if";
   }
   elsif ($OSNAME eq 'solaris') {
      $cmd = "/usr/sbin/ifconfig $if removeif $ip";
   }
   elsif ($OSNAME eq 'freebsd') {
      $cmd = "/sbin/ifconfig $if inet $ip -alias";
   }
   else {
      die "ERROR: Unsupportd platform!";
   }

   $cmd = "$ssh '$cmd'" if $ssh;
   mysql_failover::_log($cmd);
   return if $args{dry_run};

   my $output = `$cmd`;
   if ( $? >> 8 == 255 ) {
      die "Could not remove ip $ip from interface $if: $output";
   }

   return;
}

sub send_arp {
   my ( %args ) = @_;
   my ($if, $ip, $ssh) = @args{qw(interface virtual_ip ssh)};

   if ($OSNAME eq 'linux' || $OSNAME eq 'freebsd') {
      my $mac = '';
      if ($Net::ARP::VERSION < 1.0) {
         Net::ARP::get_mac($if, $mac);
      }
      else {
         $mac = Net::ARP::get_mac($if);
      }
      die "ERROR: Couldn't get mac adress of interface $if" unless ($mac);

      for (my $i = 0; $i < 5; $i++) {
         Net::ARP::send_packet($if, $ip, $ip, $mac, 'ff:ff:ff:ff:ff:ff', 'request');
         usleep(50);
         Net::ARP::send_packet($if, $ip, $ip, $mac, 'ff:ff:ff:ff:ff:ff', 'reply');
         usleep(50) if ($i < 4);
      }
   }
   elsif ($OSNAME eq 'solaris') {
      # Get params for send_arp
      my $ipaddr = `/usr/sbin/ifconfig $if`;

      # Get broadcast address and netmask
      $ipaddr =~ /netmask\s*([0-9a-f]+)\s*broadcast\s*([\d\.]+)/i;
      my $if_bcast = $1;
      my $if_mask = $2;
      `/bin/send_arp -i 100 -r 5 -p /tmp/send_arp $if $ip auto $if_bcast $if_mask`;
	}
	else {
		die "ERROR: Unsupported platform!";
	}

   return;
}

sub _solaris_find_logical_if($) {
   my $ip = shift;
   my $ifconfig = `/usr/sbin/ifconfig -a`;
   $ifconfig =~ s/\n/ /g;
   while ($ifconfig =~ s/([a-z0-9\:]+)(\:\s+.*?)inet\s*([0-9\.]+)//) {
      return $1 if ($3 eq $ip);
   }
   return;
}

1;

# ###########################################################################
# This is a combination of modules and programs in one -- a runnable module.
# http://www.perl.com/pub/a/2006/07/13/lightning-articles.html?page=last
# Or, look it up in the Camel book on pages 642 and 643 in the 3rd edition.
#
# Check at the end of this package for the call to main() which actually runs
# the program.
# ###########################################################################
package mysql_failover;

use strict;
use warnings FATAL => 'all';
use English qw(-no_match_vars);

use Data::Dumper;
$Data::Dumper::Indent    = 1;
$Data::Dumper::Sortkeys  = 1;
$Data::Dumper::Quotekeys = 0;

use constant MKDEBUG => $ENV{MKDEBUG} || 0;

use sigtrap 'handler', \&sig_int, 'normal-signals';

Transformers->import qw(ts secs_to_time);

my $oktorun;

sub main {
   @ARGV = @_;  # set global ARGV for this package

   # Reset global vars else testing will break.
   $oktorun = 1;

   # ##########################################################################
   # Get configuration information.
   # ##########################################################################
   my $o = new OptionParser(
      strict      => 0,
      prompt      => '[OPTION...] --servers DSN --state DSN '
                   . '--dead-master SERVER --new-master SERVER '
                   . '--live-master SERVER',
      description => 'replaces --dead-master with --new-master, connected to '
                   . '--live-master as a master-master pair.  The --servers '
                   . 'and --state tables store the positions for failover.  '
                   . 'Servers must use row-based idempotent mode replication.'

   );
   $o->get_specs();
   $o->get_opts();

   my $dp = $o->DSNParser();
   $dp->prop('set-vars', $o->get('set-vars'));

   # Check that both --servers and --state specify a database and table.
   my $q = new Quoter();
   foreach my $opt ( qw(servers state) ) {
      my $dsn = $o->get($opt);
      my ($db, $tbl) = ($dsn->{D}, $dsn->{t});
      if ( !$tbl ) {
         $o->save_error("--$opt DSN does not specify a table (t)");
      }
      else {
         # There's a table, but is there a database?
         ($db, undef) = $q->split_unquote($tbl) unless $db;
         if ( !$db ) {
            $o->save_error("--$opt DSN specifies a table (t) but not a database (D)");
         }
      }
   }

   $o->usage_or_errors();

   # ########################################################################
   # Make common modules to pass to various subroutines.
   # ########################################################################
   my %common_modules = (
      OptionParser => $o,
      DSNParser    => $dp,
      Quoter       => $q,
   );

   # ########################################################################
   # Ask for the password before daemonizing, while we still have a terminal.
   # ########################################################################
   if ( $o->get('ask-pass') ) {
      my $pass = OptionParser::prompt_noecho("Enter password: ");
      foreach my $opt ( qw(monitor update) ) {
         my $dsn   = $o->get($opt);
         $dsn->{p} = $pass;
         $o->set($opt, $dsn);
      }
   }

   # ########################################################################
   # Set, check --pid FILE.
   # ########################################################################
   my $daemon;
   if ( $o->get('pid') ) {
      # We're not daemoninzing, it just handles PID stuff.
      $daemon = new Daemon(o=>$o);
      $daemon->make_PID_file();
   }

   # #########################################################################
   # Connect to --servers.
   # #########################################################################
   _log("Connecting to --servers " . $dp->as_string($o->get('servers')));
   my $servers = {
      dbh => undef,
      dsn => $o->get('servers'),
      tbl => $q->join_quote($o->get('servers')->{D}, $o->get('servers')->{t}),
   };
   eval {
      $servers->{dbh} = get_cxn(dsn=>$servers->{dsn}, %common_modules);
   };
   if ( $EVAL_ERROR ) {
      _log("Cannot connect to --servers " . $dp->as_string($servers->{dsn})
         . ": $EVAL_ERROR");
      return 1;
   }

   # #########################################################################
   # Connect to --state.
   # #########################################################################
   _log("Connecting to --state " . $dp->as_string($o->get('state')));
   my $state = {
      dbh => undef,
      dsn => $o->get('state'),
      tbl => $q->join_quote($o->get('state')->{D}, $o->get('state')->{t}),
   };
   eval {
      $state->{dbh} = get_cxn(dsn=>$state->{dsn}, %common_modules);
   };
   if ( $EVAL_ERROR ) {
      _log("Cannot connect to --state " . $dp->as_string($state->{dsn})
         . ": $EVAL_ERROR");
      return 1;
   }

   # #########################################################################
   # Get --new-master cxn and info.
   # #########################################################################
   my $new_master;
   eval {
      $new_master = get_server_cxn(
         name    => $o->get('new-master'),
         servers => $servers,
         %common_modules,
      );
   };
   if ( $EVAL_ERROR ) {
      _log("Cannot connect to --new-master: $EVAL_ERROR");
      return 1;
   }

   # #########################################################################
   # Get --live-master cxn and info.
   # #########################################################################
   my $live_master;
   eval {
      $live_master = get_server_cxn(
         name    => $o->get('live-master'),
         servers => $servers,
         %common_modules,
      );
   };
   if ( $EVAL_ERROR ) {
      _log("Cannot connect to --live-master: $EVAL_ERROR");
      return 1;
   }

   # #########################################################################
   # Get dead master cxn and info.  If cxn fails, that's ok.  If it connects,
   # we'll use the dbh in the sanity checks performed next.
   # #########################################################################
   my $dead_master;
   eval {
      $dead_master = get_server_cxn(
         name               => $o->get('dead-master'),
         servers            => $servers,
         ignore_cxn_failure => 1,
         %common_modules,
      );
   };
   if ( $EVAL_ERROR ) {
      _log("Connection to --dead-master failed as expected: $EVAL_ERROR");
   }

   # #########################################################################
   # Sanity check the dead master.
   # #########################################################################
   my $completely_dead = 1;  # dead master is completely dead
   my $new_master_ok   = 1;  # new master is alive and isn't a master yet
   if ( $o->get('check-masters') ) {
      # XXX It is confusing to lump these two things into one function call.
      ($completely_dead, $new_master_ok) = check_masters(
         dead_master => $dead_master,
         new_master  => $new_master,
         state       => $state,
         where       => $o->get('where'),
         limit       => $o->get('limit'),
         %common_modules
      );
      _log("Check masters results:\n"
         . "#\tdead master completely dead: ".($completely_dead ? 'yes' : 'no')
         . "\n#\tnew master ok: " . ($new_master_ok ? 'yes' : 'no'));
   }

   # #########################################################################
   # If the dead master is in fact dead, or --force is specified, begin the
   # failover procedure.
   # #########################################################################
   if ( !$completely_dead || !$new_master_ok ) {
      if ( !$o->get('force') ) {
         _log("No failover because dead master is not completely dead or "
            . "new master is not ok.  Use --force to force failover.");
         return 0;
      }
      _log("Forcing failover");
   }

   my $exit_status = 0;

   if ( $o->get('move-virtual-ip') ) {
      _log("Removing virtual IP from dead master");
      eval {
         $dead_master->{ssh} = $o->get('ssh') ." $dead_master->{ssh_user_host}";
         $new_master->{ssh}  = $o->get('ssh') ." $new_master->{ssh_user_host}";
         virtual_ip::check_ip(%$dead_master,  dry_run => $o->get('dry-run'));
         virtual_ip::remove_ip(%$dead_master, dry_run => $o->get('dry-run'));
      };
      if ( $EVAL_ERROR ) {
         _log("Error removing virtual IP from dead master: " . $EVAL_ERROR);
         $exit_status |= 1;
      }
   }

   eval {
      $exit_status |= failover(
         dead_master => $dead_master,
         new_master  => $new_master,
         live_master => $live_master,
         servers     => $servers,
         state       => $state,
         dry_run     => $o->get('dry-run'),
         %common_modules
      );
   };
   if ( $EVAL_ERROR ) {
      _log("Failover procedure failed: $EVAL_ERROR");
      return 1;
   }
   
   if ( $o->get('move-virtual-ip') ) {
      _log("Add virtual IP to new master");
      eval {
         virtual_ip::add_ip(
            virtual_ip => $dead_master->{virtual_ip},
            interface  => $new_master->{interface},
            ssh        => $new_master->{ssh},
            dry_run    => $o->get('dry-run')
         );
      };
      if ( $EVAL_ERROR ) {
         _log("Error adding virtual IP to new master: " . $EVAL_ERROR);
         $exit_status |= 1;
      }
   }

   _log("Failover procedure complete"
      . ($o->get('dry-run') ? ' (DRY RUN)' : '' ));

   _log("$PROGRAM_NAME exit status $exit_status");
   return $exit_status;
} # End main()

# ############################################################################
# Subroutines.
# ############################################################################
sub check_masters {
   my ( %args ) = @_;
   my @required_args = qw(dead_master new_master state);
   foreach my $arg ( @required_args ) {
      die "I need a $arg argument" unless $args{$arg};
   }
   my ($dead_master, $new_master, $state) = @args{@required_args};

   my $completely_dead = 1;  # dead master is completely dead
   my $new_master_ok   = 1;  # new master is alive and isn't a master yet

   if ( $dead_master->{dbh} ) {
      _log("Checking dead master");
      if ( is_alive_as('master-master', $dead_master) ) {
         _log("Dead master appear to be alive as a master-master");
         $completely_dead = 0;
      }
      else {
         _log("Dead master appears to be dead as a master-master");
      }
   }

   _log("Checking state of dead master reported by observers");
   my $observed = get_observed_server_state(
      name  => $dead_master->{name},
      state => $state,
      %args
   );

   print_observations($observed->{observations});

   if ( $observed->{master_alive} || $observed->{slave_alive} ) {
      _log("Dead master appears to be alive to some observers");
      $completely_dead = 0;
   }
   else {
      _log("Dead master appears to be dead to all observers");
   }

   if ( $new_master->{dbh} ) {
      _log("Checking new master");
      # TODO:
      #if ( is_alive_as('master', $new_master) ) {
      #   _log("New master appears to be a master already");
      #   $new_master_ok = 0;
      #}
   }
   else {
      _log("No new master DBH");
      $new_master_ok = 0;
   }

   return $completely_dead, $new_master_ok;
}

sub is_alive_as {
   my ( $as, $server ) = @_;
   return unless $as;
   return unless $server;

   if ( $as =~ m/master/ ) {
      my $master_status = get_status('master', $server);
      if (    !$master_status
           || !$master_status->{file}
           || !$master_status->{position} )
      {
         return 0;
      }
   }

   if ( $as =~ m/slave|master-master/ ) {
      my $slave_status  = get_status('slave', $server);
      if (    !$slave_status
           || $slave_status->{slave_sql_running} =~ m/no/i
           || $slave_status->{slave_io_running}  =~ m/no/i )
         # XXX I think the above can be NULL.  I think all of this alive-ness
         # checking needs to be wrapped in eval, else any number of things can
         # make it fail.
      {
         return 0;
      }
   }

   return 1;
}

sub get_status {
   my ( $what, $server, $comment ) = @_;
   return unless $what;
   return unless $server;

   my $sql = "SHOW " . uc($what) . " STATUS /* $server->{name} */";
   _log($sql);
   my $status = $server->{dbh}->selectrow_hashref($sql);
   if ( $status && %$status ) {
      # lowercase the keys
      $status = { map { lc($_) => $status->{$_} } keys %$status };
      _log(
         sprintf "$server->{name} pos=%s, read=%s, exec=%s %s",
            (map { $status->{$_} || 'NULL' }
             qw(position read_master_log_pos exec_master_log_pos)),
            ($comment ? "($comment)" : '')
      );
      return $status;
   }

   return;
}

sub get_observed_server_state {
   my ( %args ) = @_;
   my @required_args = qw(name state);
   foreach my $arg ( @required_args ) {
      die "I need a $arg argument" unless $args{$arg};
   }
   my ($name, $state) = @args{@required_args};

   # Prepare a sth for selecting the observed states for this server
   # by each unique observer.
   my $sql = "SELECT * FROM $state->{tbl} WHERE server='$name' AND observer=? "
           . ($args{where} ? "AND $args{where} " : "")
           . "ORDER BY ts DESC "
           . ($args{limit} ? "LIMIT $args{limit} " : "");
   _log($sql);
   my $sth = $state->{dbh}->prepare($sql);

   # Get the states observed for this server by each observer.
   my @observations;
   my $master_alive  = undef;
   my $slave_alive   = undef;
   my $connection_ok = undef;
   foreach my $observer ( unique_observers($state) ) {
      $sth->execute($observer);
      while ( my $row = $sth->fetchrow_hashref() ) {
         # Save the entire state info.
         push @observations, $row;

         # Do a special logical AND (see _and() below) on the current value
         # and the previous value.  Basically we want to know: was the value
         # always true, always false, or sometimes both?  If, e.g., slave_alive
         # was sometimes true and sometimes false, maybe the slave is ok
         # or maybe it's not.  This depends on the optional limit arg above.
         # If limit=1 then the last observed state is all we know.
         $master_alive = _and(
            ($row->{file} && $row->{position} ? 1 : 0),
            $master_alive
         );

         $slave_alive = _and(
            ($row->{slave_io_running} || 0) && ($row->{slave_sql_running} || 0),
            $slave_alive
         );

         $connection_ok = _and(
            ($row->{connection_ok} || 0),
            $connection_ok
         );
      }

   }

   return {
      observations  => \@observations,
      master_alive  => $master_alive,
      slave_alive   => $slave_alive,
      connection_ok => $connection_ok,
   };
}

sub get_last_server_state {
   my ( %args ) = @_;
   my @required_args = qw(name state where);
   foreach my $arg ( @required_args ) {
      die "I need a $arg argument" unless $args{$arg};
   }
   my ($name, $state) = @args{@required_args};

   my $sql = "SELECT * FROM $state->{tbl} WHERE server='$name' "
           . "AND $args{where} "
           . "ORDER BY ts DESC LIMIT " . ($args{limit} || 1);
   _log($sql);
   my $sth = $state->{dbh}->prepare($sql);
   $sth->execute();

   my @states;
   while ( my $server_state = $sth->fetchrow_hashref() ) {
      push @states, $server_state;
   }

   return \@states;
}

sub unique_observers {
   my ( $state ) = @_;
   my $sql = "SELECT DISTINCT observer FROM $state->{tbl}";
   _log($sql);
   my $rows = $state->{dbh}->selectall_arrayref($sql);
   return  map { $_->[0] } @$rows;
}

sub print_observations {
   my ( $observations, $header ) = @_;
   my $txt = $header ? $header : "Observations:\n";
   my $fmt = "# %21s: %s";
   foreach my $rec ( @$observations ) {
      my $hdr =  "# by $rec->{observer} at $rec->{ts} ";
      $txt .= $hdr . ('_' x (78 - length $hdr)) . "\n";
      $txt .= join("\n",
            map {
               sprintf $fmt, $_, (defined $rec->{$_} ? $rec->{$_} : 'NULL')
            } grep { $_ !~ m/ts|observer/ } sort keys %$rec 
         );
      $txt .= "\n#\n";
   }
   _log($txt);
   return;
}

sub failover {
   my ( %args ) = @_;
   my @required_args = qw(dead_master new_master live_master servers state);
   foreach my $arg ( @required_args ) {
      die "I need a $arg argument" unless $args{$arg};
   }
   my ($dead_master, $new_master, $live_master, $servers, $state)
      = @args{@required_args};
   my $dry_run = $args{dry_run};
   
   _log("Beginning failover" . ($dry_run ? " (DRY RUN)" : ""));

   my $sql = "STOP SLAVE SQL_THREAD /* $new_master->{name} */";
   _log($sql);
   $new_master->{dbh}->do($sql) unless $dry_run;

   # See where new and live master are relative to dead master.
   my $new  = get_status('slave', $new_master);
   my $live = get_status('slave', $live_master);
   _log("New master read/exec pos on dead master: "
      . "$new->{read_master_log_pos}/$new->{exec_master_log_pos}");
   _log("Live master read/exec pos on dead master: "
      . "$live->{read_master_log_pos}/$live->{exec_master_log_pos}");

   # ########################################################################
   # Determine where to start live master on new master.
   # ########################################################################

   # When live master changes to new master it will start at this
   # new master positiion.  It's critical this pos be correct else
   # live master may miss extra events as noted in Case 2 below.
   my $new_master_status;

   # Handle two cases when new master has "extra events", i.e. when it
   # read more from dead master than live master read.  Example:
   #    new master read pos: 200
   #   live master read pos: 150
   #           extra events: 151-200
   if ( $new->{read_master_log_pos} > $live->{read_master_log_pos} ) {

      # Case 1: new master read more than live master but it did not
      # execute the extra events.  Start new master until it executes to
      # where live master read.  Then start live master at this new master
      # pos so it will get the extra events.
      if ( $new->{exec_master_log_pos} <= $live->{read_master_log_pos} ) {
         _log("New master read greater than live master read pos");
         $sql = "START SLAVE SQL_THREAD UNTIL "
              . "MASTER_LOG_FILE='$live->{relay_master_log_file}', "
              . "MASTER_LOG_POS=$live->{read_master_log_pos} "
              . "/* $new_master->{name} */";
         _log($sql);
         $new_master->{dbh}->do($sql) unless $dry_run;

         $new_master_status = get_status('master', $new_master,
            'start pos for live master');
      }
      # Case 2: new master already executed the extra events.  Start live
      # master at an earlier new master pos before it executed the extra
      # events.
      else {
         _log("New master exec pos greater than live master read pos");
         my $last_new_master_state = get_last_server_state(
            name  => $new_master->{name},
            state => $state,
            where => "exec_master_log_pos <= $live->{read_master_log_pos} "
                   . "AND relay_master_log_file = '$live->{relay_master_log_file}'",
         );
         if ( !$last_new_master_state || !@$last_new_master_state ) {
            die "Cannot determine last new master statue";
         }
         $new_master_status = $last_new_master_state->[0];
         _log("Will start live master at earlier new master position "
            . "$new_master_status->{position} in file "
            . $new_master_status->{file});
      }
   }

   # If the condition above wasn't true then new master read less events
   # than live master.  Example:
   #    new master read pos: 200 
   #   live master read pos: 300
   # We can start live master at any new master pos but to avoid
   # re-execing events we'll get $new_master_status later, after
   # new master execs everything it read.  E.g. if we start live
   # master on new master when it has only exec'ed to pos 100 of 200,
   # then live master will re-exec 100-200 and 200-300, but if we
   # wait for new master to exec to its max 200, then live master
   # will only re-exec 200-300.

   # ########################################################################
   # Determine where to start new master on live master by getting
   # dead master state at its Time Of Dead (TOD) relative to caught up
   # new master state.
   # ########################################################################

   # Wait for new master to catch up to itself, i.e. exec everything it read
   # from dead master, then get its status.  This will be as close to dead
   # master's TOD as possible.
   $sql = "START SLAVE SQL_THREAD /* $new_master->{name} */";
   _log($sql);
   $new_master->{dbh}->do($sql) unless $dry_run;
   my $slave_status = wait_for_sql_thread(%args, server => $new_master);

   if ( !$new_master_status ) {
      $new_master_status = get_status('master', $new_master,
         'start pos for live master');
   }

   # Get dead master state at its Time of Death (TOD).  Since new master
   # has just executed everything it read from dead master, dead master's
   # TOD relative to new master is when its pos was <= new master's
   # read/exec pos.  And since dead master was slaved to live master, its 
   # slave status at TOD tells us where we should start new master on
   # live master (i.e. start new master at live master pos where dead master
   # had executed to at TOD).
   my $dead_master_state = get_last_server_state(
      name  => $dead_master->{name},
      state => $state,
      where => "position <= $slave_status->{exec_master_log_pos} "
             . "AND file = '$slave_status->{relay_master_log_file}'",
   );
   if ( !$dead_master_state || @$dead_master_state == 0 ) {
      # This shouldn't happen, unless maybe only one state was observed
      # when the master was already dead.
      die "Cannot determine dead master state near time of death";
   }
   print_observations($dead_master_state,
         "Dead master state near time of death:\n");

   # Change new master from dead master to live master.
   change_master_to(
      %args,
      server          => $new_master,
      master_host     => $dead_master_state->[0]->{master_host},
      master_port     => $dead_master_state->[0]->{master_port},
      master_log_file => $dead_master_state->[0]->{relay_master_log_file},
      master_log_pos  => $dead_master_state->[0]->{exec_master_log_pos},
   );

   # ########################################################################
   # Change live master to new master.
   # ######################################################################## 
   wait_for_sql_thread(%args, server => $live_master);
   change_master_to(
      %args,
      server          => $live_master,
      master_host     => $new_master->{dsn}->{h},
      master_port     => $new_master->{dsn}->{P},
      master_log_file => $new_master_status->{file},
      master_log_pos  => $new_master_status->{position},
   ); 

   # ########################################################################
   # Allows writes to new master.
   # ########################################################################
   $sql = "SET GLOBAL read_only=0 /* $new_master->{name} */";
   _log($sql);
   $new_master->{dbh}->do($sql) unless $dry_run;

   return 0;
}

sub wait_for_sql_thread {
   my ( %args ) = @_;
   my @required_args = qw(server);
   foreach my $arg ( @required_args ) {
      die "I need a $arg argument" unless $args{$arg};
   }
   my ($server) = @args{@required_args};
   my $timeout  = $args{timeout} || 60;

   _log("Waiting for slave SQL thread to catch up to IO thread on "
      . $server->{name});

   # Use master log file and pos from slave status because
   # dead master is supposed to be dead so whatever the slave
   # is working on now should be all there is to do.
   # TODO: handle failure
   my $slave_status = get_status('slave', $server, 'before wait');
   my $file         = $slave_status->{master_log_file};
   my $pos_before   = $slave_status->{read_master_log_pos};

   my $sql = "SELECT MASTER_POS_WAIT('$file', $pos_before, $timeout) "
           . "/* $server->{name} */";
   _log($sql);

   return $slave_status if $args{dry_run};

   my $res = $server->{dbh}->selectrow_arrayref($sql)->[0];
   # TODO: handle failure better
   if ( !defined $res ) {
      die "MASTER_POS_WAIT returned NULL";
   }
   elsif ( $res == -1 ) {  # timeout exceeded
      die "MASTER_POS_WAIT timeout exceeded";
   }

   # res (result of waiting) was 0 (didn't have to wait) or >0 (waited
   # and reached pos) so slave sql pos should == io pos.  If not then
   # something or someone started the io thread.
   $slave_status = get_status('slave', $server, 'after wait');
   my $pos_after = $slave_status->{read_master_log_pos};
   if ( $pos_after > $pos_before ) {
      my $msg = "Read_Master_Log_Pos advanced from $pos_before to $pos_after "
              . "on $server->{name} while doing MASTER_POS_WAIT";
      if ( $slave_status->{slave_io_running} =~ m/yes/i ) {
         $msg .= ", and the slave IO thread was restarted";
      }
      _log($msg);
   }

   return $slave_status;
}

sub change_master_to {
   my ( %args ) = @_;
   my @required_args = qw(server master_host master_port master_log_file master_log_pos);
   foreach my $arg ( @required_args ) {
      die "I need a $arg argument" unless $args{$arg};
   }
   my ($server) = @args{@required_args};
   my $dry_run  = $args{dry_run};

   my $sql = "STOP SLAVE /* $server->{name} */";
   _log($sql);
   $server->{dbh}->do($sql) unless $dry_run;

   $sql = "CHANGE MASTER TO "
        . "MASTER_HOST='$args{master_host}', "
        . "MASTER_PORT=$args{master_port}, "
        . "MASTER_LOG_FILE='$args{master_log_file}', "
        . "MASTER_LOG_POS=$args{master_log_pos} "
        . "/* $server->{name} */";
   _log($sql);
   $server->{dbh}->do($sql) unless $dry_run;

   $sql = "START SLAVE /* $server->{name} */";
   _log($sql);
   $server->{dbh}->do($sql) unless $dry_run;  

   return;
}

sub get_server_cxn {
   my ( %args ) = @_;
   my @required_args = qw(servers name DSNParser OptionParser);
   foreach my $arg ( @required_args ) {
      die "I need a $arg argument" unless $args{$arg};
   }
   my ($servers, $name, $dp) = @args{@required_args};

   _log("Getting server $name info");
   my $sql = "SELECT * FROM $servers->{tbl} WHERE server='$name'";
   _log($sql);
   my $server = $servers->{dbh}->selectrow_hashref($sql);

   die "Server '$name' does not exist in table $servers->{tbl}"
      unless $server;
   die "Server '$name' in table $servers->{tbl} does not have a DSN"
      unless $server->{dsn};

   # The subs expect $server->{name} not $server->{server}.
   $server->{name} = $server->{server};

   # This may die if there's an invalid DSN part.
   my $dsn = $dp->parse($server->{dsn});

   # Fill in ssh user@host with defaults.
   if ( !$server->{ssh_user_host} ) {
      $server->{ssh_user_host} = "$ENV{USER}\@$dsn->{h}";
   }

   _log("Server $name info: " . Dumper($server));

   _log("Connecting to server $name");
   eval {
      my $dbh = get_cxn(dsn=>$dsn, %args);
      $dp->fill_in_dsn($dbh, $dsn);
      $server->{dsn} = $dsn;
      $server->{dbh} = $dbh;
      _log("Server '$name' DSN: " . $dp->as_string($dsn));

   };
   if ( $EVAL_ERROR && !$args{ignore_cxn_failure} ) {
      die $EVAL_ERROR;
   }

   return $server;
}

sub get_cxn {
   my ( %args ) = @_;
   my @required_args = qw(dsn DSNParser);
   foreach my $arg ( @required_args ) {
      die "I need a $arg argument" unless $args{$arg};
   }
   my ($dsn, $dp) = @args{@required_args};
   my $dbh = $dp->get_dbh($dp->get_cxn_params($dsn), {AutoCommit=>1});
   $dbh->{InactiveDestroy} = 1;  # Don't die on fork().
   MKDEBUG && _d('Connected dbh', $dbh);
   return $dbh;
}

# Catches signals so we can exit gracefully.
sub sig_int {
   my ( $signal ) = @_;
   if ( $oktorun ) {
      warn "Caught SIG$signal\n";
      $oktorun = 0;
   }
   else {
      warn "Exiting on SIG$signal\n";
      exit 1;
   }
}

# A special type of logical AND that takes into account
# the previous value of x (called y; i.e. y=previous x).
# So 0=0 all the time, 1=1 all the time, -1=sometimes 1,
# sometimes 0.
# x  y  res
# 0  0   0
# 0  1  -1
# 0 -1  -1
# 1  0  -1
# 1  1   1
# 1 -1  -1
# *  ?   x  *=any value, ?=undefined
sub _and {
   my ( $x, $y ) = @_;
   return $x unless defined $y;
   return $x if $x == $y;
   return -1;
}

sub _log {
   my ( $msg ) = @_;
   chomp $msg;
   $msg =~ s/\n/\n# /g;
   my $ts = ts(time);
   print "# $ts $msg\n";
   return;
}

sub _d {
   my ($package, undef, $line) = caller 0;
   @_ = map { (my $temp = $_) =~ s/\n/\n# /g; $temp; }
        map { defined $_ ? $_ : 'undef' }
        @_;
   print STDERR "# $package:$line $PID ", join(' ', @_), "\n";
}

# ############################################################################
# Run the program.
# ############################################################################
if ( !caller ) { exit main(@ARGV); }

1; # Because this is a module as well as a script.

# #############################################################################
# Documentation.
# #############################################################################

=pod

=head1 NAME

mysql-failover - Failover a slave to replace a dead master.

=head1 SYNOPSIS

Replace dead master1 with slave1 connected to master2 as master-master pair:

   mysql-failover                             \
      --servers     h=localhost,t=rmf.servers \
      --state       h=master2,t=rmf.state     \
      --dead-master master1                   \
      --new-master  slave1                    \
      --live-master master2

=head1 DESCRIPTION

mysql-failover is a tool for automating the failover/replacement of
a dead master with its slave in a specific replication topology:

  slave1 <- master1 <=> master2 -> slave2

B<All servers are using row-based idempotent mode replication>.  Master1 and
place of its master if the master fails.  More than one slave per master
is not currently supported.

Row-based idempotent mode replication allows the failover to work without
breaking replication because it is very likely that either the slave or the
still live master will re-execute some statements when they are connected.
This happens because the two servers are started at positions near (usually
a little before) the time of death of the dead master.  The dead master's
time of death is determined by the L<"--state"> table.  For example, if a
master dies at 03:00 and state checks are logged at 02:55 and 03:05, the
reported time of death is 03:05 and state information from (probably) 02:55
is used to connect its slave and the live master.  Therefore, the slave
and other master will probably re-execute statements written between
02:55 and 03:05.

The failover process works as follows, given this timeline of events where
C<pos> is the server's own binary log position (C<Position> from C<SHOW
MASTER STATUS>), C<read> is C<Read_Master_Log_Pos> and C<exec> is
C<Exec_Master_Log_Pos>, both from C<SHOW SLAVE STATUS>:

  TIME  SLAVE 1  <- MASTER 1 <=> MASTER 2  EVENT
  ===== ========    ========     ========  =============================
  23:55 pos  480    pos   90     pos  290  State check: all is well.
        read  90    read 190     read  80  M1 is lagging behind M2.
        exec  30    exec 140     exec  30

  00:00 pos  500   (pos  120)    pos  310  M1 dies, this state not seen.
        read 100   (read 220)    read 120  S1 has read to M1 pos 100,
        exec  50   (exec 180)    exec  50  M2 has read to M1 pos 120.
                                           Reading stops at these pos
                                           because M1 is dead.

  00:05 pos  510                 pos  330  State check: M1 is dead.
        read 100                 read 120  Begin failover.  Stop slave
        exec  60                 exec  70  IO thread on S1, wait for it
                                           to exec to last M1 pos it saw.

  00:10 pos  550                 pos  350  S1 is "caught up to" dead M1.
        read 100                 read 120  Save S1 pos 550.  Get 
        exec 100                 exec  90  state of M1 when its pos
                                           was <= 100, result:
                                           pos=90, exec=140.  Change S1
                                           master to M2 pos 140.  Stop
                                           slave IO thread on M2, wait
                                           for it to exec to last M1
                                           pos it saw.

  00:15 pos  600                 pos  380  M2 is "caught up to" dead M1.
        read 360                 read 120  Change M2 master to S1
        exec 340                 exec 120  starting at saved S1 pos 550.

  TIME  SLAVE 1  <=           => MASTER 2  EVENT
  ===== ========    ========     ========  =============================
  00:20 pos  600                 pos  490  S1 and M2 are connected and
        read 490                 read 600  synced.
        exec 490                 exec 600

At 23:55 all is well and the positions shown are saved in the L<"--state">
table.  At 00:00 master 1 (M1) dies.  This happens between checks, so although
M1 dies at positions (pos) 120/220/180, the last pos seen are 100 on S1 and
M2.  C<read> should not advance on either server since M1 is dead.

When the death of M1 is detected at 00:05 the failover begins by waiting
until its slave, S1, has executed everything it read from the master before
it died.  The tool does:

  SELECT MASTER_POS_WAIT('mysql-bin.000001', 100, 60) /* S1 */

This completes at 00:10 and we save S1 pos 550.  Since S1 has nothing else to
do, this pos will be the point at which M2 starts later.

The L<"--state"> table is searched for the last recorded state when M1 was
alive and at pos <= 100.  This results in the state recorded at 23:55 when
M1 was at pos 90 in its own binary log and had executed to pos 140 on M2.
This is, of course, slightly older and behind than when S1 thinks M1 died
(at pos 100), but it's as close as we can get.

S1 master is changed to M2 starting at pos 140, the last pos M1 had executed
to according to the state record just retrieved.  This means that S1 will
re-execute the events between M1 pos 90 and 100.  Since M2 is currently at
pos 400, S1 will have to catch up.  This also means that it won't miss any
writes made on M2 after M1 died and, therefore, didn't get replicated to S1.

While S1 is catching up to M2, we wait for M2 to catch up to dead M1.  The
code does:

  SELECT MASTER_POS_WAIT('mysql-bin.000001', 100, 60) /* M2 */

Maybe M2 already caught up to M1 while we were waiting for S1 to catch up
to M1.  In any case, we wait for M2 to execute everything it read from M1
before it died before switching its master to S1.  Although S1 is now slaved
to and reading from M2, M2 is still only slaved to dead M1 so its C<read>
should not advance and it can catch up to M1 while S1 catches up to it.

At 00:15 M2 catches up to M1 so its master is changed to S1 starting at
the S1 pos saved earlier: 550.

Now S1 and M2 are master-master and should synchronize after some time.

=head1 OPTIONS

=over

=item --ask-pass

group: Connection

Prompt for a password when connecting to MySQL.

=item --charset

short form: -A; type: string; group: Connection

Default character set.  If the value is utf8, sets Perl's binmode on
STDOUT to utf8, passes the mysql_enable_utf8 option to DBD::mysql, and
runs SET NAMES UTF8 after connecting to MySQL.  Any other value sets
binmode on STDOUT without the utf8 layer, and runs SET NAMES after
connecting to MySQL.

=item --[no]check-masters

default: yes

Perform sanity checks on L<"--dead-master"> and L<"--new-master"> before failover.

=item --config

type: Array; group: Connection

Read this comma-separated list of config files; if specified, this must be the
first option on the command line.

=item --[no]connect-to-dead-master

default: yes

Attempt connecting to L<"--dead-master"> to verify that it is truly dead.

=item --dead-master

type: string; group: Required

Dead master server (required).

=item --defaults-file

short form: -F; type: string; group: Connection

Only read mysql options from the given file.  You must give an absolute pathname.

=item --dry-run

Don't actually failover, just report what would be done.

=item --force

Force failover even if L<"--[no]check-masters"> fail.

=item --help

Show help and exit.

=item --host

short form: -h; type: string; group: Connection

Connect to host.

=item --limit

type: int; default: 1

Limit L<"--dead-master"> state history check to N most recent rows.

=item --live-master

type: string; group: Required

The 2nd, live master in the master-master pair with L<"--dead-master"> (required).

=item --[no]move-virtual-ip

default: yes

Move virtual IP from L<"--dead-master"> to L<"--new-master">.

=item --new-master

type: string; group: Required

Slave server to promote as new master in place of L<"--dead-master"> (required).

=item --password

short form: -p; type: string; group: Connection

Password to use when connecting.

=item --pid

type: string

Create the given PID file when daemonized.  The file contains the process
ID of the daemonized instance.  The PID file is removed when the
daemonized instance exits.  The program checks for the existence of the
PID file when starting; if it exists and the process with the matching PID
exists, the program exits.

=item --port

short form: -P; type: int; group: Connection

Port number to use for connection.

=item --servers

type: DSN; group: Required

Monitor each server listed in the table on this DSN (required).

This required DSN specifies the host and table which lists the servers
to monitor.  The table should already exist.  For each server, the L<"--state">
table is updated.

=item --set-vars

type: string; default: wait_timeout=10000; group: Connection

Set these MySQL variables.  Immediately after connecting to MySQL, this
string will be appended to SET and executed.

=item --socket

short form: -S; type: string; group: Connection

Socket file to use for connection.

=item --ssh

type: string; default: ssh

ssh command for L<"--[no]move-virtual-ip">.  SSH C<user@host> is set for each
server in the L<"--servers"> table C<ssh_user_host> column.

=item --state

type: DSN; group: Required

Update the state table on this DSN (required).

This required DSN specifies the host and state table to update for each
server listed in the monitored servers table on the L<"--servers"> DSN.
The state table should already exist.

=item --user

short form: -u; type: string; group: Connection

User for login if not current user.

=item --version

Show version and exit.

=item --where

type: string

Filter L<"--state"> results by this C<WHERE> clause.

For example, to select only monitor observations made within the last hour:
C<--where "ts > CURRENT_TIMESTAMP - INTERVAL 1 HOUR">.

=back

=head1 DSN OPTIONS

These DSN options are used to create a DSN.  Each option is given like
C<option=value>.  The options are case-sensitive, so P and p are not the
same option.  There cannot be whitespace before or after the C<=> and
if the value contains whitespace it must be quoted.  DSN options are
comma-separated.  See the L<maatkit> manpage for full details.

=over

=item * A

dsn: charset; copy: yes

Default character set.

=item * D

dsn: database; copy: yes

Database that contains the query review table.

=item * F

dsn: mysql_read_default_file; copy: yes

Only read default options from the given file

=item * h

dsn: host; copy: yes

Connect to host.

=item * p

dsn: password; copy: yes

Password to use when connecting.

=item * P

dsn: port; copy: yes

Port number to use for connection.

=item * S

dsn: mysql_socket; copy: yes

Socket file to use for connection.

=item * t

Table to use as the query review table.

=item * u

dsn: user; copy: yes

User for login if not current user.

=back

=head1 SYSTEM REQUIREMENTS

You need Perl and some core packages that ought to be installed in any
reasonably new version of Perl.

=head1 COPYRIGHT, LICENSE AND WARRANTY

This program is copyright 2010 Percona Inc.
Feedback and improvements are welcome.

THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.

This program is free software; you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, version 2; OR the Perl Artistic License.  On UNIX and similar
systems, you can issue `man perlgpl' or `man perlartistic' to read these
licenses.

You should have received a copy of the GNU General Public License along with
this program; if not, write to the Free Software Foundation, Inc., 59 Temple
Place, Suite 330, Boston, MA  02111-1307  USA.

=head1 AUTHOR

Daniel Nichter, Peter Zaitsev

=head1 VERSION

This manual page documents Ver @VERSION@ Distrib @DISTRIB@ $Revision: 6451 $.

=cut
